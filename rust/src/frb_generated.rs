// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::api::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.3.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1364151702;

// Section: executor

pub use crate::api::api::FLUTTER_RUST_BRIDGE_HANDLER;

// Section: wire_funcs

fn wire__crate__api__api__MessageFlags_bits_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MessageFlags_bits",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::MessageFlags::bits(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__MessageFlags_from_bits_truncate_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MessageFlags_from_bits_truncate",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_val = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::api::MessageFlags::from_bits_truncate(api_val),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_get_device_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_get_device_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.device_name.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_get_escrow_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_get_escrow",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.escrow.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_get_model_class_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_get_model_class",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.model_class.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_get_numeric_length_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_get_numeric_length",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.numeric_length.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_set_device_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_set_device_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            let api_device_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.device_name = api_device_name;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_set_escrow_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_set_escrow",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            let api_escrow = <EscrowData>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.escrow = api_escrow;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_set_model_class_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_set_model_class",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            let api_model_class = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.model_class = api_model_class;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ViableBottle_auto_accessor_set_numeric_length_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ViableBottle_auto_accessor_set_numeric_length",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
            >>::sse_decode(&mut deserializer);
            let api_numeric_length = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.numeric_length = api_numeric_length;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__add_album_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_album",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_guid = <String>::sse_decode(&mut deserializer);
            let api_folder = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::add_album(&*api_state_guard, api_guid, api_folder)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__answer_ft_request_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "answer_ft_request",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::api::api::LetMeInRequest>::sse_decode(&mut deserializer);
            let api_approved_group = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::answer_ft_request(
                            &*api_state_guard,
                            api_request,
                            api_approved_group,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__approve_circle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "approve_circle",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_txnid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::approve_circle(&*api_state_guard, api_txnid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__attachment_get_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "attachment_get_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::api::Attachment>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::Attachment::get_size(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__attachment_to_cloud_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "attachment_to_cloud",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_att = <crate::api::api::Attachment>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::attachment_to_cloud(&api_att))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__auth_phone_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "auth_phone",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_number = <String>::sse_decode(&mut deserializer);
            let api_sig = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::auth_phone(&*api_state_guard, api_number, api_sig)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__can_find_my_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "can_find_my",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::can_find_my(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__can_profile_share_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "can_profile_share",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::can_profile_share(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__can_statuskit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "can_statuskit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::can_statuskit(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__cancel_facetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_facetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_guid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::cancel_facetime(&*api_state_guard, api_guid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__certify_delivery_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "certify_delivery",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_context = <crate::api::api::CertifiedContext>::sse_decode(&mut deserializer);
            let api_notify = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::certify_delivery(
                            &*api_state_guard,
                            api_context,
                            api_notify,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__circle_setup_clique_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "circle_setup_clique",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_device_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::circle_setup_clique(
                            &*api_state_guard,
                            api_device_password,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__clone_poster_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clone_poster",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster =
                <crate::api::api::SimplifiedIncomingCallPoster>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::api::clone_poster(api_poster)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__api__clone_transcript_poster_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clone_transcript_poster",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster =
                <crate::api::api::SimplifiedTranscriptPoster>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::api::clone_transcript_poster(api_poster)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__api__complete_msg_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "complete_msg",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_ptr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::api::complete_msg(api_ptr).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__config_from_encoded_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_from_encoded",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_encoded = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::config_from_encoded(api_encoded)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__config_from_relay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_from_relay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_code = <String>::sse_decode(&mut deserializer);
            let api_host = <String>::sse_decode(&mut deserializer);
            let api_token = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::api::config_from_relay(api_code, api_host, &api_token)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__config_from_validation_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_from_validation_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_extra = <crate::api::api::HwExtra>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::api::config_from_validation_data(api_data, api_extra)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__configure_app_review_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "configure_app_review",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::configure_app_review(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__configure_macos_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "configure_macos",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_config = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_config_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_config,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_config_guard =
                                        Some(api_config.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let api_config_guard = api_config_guard.unwrap();
                        let output_ok =
                            crate::api::api::configure_macos(&*api_state_guard, &*api_config_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__convert_token_to_uuid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "convert_token_to_uuid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_handle = <String>::sse_decode(&mut deserializer);
            let api_token = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::convert_token_to_uuid(
                            &*api_state_guard,
                            api_handle,
                            api_token,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__create_facetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_facetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_uuid = <String>::sse_decode(&mut deserializer);
            let api_handle = <String>::sse_decode(&mut deserializer);
            let api_participants = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::create_facetime(
                            &*api_state_guard,
                            api_uuid,
                            api_handle,
                            api_participants,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__create_icon_array_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_icon_array",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_img = <crate::api::api::LPIconMetadata>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::create_icon_array(api_img))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__create_image_array_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_image_array",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_img = <crate::api::api::LPImageMetadata>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::create_image_array(api_img))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__date_now_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "date_now",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::date_now())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decline_facetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decline_facetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_guid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::decline_facetime(&*api_state_guard, api_guid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__decode_attachmentmeta_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_attachmentmeta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapped = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    GZipWrapper<AttachmentMeta>,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_wrapped_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapped,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapped_guard = Some(api_wrapped.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapped_guard = api_wrapped_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::api::decode_attachmentmeta(
                    &*api_wrapped_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decode_chatproto_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_chatproto",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapped = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<ChatProto>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_wrapped_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapped,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapped_guard = Some(api_wrapped.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapped_guard = api_wrapped_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::decode_chatproto(&*api_wrapped_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decode_message_info_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_message_info",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::api::decode_message_info(&api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__api__decode_messageproto_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_messageproto",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapped = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_wrapped_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapped,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapped_guard = Some(api_wrapped.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapped_guard = api_wrapped_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::decode_messageproto(&*api_wrapped_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decode_messageproto2_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_messageproto2",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapped = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto2>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_wrapped_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapped,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapped_guard = Some(api_wrapped.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapped_guard = api_wrapped_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::api::decode_messageproto2(
                    &*api_wrapped_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decode_messageproto3_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_messageproto3",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapped = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto3>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_wrapped_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapped,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapped_guard = Some(api_wrapped.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapped_guard = api_wrapped_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::api::decode_messageproto3(
                    &*api_wrapped_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decode_messageproto4_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_messageproto4",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapped = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto4>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_wrapped_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapped,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapped_guard = Some(api_wrapped.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapped_guard = api_wrapped_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::api::decode_messageproto4(
                    &*api_wrapped_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__decode_profile_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_profile_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_s = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::decode_profile_message(api_s)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__decode_summary_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_summary_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_info = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::decode_summary_info(&api_info))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__delete_attachments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_attachments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_attachments = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::delete_attachments(
                            &*api_state_guard,
                            &api_attachments,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__delete_chats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_chats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_chats = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::delete_chats(&*api_state_guard, &api_chats).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__delete_messages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_messages",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_messages = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::delete_messages(&*api_state_guard, &api_messages)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__do_reregister_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "do_reregister",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::do_reregister(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__download_attachment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_attachment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::api::TransferProgress,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_attachment = <crate::api::api::Attachment>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::api::download_attachment(
                                api_sink,
                                &*api_state_guard,
                                api_attachment,
                                api_path,
                            )
                            .await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__download_cloud_attachments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_cloud_attachments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_files = <Vec<(String, String)>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::download_cloud_attachments(
                            &*api_state_guard,
                            api_files,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__download_cloud_group_photos_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_cloud_group_photos",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_files = <Vec<(String, String)>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::download_cloud_group_photos(
                            &*api_state_guard,
                            api_files,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__download_mmcs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_mmcs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::api::TransferProgress,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_attachment = <crate::api::api::MMCSFile>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::api::download_mmcs(
                                api_sink,
                                &*api_state_guard,
                                api_attachment,
                                api_path,
                            )
                            .await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__encode_attachmentmeta_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_attachmentmeta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_attachmentmeta =
                <crate::api::api::AttachmentMeta>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::encode_attachmentmeta(
                    &api_attachmentmeta,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_chatproto_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_chatproto",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chat = <crate::api::api::ChatProto>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::encode_chatproto(&api_chat))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_hex_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_hex",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::api::encode_hex(&api_bytes))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__encode_message_info_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_message_info",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_info = <crate::api::api::MessageSummaryInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::encode_message_info(&api_info))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_messageproto_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_messageproto",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_messageproto = <crate::api::api::MessageProto>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::encode_messageproto(&api_messageproto))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_messageproto2_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_messageproto2",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_messageproto2 = <crate::api::api::MessageProto2>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::encode_messageproto2(&api_messageproto2))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_messageproto3_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_messageproto3",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_messageproto3 = <crate::api::api::MessageProto3>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::encode_messageproto3(&api_messageproto3))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_messageproto4_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_messageproto4",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_messageproto4 = <crate::api::api::MessageProto4>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::encode_messageproto4(&api_messageproto4))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__encode_profile_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_profile_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_p = <crate::api::api::ShareProfileMessage>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::encode_profile_message(&api_p))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__encode_summary_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_summary_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_info = <crate::api::api::MessageSummaryInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::encode_summary_info(&api_info))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__extension_app_from_bp_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "extension_app_from_bp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_bp = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_bid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, PushError>((move || {
                let output_ok = crate::api::api::ExtensionApp::from_bp(&api_bp, &api_bid)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__extension_app_to_raw_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "extension_app_to_raw",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::api::ExtensionApp>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, PushError>((move || {
                let output_ok = crate::api::api::ExtensionApp::to_raw(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__fetch_profile_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_profile",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_message = <crate::api::api::ShareProfileMessage>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::fetch_profile(&*api_state_guard, &api_message).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__ffi_file_packager_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_file_packager_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::FFIFilePackager::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__from_poster_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "from_poster",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster =
                <crate::api::api::SimplifiedIncomingCallPoster>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::from_poster(api_poster)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__from_poster_save_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "from_poster_save",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::from_poster_save(api_poster)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__from_transcript_poster_save_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "from_transcript_poster_save",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::from_transcript_poster_save(api_poster)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__ft_sessions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ft_sessions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::ft_sessions(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__generate_udid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_udid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::api::generate_udid())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__get_2fa_code_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_2fa_code",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_2fa_code(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_2fa_sms_opts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_2fa_sms_opts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::get_2fa_sms_opts(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_albums_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_albums",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_refresh = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::get_albums(&*api_state_guard, api_refresh).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_anisette_headers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_anisette_headers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::get_anisette_headers(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_background_following_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_background_following",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::get_background_following(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_bottles_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_bottles",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_bottles(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_config_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_config_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::get_config_state(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_device_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_device_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_config = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_config_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_config,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_config_guard = Some(api_config.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_config_guard = api_config_guard.unwrap();
                        let output_ok = crate::api::api::get_device_info(&*api_config_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__get_device_info_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_device_info_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::get_device_info_state(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_devices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_devices",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    FindMyPhoneClient<DefaultAnisetteProvider>,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    true,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let mut api_client_guard = api_client_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::get_devices(&mut *api_client_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_following_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_following",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    FindMyFriendsClient<DefaultAnisetteProvider>,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    true,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let mut api_client_guard = api_client_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::get_following(&mut *api_client_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_ft_link_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_ft_link",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_usage = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::get_ft_link(&*api_state_guard, api_usage).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_handles_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_handles",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_handles(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_my_phone_handles_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_my_phone_handles",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::get_my_phone_handles(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_phase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_phase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::get_phase(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_quota_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_quota_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_quota_info(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_regstate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_regstate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_regstate(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_sms_targets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_sms_targets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_handle = <String>::sse_decode(&mut deserializer);
            let api_refresh = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_sms_targets(
                            &*api_state_guard,
                            api_handle,
                            api_refresh,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_syncstatus_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_syncstatus",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_syncstatus(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::get_token(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__get_user_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_user_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::get_user_name(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__invalidate_id_cache_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "invalidate_id_cache",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::invalidate_id_cache(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__invite_to_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "invite_to_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_handle = <String>::sse_decode(&mut deserializer);
            let api_to = <std::collections::HashMap<
                String,
                crate::api::api::StatusKitPersonalConfig,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::invite_to_channel(
                            &*api_state_guard,
                            api_handle,
                            api_to,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__is_in_clique_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_in_clique",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::is_in_clique(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__join_clique_with_bottle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "join_clique_with_bottle",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_bottle = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>,
            >>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_device_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_bottle_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_bottle,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_bottle_guard =
                                        Some(api_bottle.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let api_bottle_guard = api_bottle_guard.unwrap();
                        let output_ok = crate::api::api::join_clique_with_bottle(
                            &*api_state_guard,
                            &*api_bottle_guard,
                            api_password,
                            api_device_password,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__make_find_my_friends_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "make_find_my_friends",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::make_find_my_friends(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__make_find_my_phone_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "make_find_my_phone",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::make_find_my_phone(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__message_parts_raw_text_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "message_parts_raw_text",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::api::MessageParts>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::MessageParts::raw_text(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__my_async_runtime_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "my_async_runtime_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::MyAsyncRuntime::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__new_msg_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "new_msg",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_conversation =
                <crate::api::api::ConversationData>::sse_decode(&mut deserializer);
            let api_sender = <String>::sse_decode(&mut deserializer);
            let api_message = <crate::api::api::Message>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::new_msg(
                                &*api_state_guard,
                                api_conversation,
                                api_sender,
                                api_message,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__new_push_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "new_push_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::api::new_push_state(api_dir).await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__ns_attributed_string_decode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_attributed_string_decode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_val = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_val_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_val, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_val_guard = Some(api_val.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_val_guard = api_val_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::api::NSAttributedString::decode(
                    &*api_val_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ns_attributed_string_encode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_attributed_string_encode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::api::NSAttributedString>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::NSAttributedString::encode(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ns_null_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_null",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::ns_null())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ns_number_decode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_number_decode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_val = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_val_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_val, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_val_guard = Some(api_val.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_val_guard = api_val_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::NSNumber::decode(&*api_val_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ns_number_encode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_number_encode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::api::NSNumber>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::NSNumber::encode(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ns_string_decode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_string_decode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_val = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_val_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_val, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_val_guard = Some(api_val.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_val_guard = api_val_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::NSString::decode(&*api_val_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__ns_string_encode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ns_string_encode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::api::NSString>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::NSString::encode(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__nscoder_decode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "nscoder_decode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::nscoder_decode(&api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__nscoder_encode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "nscoder_encode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <Vec<StCollapsedValue>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::nscoder_encode(&api_value))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__pack_transcript_poster_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pack_transcript_poster",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload =
                <crate::api::api::SimplifiedTranscriptPoster>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::pack_transcript_poster(api_payload)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__parse_poster_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_poster",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster = <crate::api::api::IMessagePosterRecord>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::parse_poster(api_poster)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__parse_poster_save_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_poster_save",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster =
                <crate::api::api::SimplifiedIncomingCallPoster>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::parse_poster_save(api_poster)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__parse_transcript_poster_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_transcript_poster",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::parse_transcript_poster(api_payload)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__ptr_to_dart_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ptr_to_dart",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_ptr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::api::ptr_to_dart(api_ptr).await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__recv_wait_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "recv_wait",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::recv_wait(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__refresh_background_following_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "refresh_background_following",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::refresh_background_following(&*api_state_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__refresh_devices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "refresh_devices",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    FindMyPhoneClient<DefaultAnisetteProvider>,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_client,
                                        1,
                                        true,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let mut api_client_guard = api_client_guard.unwrap();
                        let output_ok = crate::api::api::refresh_devices(
                            &*api_state_guard,
                            &mut *api_client_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__refresh_following_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "refresh_following",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    FindMyFriendsClient<DefaultAnisetteProvider>,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_client,
                                        1,
                                        true,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let mut api_client_guard = api_client_guard.unwrap();
                        let output_ok = crate::api::api::refresh_following(
                            &*api_state_guard,
                            &mut *api_client_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__refresh_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "refresh_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::refresh_token(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__register_ids_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "register_ids",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_users = <Vec<IDSUser>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::register_ids(&*api_state_guard, &api_users).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__remove_album_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_album",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_guid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::remove_album(&*api_state_guard, api_guid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__report_messages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "report_messages",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_handle = <String>::sse_decode(&mut deserializer);
            let api_messages = <Vec<crate::api::api::ReportMessage>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::report_messages(
                            &*api_state_guard,
                            api_handle,
                            api_messages,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__request_handles_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "request_handles",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_to = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::request_handles(&*api_state_guard, api_to).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__reset_channel_keys_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_channel_keys",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::reset_channel_keys(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__reset_clique_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_clique",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_device_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::reset_clique(&*api_state_guard, api_device_password)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__reset_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_reset_hw = <bool>::sse_decode(&mut deserializer);
            let api_logout = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::reset_state(
                            &*api_state_guard,
                            api_reset_hw,
                            api_logout,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__restore_attachment_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restore_attachment",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::restore_attachment(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__restore_cloud_chat_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restore_cloud_chat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::api::restore_cloud_chat(&api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__restore_user_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restore_user",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::restore_user(api_user)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__retry_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "retry_login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::retry_login(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__save_attachment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_attachment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_att = <crate::api::api::Attachment>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::save_attachment(&api_att))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__save_attachments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_attachments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_attachments = <std::collections::HashMap<
                String,
                crate::api::api::CloudAttachment,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::save_attachments(&*api_state_guard, api_attachments)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__save_chats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_chats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_chats =
                <std::collections::HashMap<String, crate::api::api::CloudChat>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::save_chats(&*api_state_guard, api_chats).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__save_cloud_chat_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_cloud_chat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <crate::api::api::CloudChat>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::save_cloud_chat(&api_value))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__save_messages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_messages",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_messages =
                <std::collections::HashMap<String, crate::api::api::CloudMessage>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::save_messages(&*api_state_guard, api_messages).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__save_user_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_user",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_user_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_user, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_user_guard = Some(api_user.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_user_guard = api_user_guard.unwrap();
                        let output_ok = crate::api::api::save_user(&*api_user_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__select_background_friend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_background_friend",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_friend = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::select_background_friend(
                            &*api_state_guard,
                            api_friend,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__select_friend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_friend",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    FindMyFriendsClient<DefaultAnisetteProvider>,
                >,
            >>::sse_decode(&mut deserializer);
            let api_friend = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_client,
                                        1,
                                        true,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let mut api_client_guard = api_client_guard.unwrap();
                        let output_ok = crate::api::api::select_friend(
                            &*api_state_guard,
                            &mut *api_client_guard,
                            api_friend,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_msg = <crate::api::api::MessageInst>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::send(&*api_state_guard, api_msg).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__send_2fa_sms_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_2fa_sms",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_phone_id = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::send_2fa_sms(&*api_state_guard, api_phone_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__send_2fa_to_devices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_2fa_to_devices",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::send_2fa_to_devices(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__service_from_ptr_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "service_from_ptr",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_ptr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::api::service_from_ptr(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api__set_profile_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_profile",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_record =
                <crate::api::api::IMessageNicknameRecord>::sse_decode(&mut deserializer);
            let api_existing =
                <Option<crate::api::api::ShareProfileMessage>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::set_profile(
                            &*api_state_guard,
                            api_record,
                            api_existing,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__set_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_new_status = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::set_status(&*api_state_guard, api_new_status).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__subscribe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_guid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::subscribe(&*api_state_guard, api_guid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__subscribe_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_token = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::subscribe_token(&*api_state_guard, api_token).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__supports_keychain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "supports_keychain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::api::supports_keychain(&*api_state_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__supports_shared_streams_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "supports_shared_streams",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::supports_shared_streams(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__sync_attachments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_attachments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_continuation_token = <Option<Vec<u8>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::sync_attachments(
                            &*api_state_guard,
                            api_continuation_token,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__sync_chats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_chats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_continuation_token = <Option<Vec<u8>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::sync_chats(&*api_state_guard, api_continuation_token)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__sync_messages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_messages",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_continuation_token = <Option<Vec<u8>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::sync_messages(
                            &*api_state_guard,
                            api_continuation_token,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__sync_now_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_now",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::sync_now(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__teardown_2fa_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "teardown_2fa",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_action = <String>::sse_decode(&mut deserializer);
            let api_txnid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::teardown_2fa(&*api_state_guard, api_action, api_txnid)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__transcript_poster_save_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "transcript_poster_save",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_poster =
                <crate::api::api::SimplifiedTranscriptPoster>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::api::transcript_poster_save(api_poster)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api__try_auth_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_auth",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_username = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::try_auth(
                            &*api_state_guard,
                            api_username,
                            api_password,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__unsubscribe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unsubscribe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_guid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::unsubscribe(&*api_state_guard, api_guid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__update_account_headers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_account_headers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::update_account_headers(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__upload_attachment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "upload_attachment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::api::TransferProgress,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            let api_mime = <String>::sse_decode(&mut deserializer);
            let api_uti = <String>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::api::upload_attachment(
                                api_sink,
                                &*api_state_guard,
                                api_path,
                                api_mime,
                                api_uti,
                                api_name,
                            )
                            .await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__upload_cloud_attachments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "upload_cloud_attachments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_files = <Vec<(String, String)>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::upload_cloud_attachments(&*api_state_guard, api_files)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__upload_group_photo_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "upload_group_photo",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_files = <Vec<(String, String)>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::upload_group_photo(&*api_state_guard, api_files)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__upload_mmcs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "upload_mmcs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::api::MMCSTransferProgress,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::api::upload_mmcs(api_sink, &*api_state_guard, api_path)
                                .await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__use_link_for_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "use_link_for",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_old_usage = <String>::sse_decode(&mut deserializer);
            let api_usage = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::use_link_for(
                            &*api_state_guard,
                            api_old_usage,
                            api_usage,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__utm_now_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "utm_now",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::api::utm_now())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api__validate_cert_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_cert",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_user = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_user_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_user, 1, false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_user_guard =
                                        Some(api_user.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let api_user_guard = api_user_guard.unwrap();
                        let output_ok =
                            crate::api::api::validate_cert(&*api_state_guard, &*api_user_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__validate_relay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_relay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::validate_relay(&*api_state_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__validate_targets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_targets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_targets = <Vec<String>>::sse_decode(&mut deserializer);
            let api_sender = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::validate_targets(
                            &*api_state_guard,
                            api_targets,
                            api_sender,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__validate_targets_facetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_targets_facetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_targets = <Vec<String>>::sse_decode(&mut deserializer);
            let api_sender = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok = crate::api::api::validate_targets_facetime(
                            &*api_state_guard,
                            api_targets,
                            api_sender,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__verify_2fa_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "verify_2fa",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_code = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_state, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let output_ok =
                            crate::api::api::verify_2fa(&*api_state_guard, api_code).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api__verify_2fa_sms_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "verify_2fa_sms",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
            >>::sse_decode(&mut deserializer);
            let api_body = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>,
            >>::sse_decode(&mut deserializer);
            let api_code = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_state_guard = None;
                        let mut api_body_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_state, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_body, 1, false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_state_guard =
                                        Some(api_state.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_body_guard =
                                        Some(api_body.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_state_guard = api_state_guard.unwrap();
                        let api_body_guard = api_body_guard.unwrap();
                        let output_ok = crate::api::api::verify_2fa_sms(
                            &*api_state_guard,
                            &*api_body_guard,
                            api_code,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let Address = None::<crate::api::api::Address>.unwrap();
        let _: Option<String> = Address.administrative_area;
        let _: String = Address.country;
        let _: String = Address.country_code;
        let _: Option<Vec<String>> = Address.formatted_address_lines;
        let _: Option<String> = Address.locality;
        let _: Option<String> = Address.state_code;
        let _: Option<String> = Address.street_address;
        let _: Option<String> = Address.street_name;
    }
    {
        let AkData = None::<crate::api::api::AkData>.unwrap();
        let _: f32 = AkData.lat;
        let _: f32 = AkData.lng;
    }
    {
        let ApsAlert = None::<crate::api::api::ApsAlert>.unwrap();
        let _: String = ApsAlert.title;
        let _: String = ApsAlert.body;
        let _: String = ApsAlert.sbdy;
        let _: String = ApsAlert.defbtn;
        let _: String = ApsAlert.albtn;
    }
    {
        let ApsData = None::<crate::api::api::ApsData>.unwrap();
        let _: crate::api::api::ApsAlert = ApsData.alert;
    }
    {
        let Attachment = None::<crate::api::api::Attachment>.unwrap();
        let _: crate::api::api::AttachmentType = Attachment.a_type;
        let _: u64 = Attachment.part;
        let _: String = Attachment.uti_type;
        let _: String = Attachment.mime;
        let _: String = Attachment.name;
        let _: bool = Attachment.iris;
    }
    {
        let AttachmentMeta = None::<crate::api::api::AttachmentMeta>.unwrap();
        let _: Option<String> = AttachmentMeta.mime_type;
        let _: u64 = AttachmentMeta.start_date;
        let _: u64 = AttachmentMeta.total_bytes;
        let _: u32 = AttachmentMeta.transfer_state;
        let _: bool = AttachmentMeta.is_sticker;
        let _: String = AttachmentMeta.guid;
        let _: bool = AttachmentMeta.hide_attachment;
        let _: Option<crate::api::api::MMCSAttachmentMeta> = AttachmentMeta.user_info;
        let _: String = AttachmentMeta.filename;
        let _: Option<crate::api::api::AttachmentMetaExtra> = AttachmentMeta.extras;
        let _: bool = AttachmentMeta.is_outgoing;
        let _: String = AttachmentMeta.transfer_name;
        let _: u32 = AttachmentMeta.version;
        let _: Option<String> = AttachmentMeta.uti;
        let _: u64 = AttachmentMeta.created_date;
        let _: Option<String> = AttachmentMeta.pathc;
        let _: Option<String> = AttachmentMeta.md5;
    }
    {
        let AttachmentMetaExtra = None::<crate::api::api::AttachmentMetaExtra>.unwrap();
        let _: Option<u32> = AttachmentMetaExtra.preview_generation_state;
    }
    match None::<crate::api::api::AttachmentType>.unwrap() {
        crate::api::api::AttachmentType::Inline(field0) => {
            let _: Vec<u8> = field0;
        }
        crate::api::api::AttachmentType::MMCS(field0) => {
            let _: crate::api::api::MMCSFile = field0;
        }
    }
    {
        let Balloon = None::<crate::api::api::Balloon>.unwrap();
        let _: String = Balloon.url;
        let _: Option<String> = Balloon.session;
        let _: Option<crate::api::api::BalloonLayout> = Balloon.layout;
        let _: Option<String> = Balloon.ld_text;
        let _: bool = Balloon.is_live;
        let _: Option<Vec<u8>> = Balloon.icon;
    }
    match None::<crate::api::api::BalloonLayout>.unwrap() {
        crate::api::api::BalloonLayout::TemplateLayout {
            image_subtitle,
            image_title,
            caption,
            secondary_subcaption,
            tertiary_subcaption,
            subcaption,
            class,
        } => {
            let _: String = image_subtitle;
            let _: String = image_title;
            let _: String = caption;
            let _: String = secondary_subcaption;
            let _: String = tertiary_subcaption;
            let _: String = subcaption;
            let _: crate::api::api::NSDictionaryClass = class;
        }
    }
    {
        let CertifiedContext = None::<crate::api::api::CertifiedContext>.unwrap();
        let _: u32 = CertifiedContext.version;
        let _: Vec<u8> = CertifiedContext.receipt;
        let _: String = CertifiedContext.sender;
        let _: String = CertifiedContext.target;
        let _: Vec<u8> = CertifiedContext.uuid;
        let _: Vec<u8> = CertifiedContext.token;
    }
    {
        let ChangeParticipantMessage = None::<crate::api::api::ChangeParticipantMessage>.unwrap();
        let _: Vec<String> = ChangeParticipantMessage.new_participants;
        let _: u64 = ChangeParticipantMessage.group_version;
    }
    {
        let ChatProto = None::<crate::api::api::ChatProto>.unwrap();
        let _: Option<u32> = ChatProto.unk1;
    }
    {
        let CloudAttachment = None::<crate::api::api::CloudAttachment>.unwrap();
        let _: GZipWrapper<AttachmentMeta> = CloudAttachment.cm;
        let _: Asset = CloudAttachment.lqa;
    }
    {
        let CloudChat = None::<crate::api::api::CloudChat>.unwrap();
        let _: i64 = CloudChat.style;
        let _: i64 = CloudChat.is_filtered;
        let _: i64 = CloudChat.successful_query;
        let _: i64 = CloudChat.state;
        let _: String = CloudChat.chat_identifier;
        let _: String = CloudChat.group_id;
        let _: String = CloudChat.service_name;
        let _: String = CloudChat.original_group_id;
        let _: Option<crate::api::api::CloudProp> = CloudChat.properties;
        let _: Vec<crate::api::api::CloudParticipant> = CloudChat.participants;
        let _: crate::api::api::CloudProp001 = CloudChat.prop001;
        let _: i64 = CloudChat.last_read_message_timestamp;
        let _: String = CloudChat.last_addressed_handle;
        let _: String = CloudChat.guid;
        let _: Option<String> = CloudChat.display_name;
        let _: Option<GZipWrapper<ChatProto>> = CloudChat.proto001;
        let _: Option<String> = CloudChat.group_photo_guid;
        let _: Option<Asset> = CloudChat.group_photo;
    }
    {
        let CloudMessage = None::<crate::api::api::CloudMessage>.unwrap();
        let _: Option<SystemTime> = CloudMessage.utm;
        let _: i64 = CloudMessage.r#type;
        let _: i64 = CloudMessage.error;
        let _: String = CloudMessage.chat_id;
        let _: String = CloudMessage.sender;
        let _: i64 = CloudMessage.time;
        let _: Option<GZipWrapper<MessageProto2>> = CloudMessage.msg_proto_2;
        let _: String = CloudMessage.destination_caller_id;
        let _: GZipWrapper<MessageProto> = CloudMessage.msg_proto;
        let _: MessageFlags = CloudMessage.flags;
        let _: String = CloudMessage.guid;
        let _: Option<GZipWrapper<MessageProto3>> = CloudMessage.msg_proto_3;
        let _: String = CloudMessage.service;
        let _: Option<GZipWrapper<MessageProto4>> = CloudMessage.msg_proto_4;
    }
    {
        let CloudParticipant = None::<crate::api::api::CloudParticipant>.unwrap();
        let _: String = CloudParticipant.uri;
    }
    {
        let CloudProp = None::<crate::api::api::CloudProp>.unwrap();
        let _: Option<u32> = CloudProp.gpufc;
        let _: Option<u32> = CloudProp.pv;
        let _: Option<u32> = CloudProp.number_of_times_respondedto_thread;
        let _: Option<bool> = CloudProp.should_force_to_sms;
        let _: Option<String> = CloudProp.last_seen_message_guid;
        let _: Option<u32> = CloudProp.message_handshake_state;
        let _: Vec<String> = CloudProp.legacy_group_identifiers;
        let _: Option<String> = CloudProp.group_photo_guid;
        let _: Option<Date> = CloudProp.last_modification_date;
    }
    {
        let CloudProp001 = None::<crate::api::api::CloudProp001>.unwrap();
        let _: u32 = CloudProp001.syndication_type;
    }
    {
        let ConversationData = None::<crate::api::api::ConversationData>.unwrap();
        let _: Vec<String> = ConversationData.participants;
        let _: Option<String> = ConversationData.cv_name;
        let _: Option<String> = ConversationData.sender_guid;
        let _: Option<String> = ConversationData.after_guid;
    }
    match None::<crate::api::api::DeleteTarget>.unwrap() {
        crate::api::api::DeleteTarget::Chat(field0) => {
            let _: crate::api::api::OperatedChat = field0;
        }
        crate::api::api::DeleteTarget::Messages(field0) => {
            let _: Vec<String> = field0;
        }
    }
    {
        let EditMessage = None::<crate::api::api::EditMessage>.unwrap();
        let _: String = EditMessage.tuuid;
        let _: u64 = EditMessage.edit_part;
        let _: crate::api::api::MessageParts = EditMessage.new_parts;
    }
    {
        let ErrorMessage = None::<crate::api::api::ErrorMessage>.unwrap();
        let _: String = ErrorMessage.for_uuid;
        let _: u64 = ErrorMessage.status;
        let _: String = ErrorMessage.status_str;
    }
    {
        let ExtensionApp = None::<crate::api::api::ExtensionApp>.unwrap();
        let _: String = ExtensionApp.name;
        let _: Option<u64> = ExtensionApp.app_id;
        let _: String = ExtensionApp.bundle_id;
        let _: Option<crate::api::api::Balloon> = ExtensionApp.balloon;
    }
    {
        let Follow = None::<crate::api::api::Follow>.unwrap();
        let _: i64 = Follow.create_timestamp;
        let _: i64 = Follow.expires;
        let _: String = Follow.id;
        let _: Vec<String> = Follow.invitation_accepted_handles;
        let _: Vec<String> = Follow.invitation_from_handles;
        let _: bool = Follow.is_from_messages;
        let _: Option<String> = Follow.offer_id;
        let _: bool = Follow.only_in_event;
        let _: String = Follow.person_id_hash;
        let _: bool = Follow.secure_locations_capable;
        let _: bool = Follow.shallow_or_live_secure_locations_capable;
        let _: String = Follow.source;
        let _: bool = Follow.tk_permission;
        let _: i64 = Follow.update_timestamp;
        let _: Option<bool> = Follow.fallback_to_legacy_allowed;
        let _: Option<bool> = Follow.opted_not_to_share;
        let _: Option<crate::api::api::Location> = Follow.last_location;
        let _: bool = Follow.locate_in_progress;
    }
    {
        let FoundDevice = None::<crate::api::api::FoundDevice>.unwrap();
        let _: Option<String> = FoundDevice.device_model;
        let _: Option<bool> = FoundDevice.low_power_mode;
        let _: Option<i64> = FoundDevice.passcode_length;
        let _: Option<String> = FoundDevice.id;
        let _: Option<String> = FoundDevice.battery_status;
        let _: Option<bool> = FoundDevice.lost_mode_capable;
        let _: Option<f64> = FoundDevice.battery_level;
        let _: Option<bool> = FoundDevice.location_enabled;
        let _: Option<bool> = FoundDevice.is_considered_accessory;
        let _: Option<crate::api::api::Location> = FoundDevice.location;
        let _: Option<String> = FoundDevice.model_display_name;
        let _: Option<String> = FoundDevice.device_color;
        let _: Option<bool> = FoundDevice.activation_locked;
        let _: Option<i64> = FoundDevice.rm2_state;
        let _: Option<bool> = FoundDevice.loc_found_enabled;
        let _: Option<bool> = FoundDevice.nwd;
        let _: Option<String> = FoundDevice.device_status;
        let _: Option<bool> = FoundDevice.fmly_share;
        let _: std::collections::HashMap<String, bool> = FoundDevice.features;
        let _: Option<bool> = FoundDevice.this_device;
        let _: Option<bool> = FoundDevice.lost_mode_enabled;
        let _: Option<String> = FoundDevice.device_display_name;
        let _: Option<String> = FoundDevice.name;
        let _: Option<bool> = FoundDevice.can_wipe_after_lock;
        let _: Option<bool> = FoundDevice.is_mac;
        let _: Option<String> = FoundDevice.raw_device_model;
        let _: Option<String> = FoundDevice.ba_uuid;
        let _: Option<String> = FoundDevice.device_discovery_id;
        let _: Option<bool> = FoundDevice.scd;
        let _: Option<bool> = FoundDevice.location_capable;
        let _: Option<bool> = FoundDevice.wipe_in_progress;
        let _: Option<bool> = FoundDevice.dark_wake;
        let _: Option<bool> = FoundDevice.device_with_you;
        let _: Option<i64> = FoundDevice.max_msg_char;
        let _: Option<String> = FoundDevice.device_class;
    }
    {
        let FTMember = None::<crate::api::api::FTMember>.unwrap();
        let _: Option<String> = FTMember.nickname;
        let _: String = FTMember.handle;
    }
    match None::<crate::api::api::FTMessage>.unwrap() {
        crate::api::api::FTMessage::LetMeInRequest(field0) => {
            let _: crate::api::api::LetMeInRequest = field0;
        }
        crate::api::api::FTMessage::LinkChanged { guid } => {
            let _: String = guid;
        }
        crate::api::api::FTMessage::JoinEvent {
            guid,
            participant,
            handle,
            ring,
        } => {
            let _: String = guid;
            let _: u64 = participant;
            let _: String = handle;
            let _: bool = ring;
        }
        crate::api::api::FTMessage::AddMembers {
            guid,
            members,
            ring,
        } => {
            let _: String = guid;
            let _: std::collections::HashSet<crate::api::api::FTMember> = members;
            let _: bool = ring;
        }
        crate::api::api::FTMessage::RemoveMembers { guid, members } => {
            let _: String = guid;
            let _: std::collections::HashSet<crate::api::api::FTMember> = members;
        }
        crate::api::api::FTMessage::LeaveEvent {
            guid,
            participant,
            handle,
        } => {
            let _: String = guid;
            let _: u64 = participant;
            let _: String = handle;
        }
        crate::api::api::FTMessage::Ring { guid } => {
            let _: String = guid;
        }
        crate::api::api::FTMessage::Decline { guid } => {
            let _: String = guid;
        }
        crate::api::api::FTMessage::RespondedElsewhere { guid } => {
            let _: String = guid;
        }
    }
    {
        let FTParticipant = None::<crate::api::api::FTParticipant>.unwrap();
        let _: Option<String> = FTParticipant.token;
        let _: String = FTParticipant.handle;
        let _: u64 = FTParticipant.participant_id;
        let _: Option<u64> = FTParticipant.last_join_date;
        let _: Option<ConversationParticipant> = FTParticipant.active;
    }
    {
        let FTSession = None::<crate::api::api::FTSession>.unwrap();
        let _: String = FTSession.group_id;
        let _: Vec<String> = FTSession.my_handles;
        let _: std::collections::HashMap<String, crate::api::api::FTParticipant> =
            FTSession.participants;
        let _: Option<ConversationLink> = FTSession.link;
        let _: std::collections::HashSet<crate::api::api::FTMember> = FTSession.members;
        let _: String = FTSession.report_id;
        let _: Option<u64> = FTSession.start_time;
        let _: Option<u64> = FTSession.last_rekey;
        let _: bool = FTSession.is_propped;
        let _: bool = FTSession.is_ringing_inaccurate;
        let _: Option<crate::api::api::FTMode> = FTSession.mode;
        let _: std::collections::HashMap<String, u64> = FTSession.recent_member_adds;
    }
    {
        let IMessageNameRecord = None::<crate::api::api::IMessageNameRecord>.unwrap();
        let _: String = IMessageNameRecord.name;
        let _: String = IMessageNameRecord.first;
        let _: String = IMessageNameRecord.last;
    }
    {
        let IMessageNicknameRecord = None::<crate::api::api::IMessageNicknameRecord>.unwrap();
        let _: crate::api::api::IMessageNameRecord = IMessageNicknameRecord.name;
        let _: Option<Vec<u8>> = IMessageNicknameRecord.image;
        let _: Option<crate::api::api::IMessagePosterRecord> = IMessageNicknameRecord.poster;
    }
    {
        let IMessagePosterRecord = None::<crate::api::api::IMessagePosterRecord>.unwrap();
        let _: Vec<u8> = IMessagePosterRecord.low_res_poster;
        let _: Vec<u8> = IMessagePosterRecord.package;
        let _: Vec<u8> = IMessagePosterRecord.meta;
    }
    {
        let IconChangeMessage = None::<crate::api::api::IconChangeMessage>.unwrap();
        let _: Option<crate::api::api::MMCSFile> = IconChangeMessage.file;
        let _: u64 = IconChangeMessage.group_version;
    }
    {
        let IdmsCircleMessage = None::<crate::api::api::IdmsCircleMessage>.unwrap();
        let _: u32 = IdmsCircleMessage.step;
        let _: String = IdmsCircleMessage.atxnid;
        let _: Option<String> = IdmsCircleMessage.pake;
        let _: Option<i32> = IdmsCircleMessage.ec;
        let _: String = IdmsCircleMessage.idmsdata;
    }
    match None::<crate::api::api::IdmsMessage>.unwrap() {
        crate::api::api::IdmsMessage::RequestedSignIn(field0) => {
            let _: crate::api::api::IdmsRequestedSignIn = field0;
        }
        crate::api::api::IdmsMessage::TeardownSignIn(field0) => {
            let _: crate::api::api::TeardownSignIn = field0;
        }
        crate::api::api::IdmsMessage::CircleRequest(field0, field1) => {
            let _: crate::api::api::IdmsCircleMessage = field0;
            let _: Option<crate::api::api::IdmsRequestedSignIn> = field1;
        }
    }
    {
        let IdmsRequestedSignIn = None::<crate::api::api::IdmsRequestedSignIn>.unwrap();
        let _: crate::api::api::ApsData = IdmsRequestedSignIn.aps;
        let _: String = IdmsRequestedSignIn.txnid;
        let _: crate::api::api::AkData = IdmsRequestedSignIn.akdata;
        let _: String = IdmsRequestedSignIn.adsid;
    }
    {
        let IndexedMessagePart = None::<crate::api::api::IndexedMessagePart>.unwrap();
        let _: crate::api::api::MessagePart = IndexedMessagePart.part;
        let _: Option<usize> = IndexedMessagePart.idx;
        let _: Option<crate::api::api::PartExtension> = IndexedMessagePart.ext;
    }
    {
        let LetMeInRequest = None::<crate::api::api::LetMeInRequest>.unwrap();
        let _: Vec<u8> = LetMeInRequest.shared_secret;
        let _: String = LetMeInRequest.pseud;
        let _: String = LetMeInRequest.requestor;
        let _: Option<String> = LetMeInRequest.nickname;
        let _: Vec<u8> = LetMeInRequest.token;
        let _: Option<String> = LetMeInRequest.delegation_uuid;
        let _: Option<String> = LetMeInRequest.usage;
    }
    {
        let LinkMeta = None::<crate::api::api::LinkMeta>.unwrap();
        let _: crate::api::api::LPLinkMetadata = LinkMeta.data;
        let _: Vec<Vec<u8>> = LinkMeta.attachments;
    }
    {
        let Location = None::<crate::api::api::Location>.unwrap();
        let _: Option<crate::api::api::Address> = Location.address;
        let _: f64 = Location.altitude;
        let _: i64 = Location.floor_level;
        let _: f64 = Location.horizontal_accuracy;
        let _: bool = Location.is_inaccurate;
        let _: f64 = Location.latitude;
        let _: Option<String> = Location.location_id;
        let _: Option<i64> = Location.location_timestamp;
        let _: f64 = Location.longitude;
        let _: i64 = Location.secure_location_ts;
        let _: i64 = Location.timestamp;
        let _: f64 = Location.vertical_accuracy;
        let _: Option<String> = Location.position_type;
        let _: Option<bool> = Location.is_old;
        let _: Option<bool> = Location.location_finished;
    }
    match None::<crate::api::api::LoginState>.unwrap() {
        crate::api::api::LoginState::LoggedIn => {}
        crate::api::api::LoginState::NeedsDevice2FA => {}
        crate::api::api::LoginState::Needs2FAVerification => {}
        crate::api::api::LoginState::NeedsSMS2FA => {}
        crate::api::api::LoginState::NeedsSMS2FAVerification(field0) => {
            let _: VerifyBody = field0;
        }
        crate::api::api::LoginState::NeedsExtraStep(field0) => {
            let _: String = field0;
        }
        crate::api::api::LoginState::NeedsLogin => {}
    }
    {
        let LPIconMetadata = None::<crate::api::api::LPIconMetadata>.unwrap();
        let _: crate::api::api::NSURL = LPIconMetadata.url;
        let _: u8 = LPIconMetadata.version;
    }
    {
        let LPImageMetadata = None::<crate::api::api::LPImageMetadata>.unwrap();
        let _: String = LPImageMetadata.size;
        let _: crate::api::api::NSURL = LPImageMetadata.url;
        let _: u8 = LPImageMetadata.version;
    }
    {
        let LPLinkMetadata = None::<crate::api::api::LPLinkMetadata>.unwrap();
        let _: Option<crate::api::api::LPImageMetadata> = LPLinkMetadata.image_metadata;
        let _: u8 = LPLinkMetadata.version;
        let _: Option<crate::api::api::LPIconMetadata> = LPLinkMetadata.icon_metadata;
        let _: crate::api::api::NSURL = LPLinkMetadata.original_url;
        let _: Option<crate::api::api::NSURL> = LPLinkMetadata.url;
        let _: Option<String> = LPLinkMetadata.title;
        let _: Option<String> = LPLinkMetadata.summary;
        let _: Option<crate::api::api::RichLinkImageAttachmentSubstitute> = LPLinkMetadata.image;
        let _: Option<crate::api::api::RichLinkImageAttachmentSubstitute> = LPLinkMetadata.icon;
        let _: Option<NSArray<LPImageMetadata>> = LPLinkMetadata.images;
        let _: Option<NSArray<LPIconMetadata>> = LPLinkMetadata.icons;
    }
    {
        let MemojiData = None::<crate::api::api::MemojiData>.unwrap();
        let _: crate::api::api::PosterColor = MemojiData.background_color_description;
        let _: Vec<u8> = MemojiData.avatar_record_data;
        let _: Vec<u8> = MemojiData.avatar_pose_data;
        let _: bool = MemojiData.has_body;
        let _: Vec<u8> = MemojiData.avatar_image_data;
    }
    match None::<crate::api::api::Message>.unwrap() {
        crate::api::api::Message::Message(field0) => {
            let _: crate::api::api::NormalMessage = field0;
        }
        crate::api::api::Message::RenameMessage(field0) => {
            let _: crate::api::api::RenameMessage = field0;
        }
        crate::api::api::Message::ChangeParticipants(field0) => {
            let _: crate::api::api::ChangeParticipantMessage = field0;
        }
        crate::api::api::Message::React(field0) => {
            let _: crate::api::api::ReactMessage = field0;
        }
        crate::api::api::Message::Delivered => {}
        crate::api::api::Message::Read => {}
        crate::api::api::Message::Typing(field0, field1) => {
            let _: bool = field0;
            let _: Option<crate::api::api::TypingApp> = field1;
        }
        crate::api::api::Message::Unsend(field0) => {
            let _: crate::api::api::UnsendMessage = field0;
        }
        crate::api::api::Message::Edit(field0) => {
            let _: crate::api::api::EditMessage = field0;
        }
        crate::api::api::Message::IconChange(field0) => {
            let _: crate::api::api::IconChangeMessage = field0;
        }
        crate::api::api::Message::EnableSmsActivation(field0) => {
            let _: bool = field0;
        }
        crate::api::api::Message::MessageReadOnDevice => {}
        crate::api::api::Message::SmsConfirmSent(field0) => {
            let _: bool = field0;
        }
        crate::api::api::Message::MarkUnread => {}
        crate::api::api::Message::PeerCacheInvalidate => {}
        crate::api::api::Message::UpdateExtension(field0) => {
            let _: crate::api::api::UpdateExtensionMessage = field0;
        }
        crate::api::api::Message::Error(field0) => {
            let _: crate::api::api::ErrorMessage = field0;
        }
        crate::api::api::Message::MoveToRecycleBin(field0) => {
            let _: crate::api::api::MoveToRecycleBinMessage = field0;
        }
        crate::api::api::Message::RecoverChat(field0) => {
            let _: crate::api::api::OperatedChat = field0;
        }
        crate::api::api::Message::PermanentDelete(field0) => {
            let _: crate::api::api::PermanentDeleteMessage = field0;
        }
        crate::api::api::Message::Unschedule => {}
        crate::api::api::Message::UpdateProfile(field0) => {
            let _: crate::api::api::UpdateProfileMessage = field0;
        }
        crate::api::api::Message::UpdateProfileSharing(field0) => {
            let _: crate::api::api::UpdateProfileSharingMessage = field0;
        }
        crate::api::api::Message::ShareProfile(field0) => {
            let _: crate::api::api::ShareProfileMessage = field0;
        }
        crate::api::api::Message::NotifyAnyways => {}
        crate::api::api::Message::SetTranscriptBackground(field0) => {
            let _: crate::api::api::SetTranscriptBackgroundMessage = field0;
        }
    }
    {
        let MessageEdit = None::<crate::api::api::MessageEdit>.unwrap();
        let _: Vec<u8> = MessageEdit.t;
        let _: f64 = MessageEdit.d;
        let _: Option<String> = MessageEdit.bcg;
    }
    {
        let MessageEditRange = None::<crate::api::api::MessageEditRange>.unwrap();
        let _: u32 = MessageEditRange.lo;
        let _: u32 = MessageEditRange.le;
    }
    {
        let MessageInst = None::<crate::api::api::MessageInst>.unwrap();
        let _: String = MessageInst.id;
        let _: Option<String> = MessageInst.sender;
        let _: Option<crate::api::api::ConversationData> = MessageInst.conversation;
        let _: crate::api::api::Message = MessageInst.message;
        let _: u64 = MessageInst.sent_timestamp;
        let _: Option<Vec<crate::api::api::MessageTarget>> = MessageInst.target;
        let _: bool = MessageInst.send_delivered;
        let _: bool = MessageInst.verification_failed;
        let _: Option<crate::api::api::CertifiedContext> = MessageInst.certified_context;
    }
    match None::<crate::api::api::MessagePart>.unwrap() {
        crate::api::api::MessagePart::Text(field0, field1) => {
            let _: String = field0;
            let _: crate::api::api::TextFormat = field1;
        }
        crate::api::api::MessagePart::Attachment(field0) => {
            let _: crate::api::api::Attachment = field0;
        }
        crate::api::api::MessagePart::Mention(field0, field1) => {
            let _: String = field0;
            let _: String = field1;
        }
        crate::api::api::MessagePart::Object(field0) => {
            let _: String = field0;
        }
    }
    {
        let MessageParts_ = None::<crate::api::api::MessageParts>.unwrap();
        let _: Vec<crate::api::api::IndexedMessagePart> = MessageParts_.0;
    }
    {
        let MessageProto = None::<crate::api::api::MessageProto>.unwrap();
        let _: u32 = MessageProto.unk1;
        let _: Option<String> = MessageProto.group_title;
        let _: String = MessageProto.text;
        let _: Vec<u8> = MessageProto.attributed_body;
        let _: Option<String> = MessageProto.balloon_bundle_id;
        let _: Option<Vec<u8>> = MessageProto.payload_data;
        let _: Option<Vec<u8>> = MessageProto.message_summary_info;
        let _: Option<String> = MessageProto.effect;
        let _: Option<u64> = MessageProto.date_read;
        let _: Option<u32> = MessageProto.unk10;
        let _: Option<u32> = MessageProto.unk11;
        let _: Option<u64> = MessageProto.date_delivered;
        let _: Option<u32> = MessageProto.unk14;
        let _: Option<u32> = MessageProto.associated_message_type;
        let _: Option<String> = MessageProto.associated_message_guid;
        let _: Option<u32> = MessageProto.associated_message_range_location;
        let _: Option<u32> = MessageProto.associated_message_range_length;
    }
    {
        let MessageProto2 = None::<crate::api::api::MessageProto2>.unwrap();
        let _: Option<String> = MessageProto2.reply;
    }
    {
        let MessageProto3 = None::<crate::api::api::MessageProto3>.unwrap();
        let _: Option<u32> = MessageProto3.unk2;
        let _: Option<u32> = MessageProto3.unk3;
    }
    {
        let MessageProto4 = None::<crate::api::api::MessageProto4>.unwrap();
        let _: Option<String> = MessageProto4.associated_message_emoji;
        let _: Option<String> = MessageProto4.service;
        let _: Option<u32> = MessageProto4.schedule_type;
        let _: Option<u32> = MessageProto4.schedule_state;
        let _: Option<String> = MessageProto4.group_id;
        let _: Option<u32> = MessageProto4.sent_or_received_off_grid;
    }
    {
        let MessageSummaryInfo = None::<crate::api::api::MessageSummaryInfo>.unwrap();
        let _: Option<String> = MessageSummaryInfo.ams;
        let _: Option<Vec<u8>> = MessageSummaryInfo.ampt;
        let _: Option<u32> = MessageSummaryInfo.amc;
        let _: Option<String> = MessageSummaryInfo.amb;
        let _: Option<String> = MessageSummaryInfo.amd;
        let _: std::collections::HashMap<String, Vec<crate::api::api::MessageEdit>> =
            MessageSummaryInfo.ec;
        let _: Vec<u32> = MessageSummaryInfo.ep;
        let _: std::collections::HashMap<String, crate::api::api::MessageEditRange> =
            MessageSummaryInfo.otr;
        let _: Option<bool> = MessageSummaryInfo.ust;
        let _: Vec<u32> = MessageSummaryInfo.rp;
        let _: Option<bool> = MessageSummaryInfo.hbr;
        let _: Option<String> = MessageSummaryInfo.oui;
        let _: Option<String> = MessageSummaryInfo.osn;
        let _: Vec<String> = MessageSummaryInfo.euh;
    }
    match None::<crate::api::api::MessageTarget>.unwrap() {
        crate::api::api::MessageTarget::Token(field0) => {
            let _: Vec<u8> = field0;
        }
        crate::api::api::MessageTarget::Uuid(field0) => {
            let _: String = field0;
        }
    }
    match None::<crate::api::api::MessageType>.unwrap() {
        crate::api::api::MessageType::IMessage => {}
        crate::api::api::MessageType::SMS {
            is_phone,
            using_number,
            from_handle,
        } => {
            let _: bool = is_phone;
            let _: String = using_number;
            let _: Option<String> = from_handle;
        }
    }
    {
        let MMCSAttachmentMeta = None::<crate::api::api::MMCSAttachmentMeta>.unwrap();
        let _: String = MMCSAttachmentMeta.mmcs_signature_hex;
        let _: crate::api::api::NumOrString = MMCSAttachmentMeta.file_size;
        let _: String = MMCSAttachmentMeta.decryption_key;
        let _: Option<String> = MMCSAttachmentMeta.uti_type;
        let _: String = MMCSAttachmentMeta.mmcs_owner;
        let _: Option<String> = MMCSAttachmentMeta.mime_type;
        let _: String = MMCSAttachmentMeta.mmcs_url;
        let _: Option<String> = MMCSAttachmentMeta.name;
    }
    {
        let MMCSFile = None::<crate::api::api::MMCSFile>.unwrap();
        let _: Vec<u8> = MMCSFile.signature;
        let _: String = MMCSFile.object;
        let _: String = MMCSFile.url;
        let _: Vec<u8> = MMCSFile.key;
        let _: usize = MMCSFile.size;
    }
    {
        let MonogramData = None::<crate::api::api::MonogramData>.unwrap();
        let _: crate::api::api::PosterColor = MonogramData.top_background_color_description;
        let _: crate::api::api::PosterColor = MonogramData.background_color_description;
        let _: String = MonogramData.initials;
        let _: bool = MonogramData.monogram_supported_for_name;
    }
    {
        let MoveToRecycleBinMessage = None::<crate::api::api::MoveToRecycleBinMessage>.unwrap();
        let _: crate::api::api::DeleteTarget = MoveToRecycleBinMessage.target;
        let _: u64 = MoveToRecycleBinMessage.recoverable_delete_date;
    }
    {
        let NormalMessage = None::<crate::api::api::NormalMessage>.unwrap();
        let _: crate::api::api::MessageParts = NormalMessage.parts;
        let _: Option<String> = NormalMessage.effect;
        let _: Option<String> = NormalMessage.reply_guid;
        let _: Option<String> = NormalMessage.reply_part;
        let _: crate::api::api::MessageType = NormalMessage.service;
        let _: Option<String> = NormalMessage.subject;
        let _: Option<crate::api::api::ExtensionApp> = NormalMessage.app;
        let _: Option<crate::api::api::LinkMeta> = NormalMessage.link_meta;
        let _: bool = NormalMessage.voice;
        let _: Option<crate::api::api::ScheduleMode> = NormalMessage.scheduled;
        let _: Option<crate::api::api::ShareProfileMessage> = NormalMessage.embedded_profile;
    }
    {
        let NSAttributedString = None::<crate::api::api::NSAttributedString>.unwrap();
        let _: String = NSAttributedString.text;
        let _: Vec<(u32, crate::api::api::NSDictionaryTypedCoder)> = NSAttributedString.ranges;
    }
    {
        let NSDictionaryTypedCoder_ = None::<crate::api::api::NSDictionaryTypedCoder>.unwrap();
        let _: std::collections::HashMap<String, StCollapsedValue> = NSDictionaryTypedCoder_.0;
    }
    {
        let NSNumber_ = None::<crate::api::api::NSNumber>.unwrap();
        let _: u32 = NSNumber_.0;
    }
    {
        let NSString_ = None::<crate::api::api::NSString>.unwrap();
        let _: String = NSString_.0;
    }
    {
        let NSURL = None::<crate::api::api::NSURL>.unwrap();
        let _: String = NSURL.base;
        let _: String = NSURL.relative;
    }
    match None::<crate::api::api::NumOrString>.unwrap() {
        crate::api::api::NumOrString::Num(field0) => {
            let _: u32 = field0;
        }
        crate::api::api::NumOrString::String(field0) => {
            let _: String = field0;
        }
    }
    {
        let OperatedChat = None::<crate::api::api::OperatedChat>.unwrap();
        let _: Vec<String> = OperatedChat.participants;
        let _: String = OperatedChat.group_id;
        let _: String = OperatedChat.guid;
        let _: Option<bool> = OperatedChat.delete_incoming_messages;
        let _: Option<bool> = OperatedChat.was_reported_as_junk;
    }
    match None::<crate::api::api::PartExtension>.unwrap() {
        crate::api::api::PartExtension::Sticker {
            msg_width,
            rotation,
            sai,
            scale,
            update,
            sli,
            normalized_x,
            normalized_y,
            version,
            hash,
            safi,
            effect_type,
            sticker_id,
        } => {
            let _: f64 = msg_width;
            let _: f64 = rotation;
            let _: u64 = sai;
            let _: f64 = scale;
            let _: Option<bool> = update;
            let _: u64 = sli;
            let _: f64 = normalized_x;
            let _: f64 = normalized_y;
            let _: u64 = version;
            let _: String = hash;
            let _: u64 = safi;
            let _: i64 = effect_type;
            let _: String = sticker_id;
        }
    }
    {
        let PermanentDeleteMessage = None::<crate::api::api::PermanentDeleteMessage>.unwrap();
        let _: crate::api::api::DeleteTarget = PermanentDeleteMessage.target;
        let _: bool = PermanentDeleteMessage.is_scheduled;
    }
    {
        let PhotoPosterContents = None::<crate::api::api::PhotoPosterContents>.unwrap();
        let _: u32 = PhotoPosterContents.version;
        let _: Vec<crate::api::api::PhotoPosterLayer> = PhotoPosterContents.layers;
        let _: crate::api::api::PhotoPosterProperties = PhotoPosterContents.properties;
    }
    {
        let PhotoPosterContentsFrame = None::<crate::api::api::PhotoPosterContentsFrame>.unwrap();
        let _: f64 = PhotoPosterContentsFrame.width;
        let _: f64 = PhotoPosterContentsFrame.height;
        let _: f64 = PhotoPosterContentsFrame.x;
        let _: f64 = PhotoPosterContentsFrame.y;
    }
    {
        let PhotoPosterContentsSize = None::<crate::api::api::PhotoPosterContentsSize>.unwrap();
        let _: f64 = PhotoPosterContentsSize.width;
        let _: f64 = PhotoPosterContentsSize.height;
    }
    {
        let PhotoPosterLayer = None::<crate::api::api::PhotoPosterLayer>.unwrap();
        let _: crate::api::api::PhotoPosterContentsFrame = PhotoPosterLayer.frame;
        let _: String = PhotoPosterLayer.filename;
        let _: f32 = PhotoPosterLayer.z_position;
        let _: String = PhotoPosterLayer.identifier;
    }
    {
        let PhotoPosterLayout = None::<crate::api::api::PhotoPosterLayout>.unwrap();
        let _: u32 = PhotoPosterLayout.clock_intersection;
        let _: crate::api::api::PhotoPosterContentsSize = PhotoPosterLayout.device_resolution;
        let _: crate::api::api::PhotoPosterContentsFrame = PhotoPosterLayout.visible_frame;
        let _: crate::api::api::PhotoPosterContentsFrame = PhotoPosterLayout.time_frame;
        let _: String = PhotoPosterLayout.clock_layer_order;
        let _: bool = PhotoPosterLayout.has_top_edge_contact;
        let _: crate::api::api::PhotoPosterContentsFrame = PhotoPosterLayout.inactive_frame;
        let _: crate::api::api::PhotoPosterContentsSize = PhotoPosterLayout.image_size;
        let _: crate::api::api::PhotoPosterContentsSize = PhotoPosterLayout.parallax_padding;
    }
    {
        let PhotoPosterProperties = None::<crate::api::api::PhotoPosterProperties>.unwrap();
        let _: crate::api::api::PhotoPosterLayout = PhotoPosterProperties.portrait_layout;
        let _: bool = PhotoPosterProperties.settling_effect_enabled;
        let _: bool = PhotoPosterProperties.depth_enabled;
        let _: f64 = PhotoPosterProperties.clock_area_luminance;
        let _: bool = PhotoPosterProperties.parallax_disabled;
    }
    {
        let PosterAsset = None::<crate::api::api::PosterAsset>.unwrap();
        let _: crate::api::api::PhotoPosterContents = PosterAsset.contents;
        let _: std::collections::HashMap<String, Vec<u8>> = PosterAsset.files;
        let _: String = PosterAsset.uuid;
    }
    {
        let PosterColor = None::<crate::api::api::PosterColor>.unwrap();
        let _: f64 = PosterColor.alpha;
        let _: f64 = PosterColor.blue;
        let _: f64 = PosterColor.green;
        let _: f64 = PosterColor.red;
    }
    match None::<crate::api::api::PosterType>.unwrap() {
        crate::api::api::PosterType::Photo { assets } => {
            let _: Vec<crate::api::api::PosterAsset> = assets;
        }
        crate::api::api::PosterType::Monogram { data, background } => {
            let _: crate::api::api::MonogramData = data;
            let _: crate::api::api::PosterColor = background;
        }
        crate::api::api::PosterType::Memoji { data, background } => {
            let _: crate::api::api::MemojiData = data;
            let _: crate::api::api::PosterColor = background;
        }
        crate::api::api::PosterType::TranscriptDynamic { data } => {
            let _: crate::api::api::TranscriptDynamicUserData = data;
        }
        crate::api::api::PosterType::TranscriptGradient { colors } => {
            let _: Vec<crate::api::api::PosterColor> = colors;
        }
    }
    {
        let PRPosterColor = None::<crate::api::api::PRPosterColor>.unwrap();
        let _: u32 = PRPosterColor.preferred_style;
        let _: String = PRPosterColor.identifier;
        let _: bool = PRPosterColor.suggested;
        let _: crate::api::api::UIColor = PRPosterColor.color;
    }
    match None::<crate::api::api::PRPosterContentMaterialStyle>.unwrap() {
        crate::api::api::PRPosterContentMaterialStyle::PRPosterContentDiscreteColorsStyle {
            variation,
            colors,
            vibrant,
            supports_variation,
            needs_to_resolve_variation,
        } => {
            let _: f32 = variation;
            let _: Vec<crate::api::api::UIColor> = colors;
            let _: bool = vibrant;
            let _: bool = supports_variation;
            let _: bool = needs_to_resolve_variation;
        }
        crate::api::api::PRPosterContentMaterialStyle::PRPosterContentVibrantMaterialStyle => {}
        crate::api::api::PRPosterContentMaterialStyle::PRPosterContentGradientStyle {
            gradient_type,
            colors,
            start_point,
            locations,
            end_point,
        } => {
            let _: u32 = gradient_type;
            let _: Vec<crate::api::api::UIColor> = colors;
            let _: String = start_point;
            let _: Vec<f64> = locations;
            let _: String = end_point;
        }
    }
    {
        let PRPosterSystemTimeFontConfiguration =
            None::<crate::api::api::PRPosterSystemTimeFontConfiguration>.unwrap();
        let _: bool = PRPosterSystemTimeFontConfiguration.is_system_item;
        let _: String = PRPosterSystemTimeFontConfiguration.time_font_identifier;
        let _: f64 = PRPosterSystemTimeFontConfiguration.weight;
    }
    {
        let PRPosterTitleStyleConfiguration =
            None::<crate::api::api::PRPosterTitleStyleConfiguration>.unwrap();
        let _: bool = PRPosterTitleStyleConfiguration.alternate_date_enabled;
        let _: f64 = PRPosterTitleStyleConfiguration.contents_luminence;
        let _: String = PRPosterTitleStyleConfiguration.group_name;
        let _: u32 = PRPosterTitleStyleConfiguration.preferred_title_alignment;
        let _: u32 = PRPosterTitleStyleConfiguration.preferred_title_layout;
        let _: crate::api::api::PRPosterSystemTimeFontConfiguration =
            PRPosterTitleStyleConfiguration.time_font_configuration;
        let _: Option<Vec<u8>> = PRPosterTitleStyleConfiguration.time_numbering_system;
        let _: crate::api::api::PRPosterColor = PRPosterTitleStyleConfiguration.title_color;
        let _: Vec<u8> = PRPosterTitleStyleConfiguration.title_content_style;
        let _: bool = PRPosterTitleStyleConfiguration.user_configured;
        let _: Option<crate::api::api::PRPosterContentMaterialStyle> =
            PRPosterTitleStyleConfiguration.title_style;
    }
    {
        let PrivateDeviceInfo = None::<crate::api::api::PrivateDeviceInfo>.unwrap();
        let _: Option<String> = PrivateDeviceInfo.uuid;
        let _: Option<String> = PrivateDeviceInfo.device_name;
        let _: Vec<u8> = PrivateDeviceInfo.token;
        let _: bool = PrivateDeviceInfo.is_hsa_trusted;
        let _: Vec<String> = PrivateDeviceInfo.identites;
        let _: Vec<String> = PrivateDeviceInfo.sub_services;
    }
    {
        let ReactMessage = None::<crate::api::api::ReactMessage>.unwrap();
        let _: String = ReactMessage.to_uuid;
        let _: Option<u64> = ReactMessage.to_part;
        let _: crate::api::api::ReactMessageType = ReactMessage.reaction;
        let _: String = ReactMessage.to_text;
        let _: Option<crate::api::api::ShareProfileMessage> = ReactMessage.embedded_profile;
    }
    match None::<crate::api::api::ReactMessageType>.unwrap() {
        crate::api::api::ReactMessageType::React { reaction, enable } => {
            let _: crate::api::api::Reaction = reaction;
            let _: bool = enable;
        }
        crate::api::api::ReactMessageType::Extension {
            spec,
            body,
            is_meta,
        } => {
            let _: crate::api::api::ExtensionApp = spec;
            let _: crate::api::api::MessageParts = body;
            let _: bool = is_meta;
        }
    }
    match None::<crate::api::api::Reaction>.unwrap() {
        crate::api::api::Reaction::Heart => {}
        crate::api::api::Reaction::Like => {}
        crate::api::api::Reaction::Dislike => {}
        crate::api::api::Reaction::Laugh => {}
        crate::api::api::Reaction::Emphasize => {}
        crate::api::api::Reaction::Question => {}
        crate::api::api::Reaction::Emoji(field0) => {
            let _: String = field0;
        }
        crate::api::api::Reaction::Sticker { spec, body } => {
            let _: Option<crate::api::api::ExtensionApp> = spec;
            let _: crate::api::api::MessageParts = body;
        }
    }
    {
        let RenameMessage = None::<crate::api::api::RenameMessage>.unwrap();
        let _: String = RenameMessage.new_name;
    }
    {
        let ReportMessage = None::<crate::api::api::ReportMessage>.unwrap();
        let _: String = ReportMessage.guid;
        let _: String = ReportMessage.sender;
        let _: u32 = ReportMessage.conversation_size;
        let _: crate::api::api::MessageParts = ReportMessage.parts;
        let _: f64 = ReportMessage.time_of_message;
    }
    {
        let RichLinkImageAttachmentSubstitute =
            None::<crate::api::api::RichLinkImageAttachmentSubstitute>.unwrap();
        let _: String = RichLinkImageAttachmentSubstitute.mime_type;
        let _: u64 = RichLinkImageAttachmentSubstitute.rich_link_image_attachment_substitute_index;
    }
    {
        let ScheduleMode = None::<crate::api::api::ScheduleMode>.unwrap();
        let _: u64 = ScheduleMode.ms;
        let _: bool = ScheduleMode.schedule;
    }
    match None::<crate::api::api::SetTranscriptBackgroundMessage>.unwrap() {
        crate::api::api::SetTranscriptBackgroundMessage::Remove {
            aid,
            bid,
            chat_id,
            remove,
        } => {
            let _: u32 = aid;
            let _: u32 = bid;
            let _: Option<String> = chat_id;
            let _: bool = remove;
        }
        crate::api::api::SetTranscriptBackgroundMessage::Set {
            aid,
            bid,
            chat_id,
            object_id,
            payload_version,
            background_id,
            url,
            signature,
            key,
            file_size,
        } => {
            let _: u32 = aid;
            let _: u32 = bid;
            let _: Option<String> = chat_id;
            let _: String = object_id;
            let _: u32 = payload_version;
            let _: String = background_id;
            let _: String = url;
            let _: String = signature;
            let _: String = key;
            let _: usize = file_size;
        }
    }
    {
        let ShareProfileMessage = None::<crate::api::api::ShareProfileMessage>.unwrap();
        let _: Vec<u8> = ShareProfileMessage.cloud_kit_decryption_record_key;
        let _: String = ShareProfileMessage.cloud_kit_record_key;
        let _: Option<crate::api::api::SharedPoster> = ShareProfileMessage.poster;
    }
    {
        let SharedAlbum = None::<crate::api::api::SharedAlbum>.unwrap();
        let _: Option<String> = SharedAlbum.name;
        let _: Option<String> = SharedAlbum.fullname;
        let _: Option<String> = SharedAlbum.email;
        let _: String = SharedAlbum.albumguid;
        let _: String = SharedAlbum.sharingtype;
        let _: Option<String> = SharedAlbum.subscriptiondate;
        let _: Option<String> = SharedAlbum.albumlocation;
        let _: Vec<String> = SharedAlbum.assets;
        let _: Option<String> = SharedAlbum.delete;
    }
    {
        let SharedPoster = None::<crate::api::api::SharedPoster>.unwrap();
        let _: Vec<u8> = SharedPoster.low_res_wallpaper_tag;
        let _: Vec<u8> = SharedPoster.wallpaper_tag;
        let _: Vec<u8> = SharedPoster.message_tag;
    }
    {
        let SimplifiedIncomingCallPoster =
            None::<crate::api::api::SimplifiedIncomingCallPoster>.unwrap();
        let _: crate::api::api::SimplifiedPoster = SimplifiedIncomingCallPoster.poster;
        let _: crate::api::api::WallpaperMetadata = SimplifiedIncomingCallPoster.text_metadata;
        let _: Vec<u8> = SimplifiedIncomingCallPoster.low_res;
    }
    {
        let SimplifiedPoster = None::<crate::api::api::SimplifiedPoster>.unwrap();
        let _: crate::api::api::PRPosterTitleStyleConfiguration =
            SimplifiedPoster.title_configuration;
        let _: crate::api::api::PosterType = SimplifiedPoster.r#type;
        let _: crate::api::api::PosterRole = SimplifiedPoster.role;
    }
    {
        let SimplifiedTranscriptPoster =
            None::<crate::api::api::SimplifiedTranscriptPoster>.unwrap();
        let _: crate::api::api::WatchBackground = SimplifiedTranscriptPoster.watch;
        let _: crate::api::api::SimplifiedPoster = SimplifiedTranscriptPoster.poster;
    }
    match None::<crate::api::api::StatusKitMessage>.unwrap() {
        crate::api::api::StatusKitMessage::StatusChanged {
            user,
            mode,
            allowed,
        } => {
            let _: String = user;
            let _: Option<String> = mode;
            let _: bool = allowed;
        }
    }
    {
        let StatusKitPersonalConfig = None::<crate::api::api::StatusKitPersonalConfig>.unwrap();
        let _: Vec<String> = StatusKitPersonalConfig.allowed_modes;
    }
    {
        let SupportAction = None::<crate::api::api::SupportAction>.unwrap();
        let _: String = SupportAction.url;
        let _: String = SupportAction.button;
    }
    {
        let SupportAlert = None::<crate::api::api::SupportAlert>.unwrap();
        let _: String = SupportAlert.title;
        let _: String = SupportAlert.body;
        let _: Option<crate::api::api::SupportAction> = SupportAlert.action;
    }
    match None::<crate::api::api::SyncStatus>.unwrap() {
        crate::api::api::SyncStatus::Synced => {}
        crate::api::api::SyncStatus::Downloading { progress, total } => {
            let _: usize = progress;
            let _: usize = total;
        }
        crate::api::api::SyncStatus::Uploading { progress, total } => {
            let _: usize = progress;
            let _: usize = total;
        }
        crate::api::api::SyncStatus::Syncing => {}
    }
    {
        let TeardownSignIn = None::<crate::api::api::TeardownSignIn>.unwrap();
        let _: String = TeardownSignIn.prevtxnid;
    }
    {
        let TextFlags = None::<crate::api::api::TextFlags>.unwrap();
        let _: bool = TextFlags.bold;
        let _: bool = TextFlags.italic;
        let _: bool = TextFlags.underline;
        let _: bool = TextFlags.strikethrough;
    }
    match None::<crate::api::api::TextFormat>.unwrap() {
        crate::api::api::TextFormat::Flags(field0) => {
            let _: crate::api::api::TextFlags = field0;
        }
        crate::api::api::TextFormat::Effect(field0) => {
            let _: crate::api::api::TextEffect = field0;
        }
    }
    {
        let TranscriptDynamicUserData = None::<crate::api::api::TranscriptDynamicUserData>.unwrap();
        let _: String = TranscriptDynamicUserData.identifier;
    }
    {
        let TrustedPhoneNumber = None::<crate::api::api::TrustedPhoneNumber>.unwrap();
        let _: String = TrustedPhoneNumber.number_with_dial_code;
        let _: String = TrustedPhoneNumber.last_two_digits;
        let _: String = TrustedPhoneNumber.push_mode;
        let _: u32 = TrustedPhoneNumber.id;
    }
    {
        let TypingApp = None::<crate::api::api::TypingApp>.unwrap();
        let _: String = TypingApp.bundle_id;
        let _: Vec<u8> = TypingApp.icon;
    }
    match None::<crate::api::api::UIColor>.unwrap() {
        crate::api::api::UIColor::RGBAColorSpace {
            color_components,
            green,
            blue,
            red,
            green_dbl,
            blue_dbl,
            red_dbl,
            alpha_dbl,
            alpha,
            rgb,
            color_space,
            class,
        } => {
            let _: u32 = color_components;
            let _: f64 = green;
            let _: f64 = blue;
            let _: f64 = red;
            let _: Option<f64> = green_dbl;
            let _: Option<f64> = blue_dbl;
            let _: Option<f64> = red_dbl;
            let _: Option<f64> = alpha_dbl;
            let _: f64 = alpha;
            let _: Vec<u8> = rgb;
            let _: u32 = color_space;
            let _: String = class;
        }
        crate::api::api::UIColor::GrayscaleAlphaColorSpace {
            color_components,
            white,
            alpha,
            bin,
            color_space,
            class,
        } => {
            let _: u32 = color_components;
            let _: f64 = white;
            let _: f64 = alpha;
            let _: Vec<u8> = bin;
            let _: u32 = color_space;
            let _: String = class;
        }
    }
    {
        let UnsendMessage = None::<crate::api::api::UnsendMessage>.unwrap();
        let _: String = UnsendMessage.tuuid;
        let _: u64 = UnsendMessage.edit_part;
    }
    {
        let UpdateExtensionMessage = None::<crate::api::api::UpdateExtensionMessage>.unwrap();
        let _: String = UpdateExtensionMessage.for_uuid;
        let _: crate::api::api::PartExtension = UpdateExtensionMessage.ext;
    }
    {
        let UpdateProfileMessage = None::<crate::api::api::UpdateProfileMessage>.unwrap();
        let _: Option<crate::api::api::ShareProfileMessage> = UpdateProfileMessage.profile;
        let _: bool = UpdateProfileMessage.share_contacts;
    }
    {
        let UpdateProfileSharingMessage =
            None::<crate::api::api::UpdateProfileSharingMessage>.unwrap();
        let _: Vec<String> = UpdateProfileSharingMessage.shared_dismissed;
        let _: Vec<String> = UpdateProfileSharingMessage.shared_all;
        let _: u64 = UpdateProfileSharingMessage.version;
    }
    {
        let WallpaperMetadata = None::<crate::api::api::WallpaperMetadata>.unwrap();
        let _: Option<crate::api::api::PosterColor> = WallpaperMetadata.background_color_key;
        let _: crate::api::api::PosterColor = WallpaperMetadata.font_color_key;
        let _: String = WallpaperMetadata.font_name_key;
        let _: f32 = WallpaperMetadata.font_size_key;
        let _: f32 = WallpaperMetadata.font_weight_key;
        let _: bool = WallpaperMetadata.is_vertical_key;
        let _: String = WallpaperMetadata.type_key;
    }
    {
        let WatchBackground = None::<crate::api::api::WatchBackground>.unwrap();
        let _: bool = WatchBackground.is_high_key;
        let _: f64 = WatchBackground.luminance;
        let _: Vec<u8> = WatchBackground.background_image_data;
        let _: String = WatchBackground.extension_identifier;
    }
};

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Date>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
        FindMyFriendsClient<DefaultAnisetteProvider>,
    >
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
        FindMyPhoneClient<DefaultAnisetteProvider>,
    >
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<ChatProto>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto2>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto3>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto4>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPIconMetadata>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPImageMetadata>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for Arc<PushState> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Asset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConversationLink {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConversationParticipant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Date {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Date>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EscrowData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FindMyFriendsClient<DefaultAnisetteProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyFriendsClient<DefaultAnisetteProvider>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FindMyPhoneClient<DefaultAnisetteProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyPhoneClient<DefaultAnisetteProvider>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GZipWrapper<AttachmentMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GZipWrapper<ChatProto> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<ChatProto>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GZipWrapper<MessageProto> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GZipWrapper<MessageProto2> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto2>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GZipWrapper<MessageProto3> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto3>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GZipWrapper<MessageProto4> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto4>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for IDSUser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for JoinedOSConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MessageFlags {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for NSArray<LPIconMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPIconMetadata>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for NSArray<LPImageMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPImageMetadata>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PushError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for StCollapsedValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SystemTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for VerifyBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ViableBottle {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, Asset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, Asset)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, StCollapsedValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, StCollapsedValue)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, u64)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, bool)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::CloudAttachment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::api::api::CloudAttachment)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::CloudChat> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::api::api::CloudChat)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::CloudMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::api::api::CloudMessage)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::FTParticipant> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::api::api::FTParticipant)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, Vec<crate::api::api::MessageEdit>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, Vec<crate::api::api::MessageEdit>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, Vec<u8>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::MessageEditRange> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, crate::api::api::MessageEditRange)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, Option<crate::api::api::CloudAttachment>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, Option<crate::api::api::CloudAttachment>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, Option<crate::api::api::CloudChat>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, Option<crate::api::api::CloudChat>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, Option<crate::api::api::CloudMessage>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, Option<crate::api::api::CloudMessage>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::StatusKitPersonalConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, crate::api::api::StatusKitPersonalConfig)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, crate::api::api::SyncStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::api::api::SyncStatus)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Date>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            FindMyFriendsClient<DefaultAnisetteProvider>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            FindMyPhoneClient<DefaultAnisetteProvider>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<ChatProto>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto2>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto3>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto4>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPIconMetadata>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPImageMetadata>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for std::collections::HashSet<crate::api::api::FTMember> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<crate::api::api::FTMember>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for StreamSink<
        crate::api::api::MMCSTransferProgress,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::api::TransferProgress, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::api::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_administrativeArea = <Option<String>>::sse_decode(deserializer);
        let mut var_country = <String>::sse_decode(deserializer);
        let mut var_countryCode = <String>::sse_decode(deserializer);
        let mut var_formattedAddressLines = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_locality = <Option<String>>::sse_decode(deserializer);
        let mut var_stateCode = <Option<String>>::sse_decode(deserializer);
        let mut var_streetAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_streetName = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::Address {
            administrative_area: var_administrativeArea,
            country: var_country,
            country_code: var_countryCode,
            formatted_address_lines: var_formattedAddressLines,
            locality: var_locality,
            state_code: var_stateCode,
            street_address: var_streetAddress,
            street_name: var_streetName,
        };
    }
}

impl SseDecode for crate::api::api::AkData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lat = <f32>::sse_decode(deserializer);
        let mut var_lng = <f32>::sse_decode(deserializer);
        return crate::api::api::AkData {
            lat: var_lat,
            lng: var_lng,
        };
    }
}

impl SseDecode for crate::api::api::ApsAlert {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_body = <String>::sse_decode(deserializer);
        let mut var_sbdy = <String>::sse_decode(deserializer);
        let mut var_defbtn = <String>::sse_decode(deserializer);
        let mut var_albtn = <String>::sse_decode(deserializer);
        return crate::api::api::ApsAlert {
            title: var_title,
            body: var_body,
            sbdy: var_sbdy,
            defbtn: var_defbtn,
            albtn: var_albtn,
        };
    }
}

impl SseDecode for crate::api::api::ApsData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_alert = <crate::api::api::ApsAlert>::sse_decode(deserializer);
        return crate::api::api::ApsData { alert: var_alert };
    }
}

impl SseDecode for crate::api::api::Attachment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_aType = <crate::api::api::AttachmentType>::sse_decode(deserializer);
        let mut var_part_ = <u64>::sse_decode(deserializer);
        let mut var_utiType = <String>::sse_decode(deserializer);
        let mut var_mime = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_iris = <bool>::sse_decode(deserializer);
        return crate::api::api::Attachment {
            a_type: var_aType,
            part: var_part_,
            uti_type: var_utiType,
            mime: var_mime,
            name: var_name,
            iris: var_iris,
        };
    }
}

impl SseDecode for crate::api::api::AttachmentMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mimeType = <Option<String>>::sse_decode(deserializer);
        let mut var_startDate = <u64>::sse_decode(deserializer);
        let mut var_totalBytes = <u64>::sse_decode(deserializer);
        let mut var_transferState = <u32>::sse_decode(deserializer);
        let mut var_isSticker = <bool>::sse_decode(deserializer);
        let mut var_guid = <String>::sse_decode(deserializer);
        let mut var_hideAttachment = <bool>::sse_decode(deserializer);
        let mut var_userInfo =
            <Option<crate::api::api::MMCSAttachmentMeta>>::sse_decode(deserializer);
        let mut var_filename = <String>::sse_decode(deserializer);
        let mut var_extras =
            <Option<crate::api::api::AttachmentMetaExtra>>::sse_decode(deserializer);
        let mut var_isOutgoing = <bool>::sse_decode(deserializer);
        let mut var_transferName = <String>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_uti = <Option<String>>::sse_decode(deserializer);
        let mut var_createdDate = <u64>::sse_decode(deserializer);
        let mut var_pathc = <Option<String>>::sse_decode(deserializer);
        let mut var_md5 = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::AttachmentMeta {
            mime_type: var_mimeType,
            start_date: var_startDate,
            total_bytes: var_totalBytes,
            transfer_state: var_transferState,
            is_sticker: var_isSticker,
            guid: var_guid,
            hide_attachment: var_hideAttachment,
            user_info: var_userInfo,
            filename: var_filename,
            extras: var_extras,
            is_outgoing: var_isOutgoing,
            transfer_name: var_transferName,
            version: var_version,
            uti: var_uti,
            created_date: var_createdDate,
            pathc: var_pathc,
            md5: var_md5,
        };
    }
}

impl SseDecode for crate::api::api::AttachmentMetaExtra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previewGenerationState = <Option<u32>>::sse_decode(deserializer);
        return crate::api::api::AttachmentMetaExtra {
            preview_generation_state: var_previewGenerationState,
        };
    }
}

impl SseDecode for crate::api::api::AttachmentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::api::AttachmentType::Inline(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::api::MMCSFile>::sse_decode(deserializer);
                return crate::api::api::AttachmentType::MMCS(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::Balloon {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_session = <Option<String>>::sse_decode(deserializer);
        let mut var_layout = <Option<crate::api::api::BalloonLayout>>::sse_decode(deserializer);
        let mut var_ldText = <Option<String>>::sse_decode(deserializer);
        let mut var_isLive = <bool>::sse_decode(deserializer);
        let mut var_icon = <Option<Vec<u8>>>::sse_decode(deserializer);
        return crate::api::api::Balloon {
            url: var_url,
            session: var_session,
            layout: var_layout,
            ld_text: var_ldText,
            is_live: var_isLive,
            icon: var_icon,
        };
    }
}

impl SseDecode for crate::api::api::BalloonLayout {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_imageSubtitle = <String>::sse_decode(deserializer);
                let mut var_imageTitle = <String>::sse_decode(deserializer);
                let mut var_caption = <String>::sse_decode(deserializer);
                let mut var_secondarySubcaption = <String>::sse_decode(deserializer);
                let mut var_tertiarySubcaption = <String>::sse_decode(deserializer);
                let mut var_subcaption = <String>::sse_decode(deserializer);
                let mut var_class_ = <crate::api::api::NSDictionaryClass>::sse_decode(deserializer);
                return crate::api::api::BalloonLayout::TemplateLayout {
                    image_subtitle: var_imageSubtitle,
                    image_title: var_imageTitle,
                    caption: var_caption,
                    secondary_subcaption: var_secondarySubcaption,
                    tertiary_subcaption: var_tertiarySubcaption,
                    subcaption: var_subcaption,
                    class: var_class_,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::api::CertifiedContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_receipt = <Vec<u8>>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_target = <String>::sse_decode(deserializer);
        let mut var_uuid = <Vec<u8>>::sse_decode(deserializer);
        let mut var_token = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::api::CertifiedContext {
            version: var_version,
            receipt: var_receipt,
            sender: var_sender,
            target: var_target,
            uuid: var_uuid,
            token: var_token,
        };
    }
}

impl SseDecode for crate::api::api::ChangeParticipantMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_newParticipants = <Vec<String>>::sse_decode(deserializer);
        let mut var_groupVersion = <u64>::sse_decode(deserializer);
        return crate::api::api::ChangeParticipantMessage {
            new_participants: var_newParticipants,
            group_version: var_groupVersion,
        };
    }
}

impl SseDecode for crate::api::api::ChatProto {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_unk1 = <Option<u32>>::sse_decode(deserializer);
        return crate::api::api::ChatProto { unk1: var_unk1 };
    }
}

impl SseDecode for crate::api::api::CloudAttachment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cm = <GZipWrapper<AttachmentMeta>>::sse_decode(deserializer);
        let mut var_lqa = <Asset>::sse_decode(deserializer);
        return crate::api::api::CloudAttachment {
            cm: var_cm,
            lqa: var_lqa,
        };
    }
}

impl SseDecode for crate::api::api::CloudChat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_style = <i64>::sse_decode(deserializer);
        let mut var_isFiltered = <i64>::sse_decode(deserializer);
        let mut var_successfulQuery = <i64>::sse_decode(deserializer);
        let mut var_state = <i64>::sse_decode(deserializer);
        let mut var_chatIdentifier = <String>::sse_decode(deserializer);
        let mut var_groupId = <String>::sse_decode(deserializer);
        let mut var_serviceName = <String>::sse_decode(deserializer);
        let mut var_originalGroupId = <String>::sse_decode(deserializer);
        let mut var_properties = <Option<crate::api::api::CloudProp>>::sse_decode(deserializer);
        let mut var_participants =
            <Vec<crate::api::api::CloudParticipant>>::sse_decode(deserializer);
        let mut var_prop001 = <crate::api::api::CloudProp001>::sse_decode(deserializer);
        let mut var_lastReadMessageTimestamp = <i64>::sse_decode(deserializer);
        let mut var_lastAddressedHandle = <String>::sse_decode(deserializer);
        let mut var_guid = <String>::sse_decode(deserializer);
        let mut var_displayName = <Option<String>>::sse_decode(deserializer);
        let mut var_proto001 = <Option<GZipWrapper<ChatProto>>>::sse_decode(deserializer);
        let mut var_groupPhotoGuid = <Option<String>>::sse_decode(deserializer);
        let mut var_groupPhoto = <Option<Asset>>::sse_decode(deserializer);
        return crate::api::api::CloudChat {
            style: var_style,
            is_filtered: var_isFiltered,
            successful_query: var_successfulQuery,
            state: var_state,
            chat_identifier: var_chatIdentifier,
            group_id: var_groupId,
            service_name: var_serviceName,
            original_group_id: var_originalGroupId,
            properties: var_properties,
            participants: var_participants,
            prop001: var_prop001,
            last_read_message_timestamp: var_lastReadMessageTimestamp,
            last_addressed_handle: var_lastAddressedHandle,
            guid: var_guid,
            display_name: var_displayName,
            proto001: var_proto001,
            group_photo_guid: var_groupPhotoGuid,
            group_photo: var_groupPhoto,
        };
    }
}

impl SseDecode for crate::api::api::CloudMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_utm = <Option<SystemTime>>::sse_decode(deserializer);
        let mut var_type = <i64>::sse_decode(deserializer);
        let mut var_error = <i64>::sse_decode(deserializer);
        let mut var_chatId = <String>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_time = <i64>::sse_decode(deserializer);
        let mut var_msgProto2 = <Option<GZipWrapper<MessageProto2>>>::sse_decode(deserializer);
        let mut var_destinationCallerId = <String>::sse_decode(deserializer);
        let mut var_msgProto = <GZipWrapper<MessageProto>>::sse_decode(deserializer);
        let mut var_flags = <MessageFlags>::sse_decode(deserializer);
        let mut var_guid = <String>::sse_decode(deserializer);
        let mut var_msgProto3 = <Option<GZipWrapper<MessageProto3>>>::sse_decode(deserializer);
        let mut var_service = <String>::sse_decode(deserializer);
        let mut var_msgProto4 = <Option<GZipWrapper<MessageProto4>>>::sse_decode(deserializer);
        return crate::api::api::CloudMessage {
            utm: var_utm,
            r#type: var_type,
            error: var_error,
            chat_id: var_chatId,
            sender: var_sender,
            time: var_time,
            msg_proto_2: var_msgProto2,
            destination_caller_id: var_destinationCallerId,
            msg_proto: var_msgProto,
            flags: var_flags,
            guid: var_guid,
            msg_proto_3: var_msgProto3,
            service: var_service,
            msg_proto_4: var_msgProto4,
        };
    }
}

impl SseDecode for crate::api::api::CloudParticipant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uri = <String>::sse_decode(deserializer);
        return crate::api::api::CloudParticipant { uri: var_uri };
    }
}

impl SseDecode for crate::api::api::CloudProp {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_gpufc = <Option<u32>>::sse_decode(deserializer);
        let mut var_pv = <Option<u32>>::sse_decode(deserializer);
        let mut var_numberOfTimesRespondedtoThread = <Option<u32>>::sse_decode(deserializer);
        let mut var_shouldForceToSms = <Option<bool>>::sse_decode(deserializer);
        let mut var_lastSeenMessageGuid = <Option<String>>::sse_decode(deserializer);
        let mut var_messageHandshakeState = <Option<u32>>::sse_decode(deserializer);
        let mut var_legacyGroupIdentifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_groupPhotoGuid = <Option<String>>::sse_decode(deserializer);
        let mut var_lastModificationDate = <Option<Date>>::sse_decode(deserializer);
        return crate::api::api::CloudProp {
            gpufc: var_gpufc,
            pv: var_pv,
            number_of_times_respondedto_thread: var_numberOfTimesRespondedtoThread,
            should_force_to_sms: var_shouldForceToSms,
            last_seen_message_guid: var_lastSeenMessageGuid,
            message_handshake_state: var_messageHandshakeState,
            legacy_group_identifiers: var_legacyGroupIdentifiers,
            group_photo_guid: var_groupPhotoGuid,
            last_modification_date: var_lastModificationDate,
        };
    }
}

impl SseDecode for crate::api::api::CloudProp001 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_syndicationType = <u32>::sse_decode(deserializer);
        return crate::api::api::CloudProp001 {
            syndication_type: var_syndicationType,
        };
    }
}

impl SseDecode for crate::api::api::ConversationData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_participants = <Vec<String>>::sse_decode(deserializer);
        let mut var_cvName = <Option<String>>::sse_decode(deserializer);
        let mut var_senderGuid = <Option<String>>::sse_decode(deserializer);
        let mut var_afterGuid = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::ConversationData {
            participants: var_participants,
            cv_name: var_cvName,
            sender_guid: var_senderGuid,
            after_guid: var_afterGuid,
        };
    }
}

impl SseDecode for crate::api::api::DeleteTarget {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::api::OperatedChat>::sse_decode(deserializer);
                return crate::api::api::DeleteTarget::Chat(var_field0);
            }
            1 => {
                let mut var_field0 = <Vec<String>>::sse_decode(deserializer);
                return crate::api::api::DeleteTarget::Messages(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::DeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_serial = <String>::sse_decode(deserializer);
        let mut var_osVersion = <String>::sse_decode(deserializer);
        let mut var_encodedData = <Option<Vec<u8>>>::sse_decode(deserializer);
        return crate::api::api::DeviceInfo {
            name: var_name,
            serial: var_serial,
            os_version: var_osVersion,
            encoded_data: var_encodedData,
        };
    }
}

impl SseDecode for crate::api::api::EditMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tuuid = <String>::sse_decode(deserializer);
        let mut var_editPart = <u64>::sse_decode(deserializer);
        let mut var_newParts = <crate::api::api::MessageParts>::sse_decode(deserializer);
        return crate::api::api::EditMessage {
            tuuid: var_tuuid,
            edit_part: var_editPart,
            new_parts: var_newParts,
        };
    }
}

impl SseDecode for crate::api::api::ErrorMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_forUuid = <String>::sse_decode(deserializer);
        let mut var_status = <u64>::sse_decode(deserializer);
        let mut var_statusStr = <String>::sse_decode(deserializer);
        return crate::api::api::ErrorMessage {
            for_uuid: var_forUuid,
            status: var_status,
            status_str: var_statusStr,
        };
    }
}

impl SseDecode for crate::api::api::ExtensionApp {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_appId = <Option<u64>>::sse_decode(deserializer);
        let mut var_bundleId = <String>::sse_decode(deserializer);
        let mut var_balloon = <Option<crate::api::api::Balloon>>::sse_decode(deserializer);
        return crate::api::api::ExtensionApp {
            name: var_name,
            app_id: var_appId,
            bundle_id: var_bundleId,
            balloon: var_balloon,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::api::FFIFilePackager {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::api::FFIFilePackager {};
    }
}

impl SseDecode for crate::api::api::Follow {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_createTimestamp = <i64>::sse_decode(deserializer);
        let mut var_expires = <i64>::sse_decode(deserializer);
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_invitationAcceptedHandles = <Vec<String>>::sse_decode(deserializer);
        let mut var_invitationFromHandles = <Vec<String>>::sse_decode(deserializer);
        let mut var_isFromMessages = <bool>::sse_decode(deserializer);
        let mut var_offerId = <Option<String>>::sse_decode(deserializer);
        let mut var_onlyInEvent = <bool>::sse_decode(deserializer);
        let mut var_personIdHash = <String>::sse_decode(deserializer);
        let mut var_secureLocationsCapable = <bool>::sse_decode(deserializer);
        let mut var_shallowOrLiveSecureLocationsCapable = <bool>::sse_decode(deserializer);
        let mut var_source = <String>::sse_decode(deserializer);
        let mut var_tkPermission = <bool>::sse_decode(deserializer);
        let mut var_updateTimestamp = <i64>::sse_decode(deserializer);
        let mut var_fallbackToLegacyAllowed = <Option<bool>>::sse_decode(deserializer);
        let mut var_optedNotToShare = <Option<bool>>::sse_decode(deserializer);
        let mut var_lastLocation = <Option<crate::api::api::Location>>::sse_decode(deserializer);
        let mut var_locateInProgress = <bool>::sse_decode(deserializer);
        return crate::api::api::Follow {
            create_timestamp: var_createTimestamp,
            expires: var_expires,
            id: var_id,
            invitation_accepted_handles: var_invitationAcceptedHandles,
            invitation_from_handles: var_invitationFromHandles,
            is_from_messages: var_isFromMessages,
            offer_id: var_offerId,
            only_in_event: var_onlyInEvent,
            person_id_hash: var_personIdHash,
            secure_locations_capable: var_secureLocationsCapable,
            shallow_or_live_secure_locations_capable: var_shallowOrLiveSecureLocationsCapable,
            source: var_source,
            tk_permission: var_tkPermission,
            update_timestamp: var_updateTimestamp,
            fallback_to_legacy_allowed: var_fallbackToLegacyAllowed,
            opted_not_to_share: var_optedNotToShare,
            last_location: var_lastLocation,
            locate_in_progress: var_locateInProgress,
        };
    }
}

impl SseDecode for crate::api::api::FoundDevice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceModel = <Option<String>>::sse_decode(deserializer);
        let mut var_lowPowerMode = <Option<bool>>::sse_decode(deserializer);
        let mut var_passcodeLength = <Option<i64>>::sse_decode(deserializer);
        let mut var_id = <Option<String>>::sse_decode(deserializer);
        let mut var_batteryStatus = <Option<String>>::sse_decode(deserializer);
        let mut var_lostModeCapable = <Option<bool>>::sse_decode(deserializer);
        let mut var_batteryLevel = <Option<f64>>::sse_decode(deserializer);
        let mut var_locationEnabled = <Option<bool>>::sse_decode(deserializer);
        let mut var_isConsideredAccessory = <Option<bool>>::sse_decode(deserializer);
        let mut var_location = <Option<crate::api::api::Location>>::sse_decode(deserializer);
        let mut var_modelDisplayName = <Option<String>>::sse_decode(deserializer);
        let mut var_deviceColor = <Option<String>>::sse_decode(deserializer);
        let mut var_activationLocked = <Option<bool>>::sse_decode(deserializer);
        let mut var_rm2State = <Option<i64>>::sse_decode(deserializer);
        let mut var_locFoundEnabled = <Option<bool>>::sse_decode(deserializer);
        let mut var_nwd = <Option<bool>>::sse_decode(deserializer);
        let mut var_deviceStatus = <Option<String>>::sse_decode(deserializer);
        let mut var_fmlyShare = <Option<bool>>::sse_decode(deserializer);
        let mut var_features = <std::collections::HashMap<String, bool>>::sse_decode(deserializer);
        let mut var_thisDevice = <Option<bool>>::sse_decode(deserializer);
        let mut var_lostModeEnabled = <Option<bool>>::sse_decode(deserializer);
        let mut var_deviceDisplayName = <Option<String>>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_canWipeAfterLock = <Option<bool>>::sse_decode(deserializer);
        let mut var_isMac = <Option<bool>>::sse_decode(deserializer);
        let mut var_rawDeviceModel = <Option<String>>::sse_decode(deserializer);
        let mut var_baUuid = <Option<String>>::sse_decode(deserializer);
        let mut var_deviceDiscoveryId = <Option<String>>::sse_decode(deserializer);
        let mut var_scd = <Option<bool>>::sse_decode(deserializer);
        let mut var_locationCapable = <Option<bool>>::sse_decode(deserializer);
        let mut var_wipeInProgress = <Option<bool>>::sse_decode(deserializer);
        let mut var_darkWake = <Option<bool>>::sse_decode(deserializer);
        let mut var_deviceWithYou = <Option<bool>>::sse_decode(deserializer);
        let mut var_maxMsgChar = <Option<i64>>::sse_decode(deserializer);
        let mut var_deviceClass = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::FoundDevice {
            device_model: var_deviceModel,
            low_power_mode: var_lowPowerMode,
            passcode_length: var_passcodeLength,
            id: var_id,
            battery_status: var_batteryStatus,
            lost_mode_capable: var_lostModeCapable,
            battery_level: var_batteryLevel,
            location_enabled: var_locationEnabled,
            is_considered_accessory: var_isConsideredAccessory,
            location: var_location,
            model_display_name: var_modelDisplayName,
            device_color: var_deviceColor,
            activation_locked: var_activationLocked,
            rm2_state: var_rm2State,
            loc_found_enabled: var_locFoundEnabled,
            nwd: var_nwd,
            device_status: var_deviceStatus,
            fmly_share: var_fmlyShare,
            features: var_features,
            this_device: var_thisDevice,
            lost_mode_enabled: var_lostModeEnabled,
            device_display_name: var_deviceDisplayName,
            name: var_name,
            can_wipe_after_lock: var_canWipeAfterLock,
            is_mac: var_isMac,
            raw_device_model: var_rawDeviceModel,
            ba_uuid: var_baUuid,
            device_discovery_id: var_deviceDiscoveryId,
            scd: var_scd,
            location_capable: var_locationCapable,
            wipe_in_progress: var_wipeInProgress,
            dark_wake: var_darkWake,
            device_with_you: var_deviceWithYou,
            max_msg_char: var_maxMsgChar,
            device_class: var_deviceClass,
        };
    }
}

impl SseDecode for crate::api::api::FTMember {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nickname = <Option<String>>::sse_decode(deserializer);
        let mut var_handle = <String>::sse_decode(deserializer);
        return crate::api::api::FTMember {
            nickname: var_nickname,
            handle: var_handle,
        };
    }
}

impl SseDecode for crate::api::api::FTMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::api::LetMeInRequest>::sse_decode(deserializer);
                return crate::api::api::FTMessage::LetMeInRequest(var_field0);
            }
            1 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                return crate::api::api::FTMessage::LinkChanged { guid: var_guid };
            }
            2 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                let mut var_participant = <u64>::sse_decode(deserializer);
                let mut var_handle = <String>::sse_decode(deserializer);
                let mut var_ring = <bool>::sse_decode(deserializer);
                return crate::api::api::FTMessage::JoinEvent {
                    guid: var_guid,
                    participant: var_participant,
                    handle: var_handle,
                    ring: var_ring,
                };
            }
            3 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                let mut var_members =
                    <std::collections::HashSet<crate::api::api::FTMember>>::sse_decode(
                        deserializer,
                    );
                let mut var_ring = <bool>::sse_decode(deserializer);
                return crate::api::api::FTMessage::AddMembers {
                    guid: var_guid,
                    members: var_members,
                    ring: var_ring,
                };
            }
            4 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                let mut var_members =
                    <std::collections::HashSet<crate::api::api::FTMember>>::sse_decode(
                        deserializer,
                    );
                return crate::api::api::FTMessage::RemoveMembers {
                    guid: var_guid,
                    members: var_members,
                };
            }
            5 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                let mut var_participant = <u64>::sse_decode(deserializer);
                let mut var_handle = <String>::sse_decode(deserializer);
                return crate::api::api::FTMessage::LeaveEvent {
                    guid: var_guid,
                    participant: var_participant,
                    handle: var_handle,
                };
            }
            6 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                return crate::api::api::FTMessage::Ring { guid: var_guid };
            }
            7 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                return crate::api::api::FTMessage::Decline { guid: var_guid };
            }
            8 => {
                let mut var_guid = <String>::sse_decode(deserializer);
                return crate::api::api::FTMessage::RespondedElsewhere { guid: var_guid };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::FTMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::api::FTMode::Outgoing,
            1 => crate::api::api::FTMode::Incoming,
            2 => crate::api::api::FTMode::Missed,
            3 => crate::api::api::FTMode::MissedOutgoing,
            _ => unreachable!("Invalid variant for FTMode: {}", inner),
        };
    }
}

impl SseDecode for crate::api::api::FTParticipant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_token = <Option<String>>::sse_decode(deserializer);
        let mut var_handle = <String>::sse_decode(deserializer);
        let mut var_participantId = <u64>::sse_decode(deserializer);
        let mut var_lastJoinDate = <Option<u64>>::sse_decode(deserializer);
        let mut var_active = <Option<ConversationParticipant>>::sse_decode(deserializer);
        return crate::api::api::FTParticipant {
            token: var_token,
            handle: var_handle,
            participant_id: var_participantId,
            last_join_date: var_lastJoinDate,
            active: var_active,
        };
    }
}

impl SseDecode for crate::api::api::FTSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_groupId = <String>::sse_decode(deserializer);
        let mut var_myHandles = <Vec<String>>::sse_decode(deserializer);
        let mut var_participants = <std::collections::HashMap<
            String,
            crate::api::api::FTParticipant,
        >>::sse_decode(deserializer);
        let mut var_link = <Option<ConversationLink>>::sse_decode(deserializer);
        let mut var_members =
            <std::collections::HashSet<crate::api::api::FTMember>>::sse_decode(deserializer);
        let mut var_reportId = <String>::sse_decode(deserializer);
        let mut var_startTime = <Option<u64>>::sse_decode(deserializer);
        let mut var_lastRekey = <Option<u64>>::sse_decode(deserializer);
        let mut var_isPropped = <bool>::sse_decode(deserializer);
        let mut var_isRingingInaccurate = <bool>::sse_decode(deserializer);
        let mut var_mode = <Option<crate::api::api::FTMode>>::sse_decode(deserializer);
        let mut var_recentMemberAdds =
            <std::collections::HashMap<String, u64>>::sse_decode(deserializer);
        return crate::api::api::FTSession {
            group_id: var_groupId,
            my_handles: var_myHandles,
            participants: var_participants,
            link: var_link,
            members: var_members,
            report_id: var_reportId,
            start_time: var_startTime,
            last_rekey: var_lastRekey,
            is_propped: var_isPropped,
            is_ringing_inaccurate: var_isRingingInaccurate,
            mode: var_mode,
            recent_member_adds: var_recentMemberAdds,
        };
    }
}

impl SseDecode for crate::api::api::HwExtra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <String>::sse_decode(deserializer);
        let mut var_protocolVersion = <u32>::sse_decode(deserializer);
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_icloudUa = <String>::sse_decode(deserializer);
        let mut var_aoskitVersion = <String>::sse_decode(deserializer);
        return crate::api::api::HwExtra {
            version: var_version,
            protocol_version: var_protocolVersion,
            device_id: var_deviceId,
            icloud_ua: var_icloudUa,
            aoskit_version: var_aoskitVersion,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::api::IMessageNameRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_first = <String>::sse_decode(deserializer);
        let mut var_last = <String>::sse_decode(deserializer);
        return crate::api::api::IMessageNameRecord {
            name: var_name,
            first: var_first,
            last: var_last,
        };
    }
}

impl SseDecode for crate::api::api::IMessageNicknameRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <crate::api::api::IMessageNameRecord>::sse_decode(deserializer);
        let mut var_image = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_poster =
            <Option<crate::api::api::IMessagePosterRecord>>::sse_decode(deserializer);
        return crate::api::api::IMessageNicknameRecord {
            name: var_name,
            image: var_image,
            poster: var_poster,
        };
    }
}

impl SseDecode for crate::api::api::IMessagePosterRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lowResPoster = <Vec<u8>>::sse_decode(deserializer);
        let mut var_package = <Vec<u8>>::sse_decode(deserializer);
        let mut var_meta = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::api::IMessagePosterRecord {
            low_res_poster: var_lowResPoster,
            package: var_package,
            meta: var_meta,
        };
    }
}

impl SseDecode for crate::api::api::IconChangeMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_file = <Option<crate::api::api::MMCSFile>>::sse_decode(deserializer);
        let mut var_groupVersion = <u64>::sse_decode(deserializer);
        return crate::api::api::IconChangeMessage {
            file: var_file,
            group_version: var_groupVersion,
        };
    }
}

impl SseDecode for crate::api::api::IdmsCircleMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_step = <u32>::sse_decode(deserializer);
        let mut var_atxnid = <String>::sse_decode(deserializer);
        let mut var_pake = <Option<String>>::sse_decode(deserializer);
        let mut var_ec = <Option<i32>>::sse_decode(deserializer);
        let mut var_idmsdata = <String>::sse_decode(deserializer);
        return crate::api::api::IdmsCircleMessage {
            step: var_step,
            atxnid: var_atxnid,
            pake: var_pake,
            ec: var_ec,
            idmsdata: var_idmsdata,
        };
    }
}

impl SseDecode for crate::api::api::IdmsMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <crate::api::api::IdmsRequestedSignIn>::sse_decode(deserializer);
                return crate::api::api::IdmsMessage::RequestedSignIn(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::api::TeardownSignIn>::sse_decode(deserializer);
                return crate::api::api::IdmsMessage::TeardownSignIn(var_field0);
            }
            2 => {
                let mut var_field0 = <crate::api::api::IdmsCircleMessage>::sse_decode(deserializer);
                let mut var_field1 =
                    <Option<crate::api::api::IdmsRequestedSignIn>>::sse_decode(deserializer);
                return crate::api::api::IdmsMessage::CircleRequest(var_field0, var_field1);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::IdmsRequestedSignIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_aps = <crate::api::api::ApsData>::sse_decode(deserializer);
        let mut var_txnid = <String>::sse_decode(deserializer);
        let mut var_akdata = <crate::api::api::AkData>::sse_decode(deserializer);
        let mut var_adsid = <String>::sse_decode(deserializer);
        return crate::api::api::IdmsRequestedSignIn {
            aps: var_aps,
            txnid: var_txnid,
            akdata: var_akdata,
            adsid: var_adsid,
        };
    }
}

impl SseDecode for crate::api::api::IndexedMessagePart {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_part_ = <crate::api::api::MessagePart>::sse_decode(deserializer);
        let mut var_idx = <Option<usize>>::sse_decode(deserializer);
        let mut var_ext = <Option<crate::api::api::PartExtension>>::sse_decode(deserializer);
        return crate::api::api::IndexedMessagePart {
            part: var_part_,
            idx: var_idx,
            ext: var_ext,
        };
    }
}

impl SseDecode for crate::api::api::LetMeInRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sharedSecret = <Vec<u8>>::sse_decode(deserializer);
        let mut var_pseud = <String>::sse_decode(deserializer);
        let mut var_requestor = <String>::sse_decode(deserializer);
        let mut var_nickname = <Option<String>>::sse_decode(deserializer);
        let mut var_token = <Vec<u8>>::sse_decode(deserializer);
        let mut var_delegationUuid = <Option<String>>::sse_decode(deserializer);
        let mut var_usage = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::LetMeInRequest {
            shared_secret: var_sharedSecret,
            pseud: var_pseud,
            requestor: var_requestor,
            nickname: var_nickname,
            token: var_token,
            delegation_uuid: var_delegationUuid,
            usage: var_usage,
        };
    }
}

impl SseDecode for crate::api::api::LinkMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <crate::api::api::LPLinkMetadata>::sse_decode(deserializer);
        let mut var_attachments = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return crate::api::api::LinkMeta {
            data: var_data,
            attachments: var_attachments,
        };
    }
}

impl SseDecode for Vec<IDSUser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<IDSUser>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<StCollapsedValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<StCollapsedValue>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ViableBottle> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ViableBottle>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::CloudParticipant> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::CloudParticipant>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::Follow> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::Follow>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::FoundDevice> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::FoundDevice>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::FTMember> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::FTMember>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::FTSession> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::FTSession>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::IndexedMessagePart> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::IndexedMessagePart>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::MessageEdit> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::MessageEdit>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::MessageTarget> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::MessageTarget>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::PhotoPosterLayer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::PhotoPosterLayer>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::PosterAsset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::PosterAsset>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::PosterColor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::PosterColor>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::PrivateDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::PrivateDeviceInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Asset)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Asset)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, StCollapsedValue)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, StCollapsedValue)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, bool)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, bool)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, u64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, u64)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::CloudAttachment)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::api::api::CloudAttachment)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::CloudChat)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::api::api::CloudChat)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::CloudMessage)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::api::api::CloudMessage)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::FTParticipant)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::api::api::FTParticipant)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Vec<crate::api::api::MessageEdit>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Vec<crate::api::api::MessageEdit>)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Vec<u8>)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::MessageEditRange)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::api::api::MessageEditRange)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Option<crate::api::api::CloudAttachment>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <(String, Option<crate::api::api::CloudAttachment>)>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Option<crate::api::api::CloudChat>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Option<crate::api::api::CloudChat>)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Option<crate::api::api::CloudMessage>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Option<crate::api::api::CloudMessage>)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::StatusKitPersonalConfig)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <(String, crate::api::api::StatusKitPersonalConfig)>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::api::api::SyncStatus)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::api::api::SyncStatus)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(u32, crate::api::api::NSDictionaryTypedCoder)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(u32, crate::api::api::NSDictionaryTypedCoder)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::ReportMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::ReportMessage>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::SharedAlbum> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::SharedAlbum>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::TrustedPhoneNumber> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::TrustedPhoneNumber>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::api::UIColor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::api::UIColor>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::api::Location {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <Option<crate::api::api::Address>>::sse_decode(deserializer);
        let mut var_altitude = <f64>::sse_decode(deserializer);
        let mut var_floorLevel = <i64>::sse_decode(deserializer);
        let mut var_horizontalAccuracy = <f64>::sse_decode(deserializer);
        let mut var_isInaccurate = <bool>::sse_decode(deserializer);
        let mut var_latitude = <f64>::sse_decode(deserializer);
        let mut var_locationId = <Option<String>>::sse_decode(deserializer);
        let mut var_locationTimestamp = <Option<i64>>::sse_decode(deserializer);
        let mut var_longitude = <f64>::sse_decode(deserializer);
        let mut var_secureLocationTs = <i64>::sse_decode(deserializer);
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        let mut var_verticalAccuracy = <f64>::sse_decode(deserializer);
        let mut var_positionType = <Option<String>>::sse_decode(deserializer);
        let mut var_isOld = <Option<bool>>::sse_decode(deserializer);
        let mut var_locationFinished = <Option<bool>>::sse_decode(deserializer);
        return crate::api::api::Location {
            address: var_address,
            altitude: var_altitude,
            floor_level: var_floorLevel,
            horizontal_accuracy: var_horizontalAccuracy,
            is_inaccurate: var_isInaccurate,
            latitude: var_latitude,
            location_id: var_locationId,
            location_timestamp: var_locationTimestamp,
            longitude: var_longitude,
            secure_location_ts: var_secureLocationTs,
            timestamp: var_timestamp,
            vertical_accuracy: var_verticalAccuracy,
            position_type: var_positionType,
            is_old: var_isOld,
            location_finished: var_locationFinished,
        };
    }
}

impl SseDecode for crate::api::api::LoginState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::api::LoginState::LoggedIn;
            }
            1 => {
                return crate::api::api::LoginState::NeedsDevice2FA;
            }
            2 => {
                return crate::api::api::LoginState::Needs2FAVerification;
            }
            3 => {
                return crate::api::api::LoginState::NeedsSMS2FA;
            }
            4 => {
                let mut var_field0 = <VerifyBody>::sse_decode(deserializer);
                return crate::api::api::LoginState::NeedsSMS2FAVerification(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::api::LoginState::NeedsExtraStep(var_field0);
            }
            6 => {
                return crate::api::api::LoginState::NeedsLogin;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::LPIconMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <crate::api::api::NSURL>::sse_decode(deserializer);
        let mut var_version = <u8>::sse_decode(deserializer);
        return crate::api::api::LPIconMetadata {
            url: var_url,
            version: var_version,
        };
    }
}

impl SseDecode for crate::api::api::LPImageMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_size = <String>::sse_decode(deserializer);
        let mut var_url = <crate::api::api::NSURL>::sse_decode(deserializer);
        let mut var_version = <u8>::sse_decode(deserializer);
        return crate::api::api::LPImageMetadata {
            size: var_size,
            url: var_url,
            version: var_version,
        };
    }
}

impl SseDecode for crate::api::api::LPLinkMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_imageMetadata =
            <Option<crate::api::api::LPImageMetadata>>::sse_decode(deserializer);
        let mut var_version = <u8>::sse_decode(deserializer);
        let mut var_iconMetadata =
            <Option<crate::api::api::LPIconMetadata>>::sse_decode(deserializer);
        let mut var_originalUrl = <crate::api::api::NSURL>::sse_decode(deserializer);
        let mut var_url = <Option<crate::api::api::NSURL>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_summary = <Option<String>>::sse_decode(deserializer);
        let mut var_image =
            <Option<crate::api::api::RichLinkImageAttachmentSubstitute>>::sse_decode(deserializer);
        let mut var_icon =
            <Option<crate::api::api::RichLinkImageAttachmentSubstitute>>::sse_decode(deserializer);
        let mut var_images = <Option<NSArray<LPImageMetadata>>>::sse_decode(deserializer);
        let mut var_icons = <Option<NSArray<LPIconMetadata>>>::sse_decode(deserializer);
        return crate::api::api::LPLinkMetadata {
            image_metadata: var_imageMetadata,
            version: var_version,
            icon_metadata: var_iconMetadata,
            original_url: var_originalUrl,
            url: var_url,
            title: var_title,
            summary: var_summary,
            image: var_image,
            icon: var_icon,
            images: var_images,
            icons: var_icons,
        };
    }
}

impl SseDecode for crate::api::api::MemojiData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backgroundColorDescription =
            <crate::api::api::PosterColor>::sse_decode(deserializer);
        let mut var_avatarRecordData = <Vec<u8>>::sse_decode(deserializer);
        let mut var_avatarPoseData = <Vec<u8>>::sse_decode(deserializer);
        let mut var_hasBody = <bool>::sse_decode(deserializer);
        let mut var_avatarImageData = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::api::MemojiData {
            background_color_description: var_backgroundColorDescription,
            avatar_record_data: var_avatarRecordData,
            avatar_pose_data: var_avatarPoseData,
            has_body: var_hasBody,
            avatar_image_data: var_avatarImageData,
        };
    }
}

impl SseDecode for crate::api::api::Message {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::api::NormalMessage>::sse_decode(deserializer);
                return crate::api::api::Message::Message(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::api::RenameMessage>::sse_decode(deserializer);
                return crate::api::api::Message::RenameMessage(var_field0);
            }
            2 => {
                let mut var_field0 =
                    <crate::api::api::ChangeParticipantMessage>::sse_decode(deserializer);
                return crate::api::api::Message::ChangeParticipants(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::api::api::ReactMessage>::sse_decode(deserializer);
                return crate::api::api::Message::React(var_field0);
            }
            4 => {
                return crate::api::api::Message::Delivered;
            }
            5 => {
                return crate::api::api::Message::Read;
            }
            6 => {
                let mut var_field0 = <bool>::sse_decode(deserializer);
                let mut var_field1 = <Option<crate::api::api::TypingApp>>::sse_decode(deserializer);
                return crate::api::api::Message::Typing(var_field0, var_field1);
            }
            7 => {
                let mut var_field0 = <crate::api::api::UnsendMessage>::sse_decode(deserializer);
                return crate::api::api::Message::Unsend(var_field0);
            }
            8 => {
                let mut var_field0 = <crate::api::api::EditMessage>::sse_decode(deserializer);
                return crate::api::api::Message::Edit(var_field0);
            }
            9 => {
                let mut var_field0 = <crate::api::api::IconChangeMessage>::sse_decode(deserializer);
                return crate::api::api::Message::IconChange(var_field0);
            }
            10 => {
                let mut var_field0 = <bool>::sse_decode(deserializer);
                return crate::api::api::Message::EnableSmsActivation(var_field0);
            }
            11 => {
                return crate::api::api::Message::MessageReadOnDevice;
            }
            12 => {
                let mut var_field0 = <bool>::sse_decode(deserializer);
                return crate::api::api::Message::SmsConfirmSent(var_field0);
            }
            13 => {
                return crate::api::api::Message::MarkUnread;
            }
            14 => {
                return crate::api::api::Message::PeerCacheInvalidate;
            }
            15 => {
                let mut var_field0 =
                    <crate::api::api::UpdateExtensionMessage>::sse_decode(deserializer);
                return crate::api::api::Message::UpdateExtension(var_field0);
            }
            16 => {
                let mut var_field0 = <crate::api::api::ErrorMessage>::sse_decode(deserializer);
                return crate::api::api::Message::Error(var_field0);
            }
            17 => {
                let mut var_field0 =
                    <crate::api::api::MoveToRecycleBinMessage>::sse_decode(deserializer);
                return crate::api::api::Message::MoveToRecycleBin(var_field0);
            }
            18 => {
                let mut var_field0 = <crate::api::api::OperatedChat>::sse_decode(deserializer);
                return crate::api::api::Message::RecoverChat(var_field0);
            }
            19 => {
                let mut var_field0 =
                    <crate::api::api::PermanentDeleteMessage>::sse_decode(deserializer);
                return crate::api::api::Message::PermanentDelete(var_field0);
            }
            20 => {
                return crate::api::api::Message::Unschedule;
            }
            21 => {
                let mut var_field0 =
                    <crate::api::api::UpdateProfileMessage>::sse_decode(deserializer);
                return crate::api::api::Message::UpdateProfile(var_field0);
            }
            22 => {
                let mut var_field0 =
                    <crate::api::api::UpdateProfileSharingMessage>::sse_decode(deserializer);
                return crate::api::api::Message::UpdateProfileSharing(var_field0);
            }
            23 => {
                let mut var_field0 =
                    <crate::api::api::ShareProfileMessage>::sse_decode(deserializer);
                return crate::api::api::Message::ShareProfile(var_field0);
            }
            24 => {
                return crate::api::api::Message::NotifyAnyways;
            }
            25 => {
                let mut var_field0 =
                    <crate::api::api::SetTranscriptBackgroundMessage>::sse_decode(deserializer);
                return crate::api::api::Message::SetTranscriptBackground(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::MessageEdit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_t = <Vec<u8>>::sse_decode(deserializer);
        let mut var_d = <f64>::sse_decode(deserializer);
        let mut var_bcg = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::MessageEdit {
            t: var_t,
            d: var_d,
            bcg: var_bcg,
        };
    }
}

impl SseDecode for crate::api::api::MessageEditRange {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lo = <u32>::sse_decode(deserializer);
        let mut var_le = <u32>::sse_decode(deserializer);
        return crate::api::api::MessageEditRange {
            lo: var_lo,
            le: var_le,
        };
    }
}

impl SseDecode for crate::api::api::MessageInst {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_sender = <Option<String>>::sse_decode(deserializer);
        let mut var_conversation =
            <Option<crate::api::api::ConversationData>>::sse_decode(deserializer);
        let mut var_message = <crate::api::api::Message>::sse_decode(deserializer);
        let mut var_sentTimestamp = <u64>::sse_decode(deserializer);
        let mut var_target =
            <Option<Vec<crate::api::api::MessageTarget>>>::sse_decode(deserializer);
        let mut var_sendDelivered = <bool>::sse_decode(deserializer);
        let mut var_verificationFailed = <bool>::sse_decode(deserializer);
        let mut var_certifiedContext =
            <Option<crate::api::api::CertifiedContext>>::sse_decode(deserializer);
        return crate::api::api::MessageInst {
            id: var_id,
            sender: var_sender,
            conversation: var_conversation,
            message: var_message,
            sent_timestamp: var_sentTimestamp,
            target: var_target,
            send_delivered: var_sendDelivered,
            verification_failed: var_verificationFailed,
            certified_context: var_certifiedContext,
        };
    }
}

impl SseDecode for crate::api::api::MessagePart {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                let mut var_field1 = <crate::api::api::TextFormat>::sse_decode(deserializer);
                return crate::api::api::MessagePart::Text(var_field0, var_field1);
            }
            1 => {
                let mut var_field0 = <crate::api::api::Attachment>::sse_decode(deserializer);
                return crate::api::api::MessagePart::Attachment(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                let mut var_field1 = <String>::sse_decode(deserializer);
                return crate::api::api::MessagePart::Mention(var_field0, var_field1);
            }
            3 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::api::MessagePart::Object(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::MessageParts {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<crate::api::api::IndexedMessagePart>>::sse_decode(deserializer);
        return crate::api::api::MessageParts(var_field0);
    }
}

impl SseDecode for crate::api::api::MessageProto {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_unk1 = <u32>::sse_decode(deserializer);
        let mut var_groupTitle = <Option<String>>::sse_decode(deserializer);
        let mut var_text = <String>::sse_decode(deserializer);
        let mut var_attributedBody = <Vec<u8>>::sse_decode(deserializer);
        let mut var_balloonBundleId = <Option<String>>::sse_decode(deserializer);
        let mut var_payloadData = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_messageSummaryInfo = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_effect = <Option<String>>::sse_decode(deserializer);
        let mut var_dateRead = <Option<u64>>::sse_decode(deserializer);
        let mut var_unk10 = <Option<u32>>::sse_decode(deserializer);
        let mut var_unk11 = <Option<u32>>::sse_decode(deserializer);
        let mut var_dateDelivered = <Option<u64>>::sse_decode(deserializer);
        let mut var_unk14 = <Option<u32>>::sse_decode(deserializer);
        let mut var_associatedMessageType = <Option<u32>>::sse_decode(deserializer);
        let mut var_associatedMessageGuid = <Option<String>>::sse_decode(deserializer);
        let mut var_associatedMessageRangeLocation = <Option<u32>>::sse_decode(deserializer);
        let mut var_associatedMessageRangeLength = <Option<u32>>::sse_decode(deserializer);
        return crate::api::api::MessageProto {
            unk1: var_unk1,
            group_title: var_groupTitle,
            text: var_text,
            attributed_body: var_attributedBody,
            balloon_bundle_id: var_balloonBundleId,
            payload_data: var_payloadData,
            message_summary_info: var_messageSummaryInfo,
            effect: var_effect,
            date_read: var_dateRead,
            unk10: var_unk10,
            unk11: var_unk11,
            date_delivered: var_dateDelivered,
            unk14: var_unk14,
            associated_message_type: var_associatedMessageType,
            associated_message_guid: var_associatedMessageGuid,
            associated_message_range_location: var_associatedMessageRangeLocation,
            associated_message_range_length: var_associatedMessageRangeLength,
        };
    }
}

impl SseDecode for crate::api::api::MessageProto2 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_reply = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::MessageProto2 { reply: var_reply };
    }
}

impl SseDecode for crate::api::api::MessageProto3 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_unk2 = <Option<u32>>::sse_decode(deserializer);
        let mut var_unk3 = <Option<u32>>::sse_decode(deserializer);
        return crate::api::api::MessageProto3 {
            unk2: var_unk2,
            unk3: var_unk3,
        };
    }
}

impl SseDecode for crate::api::api::MessageProto4 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_associatedMessageEmoji = <Option<String>>::sse_decode(deserializer);
        let mut var_service = <Option<String>>::sse_decode(deserializer);
        let mut var_scheduleType = <Option<u32>>::sse_decode(deserializer);
        let mut var_scheduleState = <Option<u32>>::sse_decode(deserializer);
        let mut var_groupId = <Option<String>>::sse_decode(deserializer);
        let mut var_sentOrReceivedOffGrid = <Option<u32>>::sse_decode(deserializer);
        return crate::api::api::MessageProto4 {
            associated_message_emoji: var_associatedMessageEmoji,
            service: var_service,
            schedule_type: var_scheduleType,
            schedule_state: var_scheduleState,
            group_id: var_groupId,
            sent_or_received_off_grid: var_sentOrReceivedOffGrid,
        };
    }
}

impl SseDecode for crate::api::api::MessageSummaryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ams = <Option<String>>::sse_decode(deserializer);
        let mut var_ampt = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_amc = <Option<u32>>::sse_decode(deserializer);
        let mut var_amb = <Option<String>>::sse_decode(deserializer);
        let mut var_amd = <Option<String>>::sse_decode(deserializer);
        let mut var_ec =
            <std::collections::HashMap<String, Vec<crate::api::api::MessageEdit>>>::sse_decode(
                deserializer,
            );
        let mut var_ep = <Vec<u32>>::sse_decode(deserializer);
        let mut var_otr =
            <std::collections::HashMap<String, crate::api::api::MessageEditRange>>::sse_decode(
                deserializer,
            );
        let mut var_ust = <Option<bool>>::sse_decode(deserializer);
        let mut var_rp = <Vec<u32>>::sse_decode(deserializer);
        let mut var_hbr = <Option<bool>>::sse_decode(deserializer);
        let mut var_oui = <Option<String>>::sse_decode(deserializer);
        let mut var_osn = <Option<String>>::sse_decode(deserializer);
        let mut var_euh = <Vec<String>>::sse_decode(deserializer);
        return crate::api::api::MessageSummaryInfo {
            ams: var_ams,
            ampt: var_ampt,
            amc: var_amc,
            amb: var_amb,
            amd: var_amd,
            ec: var_ec,
            ep: var_ep,
            otr: var_otr,
            ust: var_ust,
            rp: var_rp,
            hbr: var_hbr,
            oui: var_oui,
            osn: var_osn,
            euh: var_euh,
        };
    }
}

impl SseDecode for crate::api::api::MessageTarget {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::api::MessageTarget::Token(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::api::MessageTarget::Uuid(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::MessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::api::MessageType::IMessage;
            }
            1 => {
                let mut var_isPhone = <bool>::sse_decode(deserializer);
                let mut var_usingNumber = <String>::sse_decode(deserializer);
                let mut var_fromHandle = <Option<String>>::sse_decode(deserializer);
                return crate::api::api::MessageType::SMS {
                    is_phone: var_isPhone,
                    using_number: var_usingNumber,
                    from_handle: var_fromHandle,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::MMCSAttachmentMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mmcsSignatureHex = <String>::sse_decode(deserializer);
        let mut var_fileSize = <crate::api::api::NumOrString>::sse_decode(deserializer);
        let mut var_decryptionKey = <String>::sse_decode(deserializer);
        let mut var_utiType = <Option<String>>::sse_decode(deserializer);
        let mut var_mmcsOwner = <String>::sse_decode(deserializer);
        let mut var_mimeType = <Option<String>>::sse_decode(deserializer);
        let mut var_mmcsUrl = <String>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::MMCSAttachmentMeta {
            mmcs_signature_hex: var_mmcsSignatureHex,
            file_size: var_fileSize,
            decryption_key: var_decryptionKey,
            uti_type: var_utiType,
            mmcs_owner: var_mmcsOwner,
            mime_type: var_mimeType,
            mmcs_url: var_mmcsUrl,
            name: var_name,
        };
    }
}

impl SseDecode for crate::api::api::MMCSFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signature = <Vec<u8>>::sse_decode(deserializer);
        let mut var_object = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_key = <Vec<u8>>::sse_decode(deserializer);
        let mut var_size = <usize>::sse_decode(deserializer);
        return crate::api::api::MMCSFile {
            signature: var_signature,
            object: var_object,
            url: var_url,
            key: var_key,
            size: var_size,
        };
    }
}

impl SseDecode for crate::api::api::MMCSTransferProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prog = <usize>::sse_decode(deserializer);
        let mut var_total = <usize>::sse_decode(deserializer);
        let mut var_file = <Option<crate::api::api::MMCSFile>>::sse_decode(deserializer);
        return crate::api::api::MMCSTransferProgress {
            prog: var_prog,
            total: var_total,
            file: var_file,
        };
    }
}

impl SseDecode for crate::api::api::MonogramData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_topBackgroundColorDescription =
            <crate::api::api::PosterColor>::sse_decode(deserializer);
        let mut var_backgroundColorDescription =
            <crate::api::api::PosterColor>::sse_decode(deserializer);
        let mut var_initials = <String>::sse_decode(deserializer);
        let mut var_monogramSupportedForName = <bool>::sse_decode(deserializer);
        return crate::api::api::MonogramData {
            top_background_color_description: var_topBackgroundColorDescription,
            background_color_description: var_backgroundColorDescription,
            initials: var_initials,
            monogram_supported_for_name: var_monogramSupportedForName,
        };
    }
}

impl SseDecode for crate::api::api::MoveToRecycleBinMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_target = <crate::api::api::DeleteTarget>::sse_decode(deserializer);
        let mut var_recoverableDeleteDate = <u64>::sse_decode(deserializer);
        return crate::api::api::MoveToRecycleBinMessage {
            target: var_target,
            recoverable_delete_date: var_recoverableDeleteDate,
        };
    }
}

impl SseDecode for crate::api::api::MyAsyncRuntime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::api::MyAsyncRuntime();
    }
}

impl SseDecode for crate::api::api::NormalMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_parts = <crate::api::api::MessageParts>::sse_decode(deserializer);
        let mut var_effect = <Option<String>>::sse_decode(deserializer);
        let mut var_replyGuid = <Option<String>>::sse_decode(deserializer);
        let mut var_replyPart = <Option<String>>::sse_decode(deserializer);
        let mut var_service = <crate::api::api::MessageType>::sse_decode(deserializer);
        let mut var_subject = <Option<String>>::sse_decode(deserializer);
        let mut var_app = <Option<crate::api::api::ExtensionApp>>::sse_decode(deserializer);
        let mut var_linkMeta = <Option<crate::api::api::LinkMeta>>::sse_decode(deserializer);
        let mut var_voice = <bool>::sse_decode(deserializer);
        let mut var_scheduled = <Option<crate::api::api::ScheduleMode>>::sse_decode(deserializer);
        let mut var_embeddedProfile =
            <Option<crate::api::api::ShareProfileMessage>>::sse_decode(deserializer);
        return crate::api::api::NormalMessage {
            parts: var_parts,
            effect: var_effect,
            reply_guid: var_replyGuid,
            reply_part: var_replyPart,
            service: var_service,
            subject: var_subject,
            app: var_app,
            link_meta: var_linkMeta,
            voice: var_voice,
            scheduled: var_scheduled,
            embedded_profile: var_embeddedProfile,
        };
    }
}

impl SseDecode for crate::api::api::NSAttributedString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_text = <String>::sse_decode(deserializer);
        let mut var_ranges =
            <Vec<(u32, crate::api::api::NSDictionaryTypedCoder)>>::sse_decode(deserializer);
        return crate::api::api::NSAttributedString {
            text: var_text,
            ranges: var_ranges,
        };
    }
}

impl SseDecode for crate::api::api::NSDictionaryClass {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::api::NSDictionaryClass::NSDictionary,
            1 => crate::api::api::NSDictionaryClass::NSMutableDictionary,
            _ => unreachable!("Invalid variant for NSDictionaryClass: {}", inner),
        };
    }
}

impl SseDecode for crate::api::api::NSDictionaryTypedCoder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <std::collections::HashMap<String, StCollapsedValue>>::sse_decode(deserializer);
        return crate::api::api::NSDictionaryTypedCoder(var_field0);
    }
}

impl SseDecode for crate::api::api::NSNumber {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u32>::sse_decode(deserializer);
        return crate::api::api::NSNumber(var_field0);
    }
}

impl SseDecode for crate::api::api::NSString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        return crate::api::api::NSString(var_field0);
    }
}

impl SseDecode for crate::api::api::NSURL {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_base = <String>::sse_decode(deserializer);
        let mut var_relative = <String>::sse_decode(deserializer);
        return crate::api::api::NSURL {
            base: var_base,
            relative: var_relative,
        };
    }
}

impl SseDecode for crate::api::api::NumOrString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::api::NumOrString::Num(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::api::NumOrString::String(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::OperatedChat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_participants = <Vec<String>>::sse_decode(deserializer);
        let mut var_groupId = <String>::sse_decode(deserializer);
        let mut var_guid = <String>::sse_decode(deserializer);
        let mut var_deleteIncomingMessages = <Option<bool>>::sse_decode(deserializer);
        let mut var_wasReportedAsJunk = <Option<bool>>::sse_decode(deserializer);
        return crate::api::api::OperatedChat {
            participants: var_participants,
            group_id: var_groupId,
            guid: var_guid,
            delete_incoming_messages: var_deleteIncomingMessages,
            was_reported_as_junk: var_wasReportedAsJunk,
        };
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Asset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Asset>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ConversationLink> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ConversationLink>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ConversationParticipant> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ConversationParticipant>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Date> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Date>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<GZipWrapper<ChatProto>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<GZipWrapper<ChatProto>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<GZipWrapper<MessageProto2>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<GZipWrapper<MessageProto2>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<GZipWrapper<MessageProto3>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<GZipWrapper<MessageProto3>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<GZipWrapper<MessageProto4>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<GZipWrapper<MessageProto4>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<IDSUser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<IDSUser>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<JoinedOSConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<JoinedOSConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<NSArray<LPIconMetadata>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<NSArray<LPIconMetadata>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<NSArray<LPImageMetadata>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<NSArray<LPImageMetadata>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<SystemTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<SystemTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::Address> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::Address>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::Attachment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::Attachment>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::AttachmentMetaExtra> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::AttachmentMetaExtra>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::Balloon> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::Balloon>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::BalloonLayout> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::BalloonLayout>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::CertifiedContext> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::CertifiedContext>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::CloudAttachment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::CloudAttachment>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::CloudChat> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::CloudChat>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::CloudMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::CloudMessage>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::CloudProp> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::CloudProp>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::ConversationData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::ConversationData>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::ExtensionApp> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::ExtensionApp>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::FTMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::FTMode>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::IMessagePosterRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::IMessagePosterRecord>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::IdmsRequestedSignIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::IdmsRequestedSignIn>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::LinkMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::LinkMeta>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::Location> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::Location>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::LoginState> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::LoginState>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::LPIconMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::LPIconMetadata>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::LPImageMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::LPImageMetadata>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::MMCSAttachmentMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::MMCSAttachmentMeta>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::MMCSFile> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::MMCSFile>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::NSURL> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::NSURL>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::PartExtension> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::PartExtension>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::PosterColor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::PosterColor>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::PRPosterContentMaterialStyle> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::PRPosterContentMaterialStyle>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::PushMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::PushMessage>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(String, u64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(String, u64)>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::RichLinkImageAttachmentSubstitute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::api::RichLinkImageAttachmentSubstitute>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::ScheduleMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::ScheduleMode>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::ShareProfileMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::ShareProfileMessage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::SharedPoster> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::SharedPoster>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::SupportAction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::SupportAction>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::SupportAlert> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::SupportAlert>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::api::TypingApp> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::api::TypingApp>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::api::MessageTarget>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::api::api::MessageTarget>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::api::PartExtension {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_msgWidth = <f64>::sse_decode(deserializer);
                let mut var_rotation = <f64>::sse_decode(deserializer);
                let mut var_sai = <u64>::sse_decode(deserializer);
                let mut var_scale = <f64>::sse_decode(deserializer);
                let mut var_update = <Option<bool>>::sse_decode(deserializer);
                let mut var_sli = <u64>::sse_decode(deserializer);
                let mut var_normalizedX = <f64>::sse_decode(deserializer);
                let mut var_normalizedY = <f64>::sse_decode(deserializer);
                let mut var_version = <u64>::sse_decode(deserializer);
                let mut var_hash = <String>::sse_decode(deserializer);
                let mut var_safi = <u64>::sse_decode(deserializer);
                let mut var_effectType = <i64>::sse_decode(deserializer);
                let mut var_stickerId = <String>::sse_decode(deserializer);
                return crate::api::api::PartExtension::Sticker {
                    msg_width: var_msgWidth,
                    rotation: var_rotation,
                    sai: var_sai,
                    scale: var_scale,
                    update: var_update,
                    sli: var_sli,
                    normalized_x: var_normalizedX,
                    normalized_y: var_normalizedY,
                    version: var_version,
                    hash: var_hash,
                    safi: var_safi,
                    effect_type: var_effectType,
                    sticker_id: var_stickerId,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::PermanentDeleteMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_target = <crate::api::api::DeleteTarget>::sse_decode(deserializer);
        let mut var_isScheduled = <bool>::sse_decode(deserializer);
        return crate::api::api::PermanentDeleteMessage {
            target: var_target,
            is_scheduled: var_isScheduled,
        };
    }
}

impl SseDecode for crate::api::api::PhotoPosterContents {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_layers = <Vec<crate::api::api::PhotoPosterLayer>>::sse_decode(deserializer);
        let mut var_properties = <crate::api::api::PhotoPosterProperties>::sse_decode(deserializer);
        return crate::api::api::PhotoPosterContents {
            version: var_version,
            layers: var_layers,
            properties: var_properties,
        };
    }
}

impl SseDecode for crate::api::api::PhotoPosterContentsFrame {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_width = <f64>::sse_decode(deserializer);
        let mut var_height = <f64>::sse_decode(deserializer);
        let mut var_x = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        return crate::api::api::PhotoPosterContentsFrame {
            width: var_width,
            height: var_height,
            x: var_x,
            y: var_y,
        };
    }
}

impl SseDecode for crate::api::api::PhotoPosterContentsSize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_width = <f64>::sse_decode(deserializer);
        let mut var_height = <f64>::sse_decode(deserializer);
        return crate::api::api::PhotoPosterContentsSize {
            width: var_width,
            height: var_height,
        };
    }
}

impl SseDecode for crate::api::api::PhotoPosterLayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_frame = <crate::api::api::PhotoPosterContentsFrame>::sse_decode(deserializer);
        let mut var_filename = <String>::sse_decode(deserializer);
        let mut var_zPosition = <f32>::sse_decode(deserializer);
        let mut var_identifier = <String>::sse_decode(deserializer);
        return crate::api::api::PhotoPosterLayer {
            frame: var_frame,
            filename: var_filename,
            z_position: var_zPosition,
            identifier: var_identifier,
        };
    }
}

impl SseDecode for crate::api::api::PhotoPosterLayout {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_clockIntersection = <u32>::sse_decode(deserializer);
        let mut var_deviceResolution =
            <crate::api::api::PhotoPosterContentsSize>::sse_decode(deserializer);
        let mut var_visibleFrame =
            <crate::api::api::PhotoPosterContentsFrame>::sse_decode(deserializer);
        let mut var_timeFrame =
            <crate::api::api::PhotoPosterContentsFrame>::sse_decode(deserializer);
        let mut var_clockLayerOrder = <String>::sse_decode(deserializer);
        let mut var_hasTopEdgeContact = <bool>::sse_decode(deserializer);
        let mut var_inactiveFrame =
            <crate::api::api::PhotoPosterContentsFrame>::sse_decode(deserializer);
        let mut var_imageSize =
            <crate::api::api::PhotoPosterContentsSize>::sse_decode(deserializer);
        let mut var_parallaxPadding =
            <crate::api::api::PhotoPosterContentsSize>::sse_decode(deserializer);
        return crate::api::api::PhotoPosterLayout {
            clock_intersection: var_clockIntersection,
            device_resolution: var_deviceResolution,
            visible_frame: var_visibleFrame,
            time_frame: var_timeFrame,
            clock_layer_order: var_clockLayerOrder,
            has_top_edge_contact: var_hasTopEdgeContact,
            inactive_frame: var_inactiveFrame,
            image_size: var_imageSize,
            parallax_padding: var_parallaxPadding,
        };
    }
}

impl SseDecode for crate::api::api::PhotoPosterProperties {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_portraitLayout = <crate::api::api::PhotoPosterLayout>::sse_decode(deserializer);
        let mut var_settlingEffectEnabled = <bool>::sse_decode(deserializer);
        let mut var_depthEnabled = <bool>::sse_decode(deserializer);
        let mut var_clockAreaLuminance = <f64>::sse_decode(deserializer);
        let mut var_parallaxDisabled = <bool>::sse_decode(deserializer);
        return crate::api::api::PhotoPosterProperties {
            portrait_layout: var_portraitLayout,
            settling_effect_enabled: var_settlingEffectEnabled,
            depth_enabled: var_depthEnabled,
            clock_area_luminance: var_clockAreaLuminance,
            parallax_disabled: var_parallaxDisabled,
        };
    }
}

impl SseDecode for crate::api::api::PollResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::api::PollResult::Stop;
            }
            1 => {
                let mut var_field0 =
                    <Option<crate::api::api::PushMessage>>::sse_decode(deserializer);
                return crate::api::api::PollResult::Cont(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::PosterAsset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_contents = <crate::api::api::PhotoPosterContents>::sse_decode(deserializer);
        let mut var_files = <std::collections::HashMap<String, Vec<u8>>>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        return crate::api::api::PosterAsset {
            contents: var_contents,
            files: var_files,
            uuid: var_uuid,
        };
    }
}

impl SseDecode for crate::api::api::PosterColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_alpha = <f64>::sse_decode(deserializer);
        let mut var_blue = <f64>::sse_decode(deserializer);
        let mut var_green = <f64>::sse_decode(deserializer);
        let mut var_red = <f64>::sse_decode(deserializer);
        return crate::api::api::PosterColor {
            alpha: var_alpha,
            blue: var_blue,
            green: var_green,
            red: var_red,
        };
    }
}

impl SseDecode for crate::api::api::PosterRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::api::PosterRole::PRPosterRoleBackdrop,
            1 => crate::api::api::PosterRole::PRPosterRoleIncomingCall,
            _ => unreachable!("Invalid variant for PosterRole: {}", inner),
        };
    }
}

impl SseDecode for crate::api::api::PosterType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_assets = <Vec<crate::api::api::PosterAsset>>::sse_decode(deserializer);
                return crate::api::api::PosterType::Photo { assets: var_assets };
            }
            1 => {
                let mut var_data = <crate::api::api::MonogramData>::sse_decode(deserializer);
                let mut var_background = <crate::api::api::PosterColor>::sse_decode(deserializer);
                return crate::api::api::PosterType::Monogram {
                    data: var_data,
                    background: var_background,
                };
            }
            2 => {
                let mut var_data = <crate::api::api::MemojiData>::sse_decode(deserializer);
                let mut var_background = <crate::api::api::PosterColor>::sse_decode(deserializer);
                return crate::api::api::PosterType::Memoji {
                    data: var_data,
                    background: var_background,
                };
            }
            3 => {
                let mut var_data =
                    <crate::api::api::TranscriptDynamicUserData>::sse_decode(deserializer);
                return crate::api::api::PosterType::TranscriptDynamic { data: var_data };
            }
            4 => {
                let mut var_colors = <Vec<crate::api::api::PosterColor>>::sse_decode(deserializer);
                return crate::api::api::PosterType::TranscriptGradient { colors: var_colors };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::PRPosterColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_preferredStyle = <u32>::sse_decode(deserializer);
        let mut var_identifier = <String>::sse_decode(deserializer);
        let mut var_suggested = <bool>::sse_decode(deserializer);
        let mut var_color = <crate::api::api::UIColor>::sse_decode(deserializer);
        return crate::api::api::PRPosterColor {
            preferred_style: var_preferredStyle,
            identifier: var_identifier,
            suggested: var_suggested,
            color: var_color,
        };
    }
}

impl SseDecode for crate::api::api::PRPosterContentMaterialStyle {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_variation = <f32>::sse_decode(deserializer);
                let mut var_colors = <Vec<crate::api::api::UIColor>>::sse_decode(deserializer);
                let mut var_vibrant = <bool>::sse_decode(deserializer);
                let mut var_supportsVariation = <bool>::sse_decode(deserializer);
                let mut var_needsToResolveVariation = <bool>::sse_decode(deserializer);
                return crate::api::api::PRPosterContentMaterialStyle::PRPosterContentDiscreteColorsStyle{variation: var_variation, colors: var_colors, vibrant: var_vibrant, supports_variation: var_supportsVariation, needs_to_resolve_variation: var_needsToResolveVariation};
            }
            1 => {
                return crate::api::api::PRPosterContentMaterialStyle::PRPosterContentVibrantMaterialStyle;
            }
            2 => {
                let mut var_gradientType = <u32>::sse_decode(deserializer);
                let mut var_colors = <Vec<crate::api::api::UIColor>>::sse_decode(deserializer);
                let mut var_startPoint = <String>::sse_decode(deserializer);
                let mut var_locations = <Vec<f64>>::sse_decode(deserializer);
                let mut var_endPoint = <String>::sse_decode(deserializer);
                return crate::api::api::PRPosterContentMaterialStyle::PRPosterContentGradientStyle{gradient_type: var_gradientType, colors: var_colors, start_point: var_startPoint, locations: var_locations, end_point: var_endPoint};
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::PRPosterSystemTimeFontConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isSystemItem = <bool>::sse_decode(deserializer);
        let mut var_timeFontIdentifier = <String>::sse_decode(deserializer);
        let mut var_weight = <f64>::sse_decode(deserializer);
        return crate::api::api::PRPosterSystemTimeFontConfiguration {
            is_system_item: var_isSystemItem,
            time_font_identifier: var_timeFontIdentifier,
            weight: var_weight,
        };
    }
}

impl SseDecode for crate::api::api::PRPosterTitleStyleConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_alternateDateEnabled = <bool>::sse_decode(deserializer);
        let mut var_contentsLuminence = <f64>::sse_decode(deserializer);
        let mut var_groupName = <String>::sse_decode(deserializer);
        let mut var_preferredTitleAlignment = <u32>::sse_decode(deserializer);
        let mut var_preferredTitleLayout = <u32>::sse_decode(deserializer);
        let mut var_timeFontConfiguration =
            <crate::api::api::PRPosterSystemTimeFontConfiguration>::sse_decode(deserializer);
        let mut var_timeNumberingSystem = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_titleColor = <crate::api::api::PRPosterColor>::sse_decode(deserializer);
        let mut var_titleContentStyle = <Vec<u8>>::sse_decode(deserializer);
        let mut var_userConfigured = <bool>::sse_decode(deserializer);
        let mut var_titleStyle =
            <Option<crate::api::api::PRPosterContentMaterialStyle>>::sse_decode(deserializer);
        return crate::api::api::PRPosterTitleStyleConfiguration {
            alternate_date_enabled: var_alternateDateEnabled,
            contents_luminence: var_contentsLuminence,
            group_name: var_groupName,
            preferred_title_alignment: var_preferredTitleAlignment,
            preferred_title_layout: var_preferredTitleLayout,
            time_font_configuration: var_timeFontConfiguration,
            time_numbering_system: var_timeNumberingSystem,
            title_color: var_titleColor,
            title_content_style: var_titleContentStyle,
            user_configured: var_userConfigured,
            title_style: var_titleStyle,
        };
    }
}

impl SseDecode for crate::api::api::PrivateDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uuid = <Option<String>>::sse_decode(deserializer);
        let mut var_deviceName = <Option<String>>::sse_decode(deserializer);
        let mut var_token = <Vec<u8>>::sse_decode(deserializer);
        let mut var_isHsaTrusted = <bool>::sse_decode(deserializer);
        let mut var_identites = <Vec<String>>::sse_decode(deserializer);
        let mut var_subServices = <Vec<String>>::sse_decode(deserializer);
        return crate::api::api::PrivateDeviceInfo {
            uuid: var_uuid,
            device_name: var_deviceName,
            token: var_token,
            is_hsa_trusted: var_isHsaTrusted,
            identites: var_identites,
            sub_services: var_subServices,
        };
    }
}

impl SseDecode for crate::api::api::PushMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::api::MessageInst>::sse_decode(deserializer);
                return crate::api::api::PushMessage::IMessage(var_field0);
            }
            1 => {
                let mut var_uuid = <String>::sse_decode(deserializer);
                let mut var_error = <Option<String>>::sse_decode(deserializer);
                return crate::api::api::PushMessage::SendConfirm {
                    uuid: var_uuid,
                    error: var_error,
                };
            }
            2 => {
                let mut var_field0 = <crate::api::api::RegisterState>::sse_decode(deserializer);
                return crate::api::api::PushMessage::RegistrationState(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::api::api::SharedAlbum>::sse_decode(deserializer);
                return crate::api::api::PushMessage::NewPhotostream(var_field0);
            }
            4 => {
                let mut var_field0 = <crate::api::api::FTMessage>::sse_decode(deserializer);
                return crate::api::api::PushMessage::FaceTime(var_field0);
            }
            5 => {
                let mut var_field0 = <crate::api::api::StatusKitMessage>::sse_decode(deserializer);
                return crate::api::api::PushMessage::StatusUpdate(var_field0);
            }
            6 => {
                let mut var_field0 = <crate::api::api::IdmsMessage>::sse_decode(deserializer);
                return crate::api::api::PushMessage::Idms(var_field0);
            }
            7 => {
                let mut var_field0 = <bool>::sse_decode(deserializer);
                return crate::api::api::PushMessage::TwoFaAuthEvent(var_field0);
            }
            8 => {
                return crate::api::api::PushMessage::CircleFinishEvent;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::QuotaInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalBytes = <u64>::sse_decode(deserializer);
        let mut var_availableBytes = <u64>::sse_decode(deserializer);
        let mut var_messagesBytes = <u64>::sse_decode(deserializer);
        return crate::api::api::QuotaInfo {
            total_bytes: var_totalBytes,
            available_bytes: var_availableBytes,
            messages_bytes: var_messagesBytes,
        };
    }
}

impl SseDecode for crate::api::api::ReactMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_toUuid = <String>::sse_decode(deserializer);
        let mut var_toPart = <Option<u64>>::sse_decode(deserializer);
        let mut var_reaction = <crate::api::api::ReactMessageType>::sse_decode(deserializer);
        let mut var_toText = <String>::sse_decode(deserializer);
        let mut var_embeddedProfile =
            <Option<crate::api::api::ShareProfileMessage>>::sse_decode(deserializer);
        return crate::api::api::ReactMessage {
            to_uuid: var_toUuid,
            to_part: var_toPart,
            reaction: var_reaction,
            to_text: var_toText,
            embedded_profile: var_embeddedProfile,
        };
    }
}

impl SseDecode for crate::api::api::ReactMessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_reaction = <crate::api::api::Reaction>::sse_decode(deserializer);
                let mut var_enable = <bool>::sse_decode(deserializer);
                return crate::api::api::ReactMessageType::React {
                    reaction: var_reaction,
                    enable: var_enable,
                };
            }
            1 => {
                let mut var_spec = <crate::api::api::ExtensionApp>::sse_decode(deserializer);
                let mut var_body = <crate::api::api::MessageParts>::sse_decode(deserializer);
                let mut var_isMeta = <bool>::sse_decode(deserializer);
                return crate::api::api::ReactMessageType::Extension {
                    spec: var_spec,
                    body: var_body,
                    is_meta: var_isMeta,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::Reaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::api::Reaction::Heart;
            }
            1 => {
                return crate::api::api::Reaction::Like;
            }
            2 => {
                return crate::api::api::Reaction::Dislike;
            }
            3 => {
                return crate::api::api::Reaction::Laugh;
            }
            4 => {
                return crate::api::api::Reaction::Emphasize;
            }
            5 => {
                return crate::api::api::Reaction::Question;
            }
            6 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::api::Reaction::Emoji(var_field0);
            }
            7 => {
                let mut var_spec =
                    <Option<crate::api::api::ExtensionApp>>::sse_decode(deserializer);
                let mut var_body = <crate::api::api::MessageParts>::sse_decode(deserializer);
                return crate::api::api::Reaction::Sticker {
                    spec: var_spec,
                    body: var_body,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode
    for (
        Vec<u8>,
        std::collections::HashMap<String, Option<crate::api::api::CloudAttachment>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <std::collections::HashMap<
            String,
            Option<crate::api::api::CloudAttachment>,
        >>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        Vec<u8>,
        std::collections::HashMap<String, Option<crate::api::api::CloudChat>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 =
            <std::collections::HashMap<String, Option<crate::api::api::CloudChat>>>::sse_decode(
                deserializer,
            );
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        Vec<u8>,
        std::collections::HashMap<String, Option<crate::api::api::CloudMessage>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <std::collections::HashMap<
            String,
            Option<crate::api::api::CloudMessage>,
        >>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (Vec<u8>, Option<Vec<u8>>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <Option<Vec<u8>>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (Vec<crate::api::api::SharedAlbum>, Vec<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<crate::api::api::SharedAlbum>>::sse_decode(deserializer);
        let mut var_field1 = <Vec<String>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        Vec<crate::api::api::TrustedPhoneNumber>,
        Option<crate::api::api::LoginState>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<crate::api::api::TrustedPhoneNumber>>::sse_decode(deserializer);
        let mut var_field1 = <Option<crate::api::api::LoginState>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (crate::api::api::LoginState, Option<IDSUser>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::api::LoginState>::sse_decode(deserializer);
        let mut var_field1 = <Option<IDSUser>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        std::collections::HashMap<String, crate::api::api::SyncStatus>,
        Option<(String, u64)>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <std::collections::HashMap<String, crate::api::api::SyncStatus>>::sse_decode(
                deserializer,
            );
        let mut var_field1 = <Option<(String, u64)>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, Asset) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Asset>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, StCollapsedValue) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <StCollapsedValue>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, bool) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <bool>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::CloudAttachment) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::CloudAttachment>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::CloudChat) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::CloudChat>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::CloudMessage) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::CloudMessage>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::FTParticipant) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::FTParticipant>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, Vec<crate::api::api::MessageEdit>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Vec<crate::api::api::MessageEdit>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, Vec<u8>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Vec<u8>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::MessageEditRange) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::MessageEditRange>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, Option<crate::api::api::CloudAttachment>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Option<crate::api::api::CloudAttachment>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, Option<crate::api::api::CloudChat>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Option<crate::api::api::CloudChat>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, Option<crate::api::api::CloudMessage>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Option<crate::api::api::CloudMessage>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::StatusKitPersonalConfig) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::StatusKitPersonalConfig>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::api::api::SyncStatus) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::SyncStatus>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, u64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <u64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (u32, crate::api::api::NSDictionaryTypedCoder) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u32>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::api::NSDictionaryTypedCoder>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::api::RegisterState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_nextS = <i64>::sse_decode(deserializer);
                return crate::api::api::RegisterState::Registered { next_s: var_nextS };
            }
            1 => {
                return crate::api::api::RegisterState::Registering;
            }
            2 => {
                let mut var_retryWait = <Option<u64>>::sse_decode(deserializer);
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::api::api::RegisterState::Failed {
                    retry_wait: var_retryWait,
                    error: var_error,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::RegistrationPhase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::api::RegistrationPhase::WantsOSConfig,
            1 => crate::api::api::RegistrationPhase::WantsRegister,
            2 => crate::api::api::RegistrationPhase::Registered,
            _ => unreachable!("Invalid variant for RegistrationPhase: {}", inner),
        };
    }
}

impl SseDecode for crate::api::api::RenameMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_newName = <String>::sse_decode(deserializer);
        return crate::api::api::RenameMessage {
            new_name: var_newName,
        };
    }
}

impl SseDecode for crate::api::api::ReportMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_guid = <String>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_conversationSize = <u32>::sse_decode(deserializer);
        let mut var_parts = <crate::api::api::MessageParts>::sse_decode(deserializer);
        let mut var_timeOfMessage = <f64>::sse_decode(deserializer);
        return crate::api::api::ReportMessage {
            guid: var_guid,
            sender: var_sender,
            conversation_size: var_conversationSize,
            parts: var_parts,
            time_of_message: var_timeOfMessage,
        };
    }
}

impl SseDecode for crate::api::api::RichLinkImageAttachmentSubstitute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mimeType = <String>::sse_decode(deserializer);
        let mut var_richLinkImageAttachmentSubstituteIndex = <u64>::sse_decode(deserializer);
        return crate::api::api::RichLinkImageAttachmentSubstitute {
            mime_type: var_mimeType,
            rich_link_image_attachment_substitute_index: var_richLinkImageAttachmentSubstituteIndex,
        };
    }
}

impl SseDecode for crate::api::api::ScheduleMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ms = <u64>::sse_decode(deserializer);
        let mut var_schedule = <bool>::sse_decode(deserializer);
        return crate::api::api::ScheduleMode {
            ms: var_ms,
            schedule: var_schedule,
        };
    }
}

impl SseDecode for crate::api::api::SetTranscriptBackgroundMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_aid = <u32>::sse_decode(deserializer);
                let mut var_bid = <u32>::sse_decode(deserializer);
                let mut var_chatId = <Option<String>>::sse_decode(deserializer);
                let mut var_remove = <bool>::sse_decode(deserializer);
                return crate::api::api::SetTranscriptBackgroundMessage::Remove {
                    aid: var_aid,
                    bid: var_bid,
                    chat_id: var_chatId,
                    remove: var_remove,
                };
            }
            1 => {
                let mut var_aid = <u32>::sse_decode(deserializer);
                let mut var_bid = <u32>::sse_decode(deserializer);
                let mut var_chatId = <Option<String>>::sse_decode(deserializer);
                let mut var_objectId = <String>::sse_decode(deserializer);
                let mut var_payloadVersion = <u32>::sse_decode(deserializer);
                let mut var_backgroundId = <String>::sse_decode(deserializer);
                let mut var_url = <String>::sse_decode(deserializer);
                let mut var_signature = <String>::sse_decode(deserializer);
                let mut var_key = <String>::sse_decode(deserializer);
                let mut var_fileSize = <usize>::sse_decode(deserializer);
                return crate::api::api::SetTranscriptBackgroundMessage::Set {
                    aid: var_aid,
                    bid: var_bid,
                    chat_id: var_chatId,
                    object_id: var_objectId,
                    payload_version: var_payloadVersion,
                    background_id: var_backgroundId,
                    url: var_url,
                    signature: var_signature,
                    key: var_key,
                    file_size: var_fileSize,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::ShareProfileMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cloudKitDecryptionRecordKey = <Vec<u8>>::sse_decode(deserializer);
        let mut var_cloudKitRecordKey = <String>::sse_decode(deserializer);
        let mut var_poster = <Option<crate::api::api::SharedPoster>>::sse_decode(deserializer);
        return crate::api::api::ShareProfileMessage {
            cloud_kit_decryption_record_key: var_cloudKitDecryptionRecordKey,
            cloud_kit_record_key: var_cloudKitRecordKey,
            poster: var_poster,
        };
    }
}

impl SseDecode for crate::api::api::SharedAlbum {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_fullname = <Option<String>>::sse_decode(deserializer);
        let mut var_email = <Option<String>>::sse_decode(deserializer);
        let mut var_albumguid = <String>::sse_decode(deserializer);
        let mut var_sharingtype = <String>::sse_decode(deserializer);
        let mut var_subscriptiondate = <Option<String>>::sse_decode(deserializer);
        let mut var_albumlocation = <Option<String>>::sse_decode(deserializer);
        let mut var_assets = <Vec<String>>::sse_decode(deserializer);
        let mut var_delete = <Option<String>>::sse_decode(deserializer);
        return crate::api::api::SharedAlbum {
            name: var_name,
            fullname: var_fullname,
            email: var_email,
            albumguid: var_albumguid,
            sharingtype: var_sharingtype,
            subscriptiondate: var_subscriptiondate,
            albumlocation: var_albumlocation,
            assets: var_assets,
            delete: var_delete,
        };
    }
}

impl SseDecode for crate::api::api::SharedPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lowResWallpaperTag = <Vec<u8>>::sse_decode(deserializer);
        let mut var_wallpaperTag = <Vec<u8>>::sse_decode(deserializer);
        let mut var_messageTag = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::api::SharedPoster {
            low_res_wallpaper_tag: var_lowResWallpaperTag,
            wallpaper_tag: var_wallpaperTag,
            message_tag: var_messageTag,
        };
    }
}

impl SseDecode for crate::api::api::SimplifiedIncomingCallPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_poster = <crate::api::api::SimplifiedPoster>::sse_decode(deserializer);
        let mut var_textMetadata = <crate::api::api::WallpaperMetadata>::sse_decode(deserializer);
        let mut var_lowRes = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::api::SimplifiedIncomingCallPoster {
            poster: var_poster,
            text_metadata: var_textMetadata,
            low_res: var_lowRes,
        };
    }
}

impl SseDecode for crate::api::api::SimplifiedPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_titleConfiguration =
            <crate::api::api::PRPosterTitleStyleConfiguration>::sse_decode(deserializer);
        let mut var_type = <crate::api::api::PosterType>::sse_decode(deserializer);
        let mut var_role = <crate::api::api::PosterRole>::sse_decode(deserializer);
        return crate::api::api::SimplifiedPoster {
            title_configuration: var_titleConfiguration,
            r#type: var_type,
            role: var_role,
        };
    }
}

impl SseDecode for crate::api::api::SimplifiedTranscriptPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_watch = <crate::api::api::WatchBackground>::sse_decode(deserializer);
        let mut var_poster = <crate::api::api::SimplifiedPoster>::sse_decode(deserializer);
        return crate::api::api::SimplifiedTranscriptPoster {
            watch: var_watch,
            poster: var_poster,
        };
    }
}

impl SseDecode for crate::api::api::StatusKitMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_user = <String>::sse_decode(deserializer);
                let mut var_mode = <Option<String>>::sse_decode(deserializer);
                let mut var_allowed = <bool>::sse_decode(deserializer);
                return crate::api::api::StatusKitMessage::StatusChanged {
                    user: var_user,
                    mode: var_mode,
                    allowed: var_allowed,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::StatusKitPersonalConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_allowedModes = <Vec<String>>::sse_decode(deserializer);
        return crate::api::api::StatusKitPersonalConfig {
            allowed_modes: var_allowedModes,
        };
    }
}

impl SseDecode for crate::api::api::SupportAction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_button = <String>::sse_decode(deserializer);
        return crate::api::api::SupportAction {
            url: var_url,
            button: var_button,
        };
    }
}

impl SseDecode for crate::api::api::SupportAlert {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_body = <String>::sse_decode(deserializer);
        let mut var_action = <Option<crate::api::api::SupportAction>>::sse_decode(deserializer);
        return crate::api::api::SupportAlert {
            title: var_title,
            body: var_body,
            action: var_action,
        };
    }
}

impl SseDecode for crate::api::api::SyncStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::api::SyncStatus::Synced;
            }
            1 => {
                let mut var_progress = <usize>::sse_decode(deserializer);
                let mut var_total = <usize>::sse_decode(deserializer);
                return crate::api::api::SyncStatus::Downloading {
                    progress: var_progress,
                    total: var_total,
                };
            }
            2 => {
                let mut var_progress = <usize>::sse_decode(deserializer);
                let mut var_total = <usize>::sse_decode(deserializer);
                return crate::api::api::SyncStatus::Uploading {
                    progress: var_progress,
                    total: var_total,
                };
            }
            3 => {
                return crate::api::api::SyncStatus::Syncing;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::TeardownSignIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prevtxnid = <String>::sse_decode(deserializer);
        return crate::api::api::TeardownSignIn {
            prevtxnid: var_prevtxnid,
        };
    }
}

impl SseDecode for crate::api::api::TextEffect {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::api::TextEffect::Big,
            1 => crate::api::api::TextEffect::Small,
            2 => crate::api::api::TextEffect::Shake,
            3 => crate::api::api::TextEffect::Nod,
            4 => crate::api::api::TextEffect::Explode,
            5 => crate::api::api::TextEffect::Ripple,
            6 => crate::api::api::TextEffect::Bloom,
            7 => crate::api::api::TextEffect::Jitter,
            _ => unreachable!("Invalid variant for TextEffect: {}", inner),
        };
    }
}

impl SseDecode for crate::api::api::TextFlags {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bold = <bool>::sse_decode(deserializer);
        let mut var_italic = <bool>::sse_decode(deserializer);
        let mut var_underline = <bool>::sse_decode(deserializer);
        let mut var_strikethrough = <bool>::sse_decode(deserializer);
        return crate::api::api::TextFlags {
            bold: var_bold,
            italic: var_italic,
            underline: var_underline,
            strikethrough: var_strikethrough,
        };
    }
}

impl SseDecode for crate::api::api::TextFormat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::api::TextFlags>::sse_decode(deserializer);
                return crate::api::api::TextFormat::Flags(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::api::TextEffect>::sse_decode(deserializer);
                return crate::api::api::TextFormat::Effect(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::api::TranscriptDynamicUserData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_identifier = <String>::sse_decode(deserializer);
        return crate::api::api::TranscriptDynamicUserData {
            identifier: var_identifier,
        };
    }
}

impl SseDecode for crate::api::api::TransferProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prog = <usize>::sse_decode(deserializer);
        let mut var_total = <usize>::sse_decode(deserializer);
        let mut var_attachment = <Option<crate::api::api::Attachment>>::sse_decode(deserializer);
        return crate::api::api::TransferProgress {
            prog: var_prog,
            total: var_total,
            attachment: var_attachment,
        };
    }
}

impl SseDecode for crate::api::api::TrustedPhoneNumber {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_numberWithDialCode = <String>::sse_decode(deserializer);
        let mut var_lastTwoDigits = <String>::sse_decode(deserializer);
        let mut var_pushMode = <String>::sse_decode(deserializer);
        let mut var_id = <u32>::sse_decode(deserializer);
        return crate::api::api::TrustedPhoneNumber {
            number_with_dial_code: var_numberWithDialCode,
            last_two_digits: var_lastTwoDigits,
            push_mode: var_pushMode,
            id: var_id,
        };
    }
}

impl SseDecode for crate::api::api::TypingApp {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bundleId = <String>::sse_decode(deserializer);
        let mut var_icon = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::api::TypingApp {
            bundle_id: var_bundleId,
            icon: var_icon,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for crate::api::api::UIColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_colorComponents = <u32>::sse_decode(deserializer);
                let mut var_green = <f64>::sse_decode(deserializer);
                let mut var_blue = <f64>::sse_decode(deserializer);
                let mut var_red = <f64>::sse_decode(deserializer);
                let mut var_greenDbl = <Option<f64>>::sse_decode(deserializer);
                let mut var_blueDbl = <Option<f64>>::sse_decode(deserializer);
                let mut var_redDbl = <Option<f64>>::sse_decode(deserializer);
                let mut var_alphaDbl = <Option<f64>>::sse_decode(deserializer);
                let mut var_alpha = <f64>::sse_decode(deserializer);
                let mut var_rgb = <Vec<u8>>::sse_decode(deserializer);
                let mut var_colorSpace = <u32>::sse_decode(deserializer);
                let mut var_class_ = <String>::sse_decode(deserializer);
                return crate::api::api::UIColor::RGBAColorSpace {
                    color_components: var_colorComponents,
                    green: var_green,
                    blue: var_blue,
                    red: var_red,
                    green_dbl: var_greenDbl,
                    blue_dbl: var_blueDbl,
                    red_dbl: var_redDbl,
                    alpha_dbl: var_alphaDbl,
                    alpha: var_alpha,
                    rgb: var_rgb,
                    color_space: var_colorSpace,
                    class: var_class_,
                };
            }
            1 => {
                let mut var_colorComponents = <u32>::sse_decode(deserializer);
                let mut var_white = <f64>::sse_decode(deserializer);
                let mut var_alpha = <f64>::sse_decode(deserializer);
                let mut var_bin = <Vec<u8>>::sse_decode(deserializer);
                let mut var_colorSpace = <u32>::sse_decode(deserializer);
                let mut var_class_ = <String>::sse_decode(deserializer);
                return crate::api::api::UIColor::GrayscaleAlphaColorSpace {
                    color_components: var_colorComponents,
                    white: var_white,
                    alpha: var_alpha,
                    bin: var_bin,
                    color_space: var_colorSpace,
                    class: var_class_,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::api::UnsendMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tuuid = <String>::sse_decode(deserializer);
        let mut var_editPart = <u64>::sse_decode(deserializer);
        return crate::api::api::UnsendMessage {
            tuuid: var_tuuid,
            edit_part: var_editPart,
        };
    }
}

impl SseDecode for crate::api::api::UpdateExtensionMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_forUuid = <String>::sse_decode(deserializer);
        let mut var_ext = <crate::api::api::PartExtension>::sse_decode(deserializer);
        return crate::api::api::UpdateExtensionMessage {
            for_uuid: var_forUuid,
            ext: var_ext,
        };
    }
}

impl SseDecode for crate::api::api::UpdateProfileMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_profile =
            <Option<crate::api::api::ShareProfileMessage>>::sse_decode(deserializer);
        let mut var_shareContacts = <bool>::sse_decode(deserializer);
        return crate::api::api::UpdateProfileMessage {
            profile: var_profile,
            share_contacts: var_shareContacts,
        };
    }
}

impl SseDecode for crate::api::api::UpdateProfileSharingMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sharedDismissed = <Vec<String>>::sse_decode(deserializer);
        let mut var_sharedAll = <Vec<String>>::sse_decode(deserializer);
        let mut var_version = <u64>::sse_decode(deserializer);
        return crate::api::api::UpdateProfileSharingMessage {
            shared_dismissed: var_sharedDismissed,
            shared_all: var_sharedAll,
            version: var_version,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::api::WallpaperMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backgroundColorKey =
            <Option<crate::api::api::PosterColor>>::sse_decode(deserializer);
        let mut var_fontColorKey = <crate::api::api::PosterColor>::sse_decode(deserializer);
        let mut var_fontNameKey = <String>::sse_decode(deserializer);
        let mut var_fontSizeKey = <f32>::sse_decode(deserializer);
        let mut var_fontWeightKey = <f32>::sse_decode(deserializer);
        let mut var_isVerticalKey = <bool>::sse_decode(deserializer);
        let mut var_typeKey = <String>::sse_decode(deserializer);
        return crate::api::api::WallpaperMetadata {
            background_color_key: var_backgroundColorKey,
            font_color_key: var_fontColorKey,
            font_name_key: var_fontNameKey,
            font_size_key: var_fontSizeKey,
            font_weight_key: var_fontWeightKey,
            is_vertical_key: var_isVerticalKey,
            type_key: var_typeKey,
        };
    }
}

impl SseDecode for crate::api::api::WatchBackground {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isHighKey = <bool>::sse_decode(deserializer);
        let mut var_luminance = <f64>::sse_decode(deserializer);
        let mut var_backgroundImageData = <Vec<u8>>::sse_decode(deserializer);
        let mut var_extensionIdentifier = <String>::sse_decode(deserializer);
        return crate::api::api::WatchBackground {
            is_high_key: var_isHighKey,
            luminance: var_luminance,
            background_image_data: var_backgroundImageData,
            extension_identifier: var_extensionIdentifier,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        11 => wire__crate__api__api__add_album_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__api__answer_ft_request_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__api__approve_circle_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__api__attachment_get_size_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__api__auth_phone_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__api__can_find_my_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__api__can_profile_share_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__api__api__can_statuskit_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__api__cancel_facetime_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__api__certify_delivery_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__api__circle_setup_clique_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__api__complete_msg_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__api__config_from_encoded_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__api__config_from_relay_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__api__config_from_validation_data_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        29 => wire__crate__api__api__configure_app_review_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__api__api__configure_macos_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__api__convert_token_to_uuid_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__api__create_facetime_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__api__create_icon_array_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__api__create_image_array_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__api__decline_facetime_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__api__decode_profile_message_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__api__decode_summary_info_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__api__delete_attachments_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__api__delete_chats_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__api__delete_messages_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__api__do_reregister_impl(port, ptr, rust_vec_len, data_len),
        50 => wire__crate__api__api__download_attachment_impl(port, ptr, rust_vec_len, data_len),
        51 => wire__crate__api__api__download_cloud_attachments_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        52 => wire__crate__api__api__download_cloud_group_photos_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        53 => wire__crate__api__api__download_mmcs_impl(port, ptr, rust_vec_len, data_len),
        56 => wire__crate__api__api__encode_hex_impl(port, ptr, rust_vec_len, data_len),
        62 => wire__crate__api__api__encode_profile_message_impl(port, ptr, rust_vec_len, data_len),
        63 => wire__crate__api__api__encode_summary_info_impl(port, ptr, rust_vec_len, data_len),
        66 => wire__crate__api__api__fetch_profile_impl(port, ptr, rust_vec_len, data_len),
        67 => {
            wire__crate__api__api__ffi_file_packager_default_impl(port, ptr, rust_vec_len, data_len)
        }
        68 => wire__crate__api__api__from_poster_impl(port, ptr, rust_vec_len, data_len),
        69 => wire__crate__api__api__from_poster_save_impl(port, ptr, rust_vec_len, data_len),
        70 => wire__crate__api__api__from_transcript_poster_save_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        71 => wire__crate__api__api__ft_sessions_impl(port, ptr, rust_vec_len, data_len),
        72 => wire__crate__api__api__generate_udid_impl(port, ptr, rust_vec_len, data_len),
        73 => wire__crate__api__api__get_2fa_code_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__api__get_2fa_sms_opts_impl(port, ptr, rust_vec_len, data_len),
        75 => wire__crate__api__api__get_albums_impl(port, ptr, rust_vec_len, data_len),
        76 => wire__crate__api__api__get_anisette_headers_impl(port, ptr, rust_vec_len, data_len),
        77 => {
            wire__crate__api__api__get_background_following_impl(port, ptr, rust_vec_len, data_len)
        }
        78 => wire__crate__api__api__get_bottles_impl(port, ptr, rust_vec_len, data_len),
        79 => wire__crate__api__api__get_config_state_impl(port, ptr, rust_vec_len, data_len),
        80 => wire__crate__api__api__get_device_info_impl(port, ptr, rust_vec_len, data_len),
        81 => wire__crate__api__api__get_device_info_state_impl(port, ptr, rust_vec_len, data_len),
        82 => wire__crate__api__api__get_devices_impl(port, ptr, rust_vec_len, data_len),
        83 => wire__crate__api__api__get_following_impl(port, ptr, rust_vec_len, data_len),
        84 => wire__crate__api__api__get_ft_link_impl(port, ptr, rust_vec_len, data_len),
        85 => wire__crate__api__api__get_handles_impl(port, ptr, rust_vec_len, data_len),
        86 => wire__crate__api__api__get_my_phone_handles_impl(port, ptr, rust_vec_len, data_len),
        87 => wire__crate__api__api__get_phase_impl(port, ptr, rust_vec_len, data_len),
        88 => wire__crate__api__api__get_quota_info_impl(port, ptr, rust_vec_len, data_len),
        89 => wire__crate__api__api__get_regstate_impl(port, ptr, rust_vec_len, data_len),
        90 => wire__crate__api__api__get_sms_targets_impl(port, ptr, rust_vec_len, data_len),
        91 => wire__crate__api__api__get_syncstatus_impl(port, ptr, rust_vec_len, data_len),
        92 => wire__crate__api__api__get_token_impl(port, ptr, rust_vec_len, data_len),
        93 => wire__crate__api__api__get_user_name_impl(port, ptr, rust_vec_len, data_len),
        94 => wire__crate__api__api__invalidate_id_cache_impl(port, ptr, rust_vec_len, data_len),
        95 => wire__crate__api__api__invite_to_channel_impl(port, ptr, rust_vec_len, data_len),
        96 => wire__crate__api__api__is_in_clique_impl(port, ptr, rust_vec_len, data_len),
        97 => {
            wire__crate__api__api__join_clique_with_bottle_impl(port, ptr, rust_vec_len, data_len)
        }
        98 => wire__crate__api__api__make_find_my_friends_impl(port, ptr, rust_vec_len, data_len),
        99 => wire__crate__api__api__make_find_my_phone_impl(port, ptr, rust_vec_len, data_len),
        100 => {
            wire__crate__api__api__message_parts_raw_text_impl(port, ptr, rust_vec_len, data_len)
        }
        101 => {
            wire__crate__api__api__my_async_runtime_default_impl(port, ptr, rust_vec_len, data_len)
        }
        102 => wire__crate__api__api__new_msg_impl(port, ptr, rust_vec_len, data_len),
        103 => wire__crate__api__api__new_push_state_impl(port, ptr, rust_vec_len, data_len),
        113 => {
            wire__crate__api__api__pack_transcript_poster_impl(port, ptr, rust_vec_len, data_len)
        }
        114 => wire__crate__api__api__parse_poster_impl(port, ptr, rust_vec_len, data_len),
        115 => wire__crate__api__api__parse_poster_save_impl(port, ptr, rust_vec_len, data_len),
        116 => {
            wire__crate__api__api__parse_transcript_poster_impl(port, ptr, rust_vec_len, data_len)
        }
        117 => wire__crate__api__api__ptr_to_dart_impl(port, ptr, rust_vec_len, data_len),
        118 => wire__crate__api__api__recv_wait_impl(port, ptr, rust_vec_len, data_len),
        119 => wire__crate__api__api__refresh_background_following_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        120 => wire__crate__api__api__refresh_devices_impl(port, ptr, rust_vec_len, data_len),
        121 => wire__crate__api__api__refresh_following_impl(port, ptr, rust_vec_len, data_len),
        122 => wire__crate__api__api__refresh_token_impl(port, ptr, rust_vec_len, data_len),
        123 => wire__crate__api__api__register_ids_impl(port, ptr, rust_vec_len, data_len),
        124 => wire__crate__api__api__remove_album_impl(port, ptr, rust_vec_len, data_len),
        125 => wire__crate__api__api__report_messages_impl(port, ptr, rust_vec_len, data_len),
        126 => wire__crate__api__api__request_handles_impl(port, ptr, rust_vec_len, data_len),
        127 => wire__crate__api__api__reset_channel_keys_impl(port, ptr, rust_vec_len, data_len),
        128 => wire__crate__api__api__reset_clique_impl(port, ptr, rust_vec_len, data_len),
        129 => wire__crate__api__api__reset_state_impl(port, ptr, rust_vec_len, data_len),
        132 => wire__crate__api__api__restore_user_impl(port, ptr, rust_vec_len, data_len),
        133 => wire__crate__api__api__retry_login_impl(port, ptr, rust_vec_len, data_len),
        134 => wire__crate__api__api__save_attachment_impl(port, ptr, rust_vec_len, data_len),
        135 => wire__crate__api__api__save_attachments_impl(port, ptr, rust_vec_len, data_len),
        136 => wire__crate__api__api__save_chats_impl(port, ptr, rust_vec_len, data_len),
        138 => wire__crate__api__api__save_messages_impl(port, ptr, rust_vec_len, data_len),
        139 => wire__crate__api__api__save_user_impl(port, ptr, rust_vec_len, data_len),
        140 => {
            wire__crate__api__api__select_background_friend_impl(port, ptr, rust_vec_len, data_len)
        }
        141 => wire__crate__api__api__select_friend_impl(port, ptr, rust_vec_len, data_len),
        142 => wire__crate__api__api__send_impl(port, ptr, rust_vec_len, data_len),
        143 => wire__crate__api__api__send_2fa_sms_impl(port, ptr, rust_vec_len, data_len),
        144 => wire__crate__api__api__send_2fa_to_devices_impl(port, ptr, rust_vec_len, data_len),
        145 => wire__crate__api__api__service_from_ptr_impl(port, ptr, rust_vec_len, data_len),
        146 => wire__crate__api__api__set_profile_impl(port, ptr, rust_vec_len, data_len),
        147 => wire__crate__api__api__set_status_impl(port, ptr, rust_vec_len, data_len),
        148 => wire__crate__api__api__subscribe_impl(port, ptr, rust_vec_len, data_len),
        149 => wire__crate__api__api__subscribe_token_impl(port, ptr, rust_vec_len, data_len),
        150 => wire__crate__api__api__supports_keychain_impl(port, ptr, rust_vec_len, data_len),
        151 => {
            wire__crate__api__api__supports_shared_streams_impl(port, ptr, rust_vec_len, data_len)
        }
        152 => wire__crate__api__api__sync_attachments_impl(port, ptr, rust_vec_len, data_len),
        153 => wire__crate__api__api__sync_chats_impl(port, ptr, rust_vec_len, data_len),
        154 => wire__crate__api__api__sync_messages_impl(port, ptr, rust_vec_len, data_len),
        155 => wire__crate__api__api__sync_now_impl(port, ptr, rust_vec_len, data_len),
        156 => wire__crate__api__api__teardown_2fa_impl(port, ptr, rust_vec_len, data_len),
        157 => {
            wire__crate__api__api__transcript_poster_save_impl(port, ptr, rust_vec_len, data_len)
        }
        158 => wire__crate__api__api__try_auth_impl(port, ptr, rust_vec_len, data_len),
        159 => wire__crate__api__api__unsubscribe_impl(port, ptr, rust_vec_len, data_len),
        160 => {
            wire__crate__api__api__update_account_headers_impl(port, ptr, rust_vec_len, data_len)
        }
        161 => wire__crate__api__api__upload_attachment_impl(port, ptr, rust_vec_len, data_len),
        162 => {
            wire__crate__api__api__upload_cloud_attachments_impl(port, ptr, rust_vec_len, data_len)
        }
        163 => wire__crate__api__api__upload_group_photo_impl(port, ptr, rust_vec_len, data_len),
        164 => wire__crate__api__api__upload_mmcs_impl(port, ptr, rust_vec_len, data_len),
        165 => wire__crate__api__api__use_link_for_impl(port, ptr, rust_vec_len, data_len),
        167 => wire__crate__api__api__validate_cert_impl(port, ptr, rust_vec_len, data_len),
        168 => wire__crate__api__api__validate_relay_impl(port, ptr, rust_vec_len, data_len),
        169 => wire__crate__api__api__validate_targets_impl(port, ptr, rust_vec_len, data_len),
        170 => {
            wire__crate__api__api__validate_targets_facetime_impl(port, ptr, rust_vec_len, data_len)
        }
        171 => wire__crate__api__api__verify_2fa_impl(port, ptr, rust_vec_len, data_len),
        172 => wire__crate__api__api__verify_2fa_sms_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__api__MessageFlags_bits_impl(ptr, rust_vec_len, data_len),
        2 => {
            wire__crate__api__api__MessageFlags_from_bits_truncate_impl(ptr, rust_vec_len, data_len)
        }
        3 => wire__crate__api__api__ViableBottle_auto_accessor_get_device_name_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        4 => wire__crate__api__api__ViableBottle_auto_accessor_get_escrow_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__api__ViableBottle_auto_accessor_get_model_class_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__api__ViableBottle_auto_accessor_get_numeric_length_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        7 => wire__crate__api__api__ViableBottle_auto_accessor_set_device_name_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        8 => wire__crate__api__api__ViableBottle_auto_accessor_set_escrow_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__api__ViableBottle_auto_accessor_set_model_class_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire__crate__api__api__ViableBottle_auto_accessor_set_numeric_length_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        15 => wire__crate__api__api__attachment_to_cloud_impl(ptr, rust_vec_len, data_len),
        23 => wire__crate__api__api__clone_poster_impl(ptr, rust_vec_len, data_len),
        24 => wire__crate__api__api__clone_transcript_poster_impl(ptr, rust_vec_len, data_len),
        35 => wire__crate__api__api__date_now_impl(ptr, rust_vec_len, data_len),
        37 => wire__crate__api__api__decode_attachmentmeta_impl(ptr, rust_vec_len, data_len),
        38 => wire__crate__api__api__decode_chatproto_impl(ptr, rust_vec_len, data_len),
        39 => wire__crate__api__api__decode_message_info_impl(ptr, rust_vec_len, data_len),
        40 => wire__crate__api__api__decode_messageproto_impl(ptr, rust_vec_len, data_len),
        41 => wire__crate__api__api__decode_messageproto2_impl(ptr, rust_vec_len, data_len),
        42 => wire__crate__api__api__decode_messageproto3_impl(ptr, rust_vec_len, data_len),
        43 => wire__crate__api__api__decode_messageproto4_impl(ptr, rust_vec_len, data_len),
        54 => wire__crate__api__api__encode_attachmentmeta_impl(ptr, rust_vec_len, data_len),
        55 => wire__crate__api__api__encode_chatproto_impl(ptr, rust_vec_len, data_len),
        57 => wire__crate__api__api__encode_message_info_impl(ptr, rust_vec_len, data_len),
        58 => wire__crate__api__api__encode_messageproto_impl(ptr, rust_vec_len, data_len),
        59 => wire__crate__api__api__encode_messageproto2_impl(ptr, rust_vec_len, data_len),
        60 => wire__crate__api__api__encode_messageproto3_impl(ptr, rust_vec_len, data_len),
        61 => wire__crate__api__api__encode_messageproto4_impl(ptr, rust_vec_len, data_len),
        64 => wire__crate__api__api__extension_app_from_bp_impl(ptr, rust_vec_len, data_len),
        65 => wire__crate__api__api__extension_app_to_raw_impl(ptr, rust_vec_len, data_len),
        104 => wire__crate__api__api__ns_attributed_string_decode_impl(ptr, rust_vec_len, data_len),
        105 => wire__crate__api__api__ns_attributed_string_encode_impl(ptr, rust_vec_len, data_len),
        106 => wire__crate__api__api__ns_null_impl(ptr, rust_vec_len, data_len),
        107 => wire__crate__api__api__ns_number_decode_impl(ptr, rust_vec_len, data_len),
        108 => wire__crate__api__api__ns_number_encode_impl(ptr, rust_vec_len, data_len),
        109 => wire__crate__api__api__ns_string_decode_impl(ptr, rust_vec_len, data_len),
        110 => wire__crate__api__api__ns_string_encode_impl(ptr, rust_vec_len, data_len),
        111 => wire__crate__api__api__nscoder_decode_impl(ptr, rust_vec_len, data_len),
        112 => wire__crate__api__api__nscoder_encode_impl(ptr, rust_vec_len, data_len),
        130 => wire__crate__api__api__restore_attachment_impl(ptr, rust_vec_len, data_len),
        131 => wire__crate__api__api__restore_cloud_chat_impl(ptr, rust_vec_len, data_len),
        137 => wire__crate__api__api__save_cloud_chat_impl(ptr, rust_vec_len, data_len),
        166 => wire__crate__api__api__utm_now_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<PushState>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Arc<PushState>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<PushState>>> for Arc<PushState> {
    fn into_into_dart(self) -> FrbWrapper<Arc<PushState>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Asset> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Asset> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Asset>> for Asset {
    fn into_into_dart(self) -> FrbWrapper<Asset> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConversationLink> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ConversationLink> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConversationLink>> for ConversationLink {
    fn into_into_dart(self) -> FrbWrapper<ConversationLink> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConversationParticipant> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ConversationParticipant>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConversationParticipant>>
    for ConversationParticipant
{
    fn into_into_dart(self) -> FrbWrapper<ConversationParticipant> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Date> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Date> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Date>> for Date {
    fn into_into_dart(self) -> FrbWrapper<Date> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EscrowData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EscrowData> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EscrowData>> for EscrowData {
    fn into_into_dart(self) -> FrbWrapper<EscrowData> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FindMyFriendsClient<DefaultAnisetteProvider>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FindMyFriendsClient<DefaultAnisetteProvider>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FindMyFriendsClient<DefaultAnisetteProvider>>>
    for FindMyFriendsClient<DefaultAnisetteProvider>
{
    fn into_into_dart(self) -> FrbWrapper<FindMyFriendsClient<DefaultAnisetteProvider>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FindMyPhoneClient<DefaultAnisetteProvider>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FindMyPhoneClient<DefaultAnisetteProvider>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FindMyPhoneClient<DefaultAnisetteProvider>>>
    for FindMyPhoneClient<DefaultAnisetteProvider>
{
    fn into_into_dart(self) -> FrbWrapper<FindMyPhoneClient<DefaultAnisetteProvider>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GZipWrapper<AttachmentMeta>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GZipWrapper<AttachmentMeta>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GZipWrapper<AttachmentMeta>>>
    for GZipWrapper<AttachmentMeta>
{
    fn into_into_dart(self) -> FrbWrapper<GZipWrapper<AttachmentMeta>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GZipWrapper<ChatProto>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GZipWrapper<ChatProto>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GZipWrapper<ChatProto>>>
    for GZipWrapper<ChatProto>
{
    fn into_into_dart(self) -> FrbWrapper<GZipWrapper<ChatProto>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GZipWrapper<MessageProto>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GZipWrapper<MessageProto>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GZipWrapper<MessageProto>>>
    for GZipWrapper<MessageProto>
{
    fn into_into_dart(self) -> FrbWrapper<GZipWrapper<MessageProto>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GZipWrapper<MessageProto2>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GZipWrapper<MessageProto2>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GZipWrapper<MessageProto2>>>
    for GZipWrapper<MessageProto2>
{
    fn into_into_dart(self) -> FrbWrapper<GZipWrapper<MessageProto2>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GZipWrapper<MessageProto3>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GZipWrapper<MessageProto3>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GZipWrapper<MessageProto3>>>
    for GZipWrapper<MessageProto3>
{
    fn into_into_dart(self) -> FrbWrapper<GZipWrapper<MessageProto3>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GZipWrapper<MessageProto4>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GZipWrapper<MessageProto4>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GZipWrapper<MessageProto4>>>
    for GZipWrapper<MessageProto4>
{
    fn into_into_dart(self) -> FrbWrapper<GZipWrapper<MessageProto4>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<IDSUser> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<IDSUser> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<IDSUser>> for IDSUser {
    fn into_into_dart(self) -> FrbWrapper<IDSUser> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<JoinedOSConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<JoinedOSConfig> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<JoinedOSConfig>> for JoinedOSConfig {
    fn into_into_dart(self) -> FrbWrapper<JoinedOSConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MessageFlags> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MessageFlags> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MessageFlags>> for MessageFlags {
    fn into_into_dart(self) -> FrbWrapper<MessageFlags> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NSArray<LPIconMetadata>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<NSArray<LPIconMetadata>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NSArray<LPIconMetadata>>>
    for NSArray<LPIconMetadata>
{
    fn into_into_dart(self) -> FrbWrapper<NSArray<LPIconMetadata>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NSArray<LPImageMetadata>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<NSArray<LPImageMetadata>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NSArray<LPImageMetadata>>>
    for NSArray<LPImageMetadata>
{
    fn into_into_dart(self) -> FrbWrapper<NSArray<LPImageMetadata>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PushError> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PushError> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PushError>> for PushError {
    fn into_into_dart(self) -> FrbWrapper<PushError> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<StCollapsedValue> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<StCollapsedValue> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<StCollapsedValue>> for StCollapsedValue {
    fn into_into_dart(self) -> FrbWrapper<StCollapsedValue> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SystemTime> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SystemTime> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SystemTime>> for SystemTime {
    fn into_into_dart(self) -> FrbWrapper<SystemTime> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<VerifyBody> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<VerifyBody> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<VerifyBody>> for VerifyBody {
    fn into_into_dart(self) -> FrbWrapper<VerifyBody> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ViableBottle> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ViableBottle> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ViableBottle>> for ViableBottle {
    fn into_into_dart(self) -> FrbWrapper<ViableBottle> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Address> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.administrative_area.into_into_dart().into_dart(),
            self.0.country.into_into_dart().into_dart(),
            self.0.country_code.into_into_dart().into_dart(),
            self.0.formatted_address_lines.into_into_dart().into_dart(),
            self.0.locality.into_into_dart().into_dart(),
            self.0.state_code.into_into_dart().into_dart(),
            self.0.street_address.into_into_dart().into_dart(),
            self.0.street_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Address>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Address>>
    for crate::api::api::Address
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Address> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::AkData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.lat.into_into_dart().into_dart(),
            self.0.lng.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::AkData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::AkData>>
    for crate::api::api::AkData
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::AkData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ApsAlert> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.title.into_into_dart().into_dart(),
            self.0.body.into_into_dart().into_dart(),
            self.0.sbdy.into_into_dart().into_dart(),
            self.0.defbtn.into_into_dart().into_dart(),
            self.0.albtn.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ApsAlert>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ApsAlert>>
    for crate::api::api::ApsAlert
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ApsAlert> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ApsData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.alert.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ApsData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ApsData>>
    for crate::api::api::ApsData
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ApsData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Attachment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.a_type.into_into_dart().into_dart(),
            self.0.part.into_into_dart().into_dart(),
            self.0.uti_type.into_into_dart().into_dart(),
            self.0.mime.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
            self.0.iris.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Attachment>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Attachment>>
    for crate::api::api::Attachment
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Attachment> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::AttachmentMeta> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.mime_type.into_into_dart().into_dart(),
            self.0.start_date.into_into_dart().into_dart(),
            self.0.total_bytes.into_into_dart().into_dart(),
            self.0.transfer_state.into_into_dart().into_dart(),
            self.0.is_sticker.into_into_dart().into_dart(),
            self.0.guid.into_into_dart().into_dart(),
            self.0.hide_attachment.into_into_dart().into_dart(),
            self.0.user_info.into_into_dart().into_dart(),
            self.0.filename.into_into_dart().into_dart(),
            self.0.extras.into_into_dart().into_dart(),
            self.0.is_outgoing.into_into_dart().into_dart(),
            self.0.transfer_name.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
            self.0.uti.into_into_dart().into_dart(),
            self.0.created_date.into_into_dart().into_dart(),
            self.0.pathc.into_into_dart().into_dart(),
            self.0.md5.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::AttachmentMeta>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::AttachmentMeta>>
    for crate::api::api::AttachmentMeta
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::AttachmentMeta> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::AttachmentMetaExtra> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.preview_generation_state.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::AttachmentMetaExtra>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::AttachmentMetaExtra>>
    for crate::api::api::AttachmentMetaExtra
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::AttachmentMetaExtra> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::AttachmentType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::AttachmentType::Inline(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::AttachmentType::MMCS(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::AttachmentType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::AttachmentType>>
    for crate::api::api::AttachmentType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::AttachmentType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Balloon> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.url.into_into_dart().into_dart(),
            self.0.session.into_into_dart().into_dart(),
            self.0.layout.into_into_dart().into_dart(),
            self.0.ld_text.into_into_dart().into_dart(),
            self.0.is_live.into_into_dart().into_dart(),
            self.0.icon.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Balloon>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Balloon>>
    for crate::api::api::Balloon
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Balloon> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::BalloonLayout> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::BalloonLayout::TemplateLayout {
                image_subtitle,
                image_title,
                caption,
                secondary_subcaption,
                tertiary_subcaption,
                subcaption,
                class,
            } => [
                0.into_dart(),
                image_subtitle.into_into_dart().into_dart(),
                image_title.into_into_dart().into_dart(),
                caption.into_into_dart().into_dart(),
                secondary_subcaption.into_into_dart().into_dart(),
                tertiary_subcaption.into_into_dart().into_dart(),
                subcaption.into_into_dart().into_dart(),
                class.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::BalloonLayout>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::BalloonLayout>>
    for crate::api::api::BalloonLayout
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::BalloonLayout> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CertifiedContext> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.version.into_into_dart().into_dart(),
            self.0.receipt.into_into_dart().into_dart(),
            self.0.sender.into_into_dart().into_dart(),
            self.0.target.into_into_dart().into_dart(),
            self.0.uuid.into_into_dart().into_dart(),
            self.0.token.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CertifiedContext>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CertifiedContext>>
    for crate::api::api::CertifiedContext
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CertifiedContext> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ChangeParticipantMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.new_participants.into_into_dart().into_dart(),
            self.0.group_version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ChangeParticipantMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ChangeParticipantMessage>>
    for crate::api::api::ChangeParticipantMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ChangeParticipantMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ChatProto> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.unk1.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ChatProto>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ChatProto>>
    for crate::api::api::ChatProto
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ChatProto> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CloudAttachment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.cm.into_into_dart().into_dart(),
            self.0.lqa.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CloudAttachment>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CloudAttachment>>
    for crate::api::api::CloudAttachment
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CloudAttachment> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CloudChat> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.style.into_into_dart().into_dart(),
            self.0.is_filtered.into_into_dart().into_dart(),
            self.0.successful_query.into_into_dart().into_dart(),
            self.0.state.into_into_dart().into_dart(),
            self.0.chat_identifier.into_into_dart().into_dart(),
            self.0.group_id.into_into_dart().into_dart(),
            self.0.service_name.into_into_dart().into_dart(),
            self.0.original_group_id.into_into_dart().into_dart(),
            self.0.properties.into_into_dart().into_dart(),
            self.0.participants.into_into_dart().into_dart(),
            self.0.prop001.into_into_dart().into_dart(),
            self.0
                .last_read_message_timestamp
                .into_into_dart()
                .into_dart(),
            self.0.last_addressed_handle.into_into_dart().into_dart(),
            self.0.guid.into_into_dart().into_dart(),
            self.0.display_name.into_into_dart().into_dart(),
            self.0.proto001.into_into_dart().into_dart(),
            self.0.group_photo_guid.into_into_dart().into_dart(),
            self.0.group_photo.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CloudChat>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CloudChat>>
    for crate::api::api::CloudChat
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CloudChat> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CloudMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.utm.into_into_dart().into_dart(),
            self.0.r#type.into_into_dart().into_dart(),
            self.0.error.into_into_dart().into_dart(),
            self.0.chat_id.into_into_dart().into_dart(),
            self.0.sender.into_into_dart().into_dart(),
            self.0.time.into_into_dart().into_dart(),
            self.0.msg_proto_2.into_into_dart().into_dart(),
            self.0.destination_caller_id.into_into_dart().into_dart(),
            self.0.msg_proto.into_into_dart().into_dart(),
            self.0.flags.into_into_dart().into_dart(),
            self.0.guid.into_into_dart().into_dart(),
            self.0.msg_proto_3.into_into_dart().into_dart(),
            self.0.service.into_into_dart().into_dart(),
            self.0.msg_proto_4.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CloudMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CloudMessage>>
    for crate::api::api::CloudMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CloudMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CloudParticipant> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.uri.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CloudParticipant>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CloudParticipant>>
    for crate::api::api::CloudParticipant
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CloudParticipant> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CloudProp> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.gpufc.into_into_dart().into_dart(),
            self.0.pv.into_into_dart().into_dart(),
            self.0
                .number_of_times_respondedto_thread
                .into_into_dart()
                .into_dart(),
            self.0.should_force_to_sms.into_into_dart().into_dart(),
            self.0.last_seen_message_guid.into_into_dart().into_dart(),
            self.0.message_handshake_state.into_into_dart().into_dart(),
            self.0.legacy_group_identifiers.into_into_dart().into_dart(),
            self.0.group_photo_guid.into_into_dart().into_dart(),
            self.0.last_modification_date.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CloudProp>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CloudProp>>
    for crate::api::api::CloudProp
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CloudProp> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::CloudProp001> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.syndication_type.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::CloudProp001>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::CloudProp001>>
    for crate::api::api::CloudProp001
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::CloudProp001> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ConversationData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.participants.into_into_dart().into_dart(),
            self.0.cv_name.into_into_dart().into_dart(),
            self.0.sender_guid.into_into_dart().into_dart(),
            self.0.after_guid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ConversationData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ConversationData>>
    for crate::api::api::ConversationData
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ConversationData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::DeleteTarget> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::DeleteTarget::Chat(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::DeleteTarget::Messages(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::DeleteTarget>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::DeleteTarget>>
    for crate::api::api::DeleteTarget
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::DeleteTarget> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::DeviceInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.serial.into_into_dart().into_dart(),
            self.os_version.into_into_dart().into_dart(),
            self.encoded_data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::api::DeviceInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DeviceInfo>
    for crate::api::api::DeviceInfo
{
    fn into_into_dart(self) -> crate::api::api::DeviceInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::EditMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.tuuid.into_into_dart().into_dart(),
            self.0.edit_part.into_into_dart().into_dart(),
            self.0.new_parts.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::EditMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::EditMessage>>
    for crate::api::api::EditMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::EditMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ErrorMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.for_uuid.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
            self.0.status_str.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ErrorMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ErrorMessage>>
    for crate::api::api::ErrorMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ErrorMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ExtensionApp> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.app_id.into_into_dart().into_dart(),
            self.0.bundle_id.into_into_dart().into_dart(),
            self.0.balloon.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ExtensionApp>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ExtensionApp>>
    for crate::api::api::ExtensionApp
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ExtensionApp> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::FFIFilePackager {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::api::FFIFilePackager
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::FFIFilePackager>
    for crate::api::api::FFIFilePackager
{
    fn into_into_dart(self) -> crate::api::api::FFIFilePackager {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Follow> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.create_timestamp.into_into_dart().into_dart(),
            self.0.expires.into_into_dart().into_dart(),
            self.0.id.into_into_dart().into_dart(),
            self.0
                .invitation_accepted_handles
                .into_into_dart()
                .into_dart(),
            self.0.invitation_from_handles.into_into_dart().into_dart(),
            self.0.is_from_messages.into_into_dart().into_dart(),
            self.0.offer_id.into_into_dart().into_dart(),
            self.0.only_in_event.into_into_dart().into_dart(),
            self.0.person_id_hash.into_into_dart().into_dart(),
            self.0.secure_locations_capable.into_into_dart().into_dart(),
            self.0
                .shallow_or_live_secure_locations_capable
                .into_into_dart()
                .into_dart(),
            self.0.source.into_into_dart().into_dart(),
            self.0.tk_permission.into_into_dart().into_dart(),
            self.0.update_timestamp.into_into_dart().into_dart(),
            self.0
                .fallback_to_legacy_allowed
                .into_into_dart()
                .into_dart(),
            self.0.opted_not_to_share.into_into_dart().into_dart(),
            self.0.last_location.into_into_dart().into_dart(),
            self.0.locate_in_progress.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Follow>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Follow>>
    for crate::api::api::Follow
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Follow> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::FoundDevice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.device_model.into_into_dart().into_dart(),
            self.0.low_power_mode.into_into_dart().into_dart(),
            self.0.passcode_length.into_into_dart().into_dart(),
            self.0.id.into_into_dart().into_dart(),
            self.0.battery_status.into_into_dart().into_dart(),
            self.0.lost_mode_capable.into_into_dart().into_dart(),
            self.0.battery_level.into_into_dart().into_dart(),
            self.0.location_enabled.into_into_dart().into_dart(),
            self.0.is_considered_accessory.into_into_dart().into_dart(),
            self.0.location.into_into_dart().into_dart(),
            self.0.model_display_name.into_into_dart().into_dart(),
            self.0.device_color.into_into_dart().into_dart(),
            self.0.activation_locked.into_into_dart().into_dart(),
            self.0.rm2_state.into_into_dart().into_dart(),
            self.0.loc_found_enabled.into_into_dart().into_dart(),
            self.0.nwd.into_into_dart().into_dart(),
            self.0.device_status.into_into_dart().into_dart(),
            self.0.fmly_share.into_into_dart().into_dart(),
            self.0.features.into_into_dart().into_dart(),
            self.0.this_device.into_into_dart().into_dart(),
            self.0.lost_mode_enabled.into_into_dart().into_dart(),
            self.0.device_display_name.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
            self.0.can_wipe_after_lock.into_into_dart().into_dart(),
            self.0.is_mac.into_into_dart().into_dart(),
            self.0.raw_device_model.into_into_dart().into_dart(),
            self.0.ba_uuid.into_into_dart().into_dart(),
            self.0.device_discovery_id.into_into_dart().into_dart(),
            self.0.scd.into_into_dart().into_dart(),
            self.0.location_capable.into_into_dart().into_dart(),
            self.0.wipe_in_progress.into_into_dart().into_dart(),
            self.0.dark_wake.into_into_dart().into_dart(),
            self.0.device_with_you.into_into_dart().into_dart(),
            self.0.max_msg_char.into_into_dart().into_dart(),
            self.0.device_class.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::FoundDevice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::FoundDevice>>
    for crate::api::api::FoundDevice
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::FoundDevice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::FTMember> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.nickname.into_into_dart().into_dart(),
            self.0.handle.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::FTMember>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::FTMember>>
    for crate::api::api::FTMember
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::FTMember> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::FTMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::FTMessage::LetMeInRequest(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::FTMessage::LinkChanged { guid } => {
                [1.into_dart(), guid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::FTMessage::JoinEvent {
                guid,
                participant,
                handle,
                ring,
            } => [
                2.into_dart(),
                guid.into_into_dart().into_dart(),
                participant.into_into_dart().into_dart(),
                handle.into_into_dart().into_dart(),
                ring.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::FTMessage::AddMembers {
                guid,
                members,
                ring,
            } => [
                3.into_dart(),
                guid.into_into_dart().into_dart(),
                members.into_into_dart().into_dart(),
                ring.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::FTMessage::RemoveMembers { guid, members } => [
                4.into_dart(),
                guid.into_into_dart().into_dart(),
                members.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::FTMessage::LeaveEvent {
                guid,
                participant,
                handle,
            } => [
                5.into_dart(),
                guid.into_into_dart().into_dart(),
                participant.into_into_dart().into_dart(),
                handle.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::FTMessage::Ring { guid } => {
                [6.into_dart(), guid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::FTMessage::Decline { guid } => {
                [7.into_dart(), guid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::FTMessage::RespondedElsewhere { guid } => {
                [8.into_dart(), guid.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::FTMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::FTMessage>>
    for crate::api::api::FTMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::FTMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::FTMode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::FTMode::Outgoing => 0.into_dart(),
            crate::api::api::FTMode::Incoming => 1.into_dart(),
            crate::api::api::FTMode::Missed => 2.into_dart(),
            crate::api::api::FTMode::MissedOutgoing => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::FTMode>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::FTMode>>
    for crate::api::api::FTMode
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::FTMode> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::FTParticipant> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.token.into_into_dart().into_dart(),
            self.0.handle.into_into_dart().into_dart(),
            self.0.participant_id.into_into_dart().into_dart(),
            self.0.last_join_date.into_into_dart().into_dart(),
            self.0.active.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::FTParticipant>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::FTParticipant>>
    for crate::api::api::FTParticipant
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::FTParticipant> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::FTSession> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.group_id.into_into_dart().into_dart(),
            self.0.my_handles.into_into_dart().into_dart(),
            self.0.participants.into_into_dart().into_dart(),
            self.0.link.into_into_dart().into_dart(),
            self.0.members.into_into_dart().into_dart(),
            self.0.report_id.into_into_dart().into_dart(),
            self.0.start_time.into_into_dart().into_dart(),
            self.0.last_rekey.into_into_dart().into_dart(),
            self.0.is_propped.into_into_dart().into_dart(),
            self.0.is_ringing_inaccurate.into_into_dart().into_dart(),
            self.0.mode.into_into_dart().into_dart(),
            self.0.recent_member_adds.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::FTSession>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::FTSession>>
    for crate::api::api::FTSession
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::FTSession> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::HwExtra {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.version.into_into_dart().into_dart(),
            self.protocol_version.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
            self.icloud_ua.into_into_dart().into_dart(),
            self.aoskit_version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::api::HwExtra {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::HwExtra> for crate::api::api::HwExtra {
    fn into_into_dart(self) -> crate::api::api::HwExtra {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IMessageNameRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.first.into_into_dart().into_dart(),
            self.0.last.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IMessageNameRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IMessageNameRecord>>
    for crate::api::api::IMessageNameRecord
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IMessageNameRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IMessageNicknameRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.image.into_into_dart().into_dart(),
            self.0.poster.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IMessageNicknameRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IMessageNicknameRecord>>
    for crate::api::api::IMessageNicknameRecord
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IMessageNicknameRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IMessagePosterRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.low_res_poster.into_into_dart().into_dart(),
            self.0.package.into_into_dart().into_dart(),
            self.0.meta.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IMessagePosterRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IMessagePosterRecord>>
    for crate::api::api::IMessagePosterRecord
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IMessagePosterRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IconChangeMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.file.into_into_dart().into_dart(),
            self.0.group_version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IconChangeMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IconChangeMessage>>
    for crate::api::api::IconChangeMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IconChangeMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IdmsCircleMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.step.into_into_dart().into_dart(),
            self.0.atxnid.into_into_dart().into_dart(),
            self.0.pake.into_into_dart().into_dart(),
            self.0.ec.into_into_dart().into_dart(),
            self.0.idmsdata.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IdmsCircleMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IdmsCircleMessage>>
    for crate::api::api::IdmsCircleMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IdmsCircleMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IdmsMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::IdmsMessage::RequestedSignIn(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::IdmsMessage::TeardownSignIn(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::IdmsMessage::CircleRequest(field0, field1) => [
                2.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IdmsMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IdmsMessage>>
    for crate::api::api::IdmsMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IdmsMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IdmsRequestedSignIn> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.aps.into_into_dart().into_dart(),
            self.0.txnid.into_into_dart().into_dart(),
            self.0.akdata.into_into_dart().into_dart(),
            self.0.adsid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IdmsRequestedSignIn>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IdmsRequestedSignIn>>
    for crate::api::api::IdmsRequestedSignIn
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IdmsRequestedSignIn> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::IndexedMessagePart> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.part.into_into_dart().into_dart(),
            self.0.idx.into_into_dart().into_dart(),
            self.0.ext.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::IndexedMessagePart>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::IndexedMessagePart>>
    for crate::api::api::IndexedMessagePart
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::IndexedMessagePart> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::LetMeInRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.shared_secret.into_into_dart().into_dart(),
            self.0.pseud.into_into_dart().into_dart(),
            self.0.requestor.into_into_dart().into_dart(),
            self.0.nickname.into_into_dart().into_dart(),
            self.0.token.into_into_dart().into_dart(),
            self.0.delegation_uuid.into_into_dart().into_dart(),
            self.0.usage.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::LetMeInRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::LetMeInRequest>>
    for crate::api::api::LetMeInRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::LetMeInRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::LinkMeta> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.data.into_into_dart().into_dart(),
            self.0.attachments.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::LinkMeta>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::LinkMeta>>
    for crate::api::api::LinkMeta
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::LinkMeta> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Location> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.altitude.into_into_dart().into_dart(),
            self.0.floor_level.into_into_dart().into_dart(),
            self.0.horizontal_accuracy.into_into_dart().into_dart(),
            self.0.is_inaccurate.into_into_dart().into_dart(),
            self.0.latitude.into_into_dart().into_dart(),
            self.0.location_id.into_into_dart().into_dart(),
            self.0.location_timestamp.into_into_dart().into_dart(),
            self.0.longitude.into_into_dart().into_dart(),
            self.0.secure_location_ts.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
            self.0.vertical_accuracy.into_into_dart().into_dart(),
            self.0.position_type.into_into_dart().into_dart(),
            self.0.is_old.into_into_dart().into_dart(),
            self.0.location_finished.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Location>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Location>>
    for crate::api::api::Location
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Location> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::LoginState> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::LoginState::LoggedIn => [0.into_dart()].into_dart(),
            crate::api::api::LoginState::NeedsDevice2FA => [1.into_dart()].into_dart(),
            crate::api::api::LoginState::Needs2FAVerification => [2.into_dart()].into_dart(),
            crate::api::api::LoginState::NeedsSMS2FA => [3.into_dart()].into_dart(),
            crate::api::api::LoginState::NeedsSMS2FAVerification(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::LoginState::NeedsExtraStep(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::LoginState::NeedsLogin => [6.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::LoginState>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::LoginState>>
    for crate::api::api::LoginState
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::LoginState> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::LPIconMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.url.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::LPIconMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::LPIconMetadata>>
    for crate::api::api::LPIconMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::LPIconMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::LPImageMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.size.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::LPImageMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::LPImageMetadata>>
    for crate::api::api::LPImageMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::LPImageMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::LPLinkMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.image_metadata.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
            self.0.icon_metadata.into_into_dart().into_dart(),
            self.0.original_url.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.title.into_into_dart().into_dart(),
            self.0.summary.into_into_dart().into_dart(),
            self.0.image.into_into_dart().into_dart(),
            self.0.icon.into_into_dart().into_dart(),
            self.0.images.into_into_dart().into_dart(),
            self.0.icons.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::LPLinkMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::LPLinkMetadata>>
    for crate::api::api::LPLinkMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::LPLinkMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MemojiData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .background_color_description
                .into_into_dart()
                .into_dart(),
            self.0.avatar_record_data.into_into_dart().into_dart(),
            self.0.avatar_pose_data.into_into_dart().into_dart(),
            self.0.has_body.into_into_dart().into_dart(),
            self.0.avatar_image_data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MemojiData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MemojiData>>
    for crate::api::api::MemojiData
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MemojiData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Message> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::Message::Message(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::RenameMessage(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::ChangeParticipants(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::React(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::Delivered => [4.into_dart()].into_dart(),
            crate::api::api::Message::Read => [5.into_dart()].into_dart(),
            crate::api::api::Message::Typing(field0, field1) => [
                6.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::Message::Unsend(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::Edit(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::IconChange(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::EnableSmsActivation(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::MessageReadOnDevice => [11.into_dart()].into_dart(),
            crate::api::api::Message::SmsConfirmSent(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::MarkUnread => [13.into_dart()].into_dart(),
            crate::api::api::Message::PeerCacheInvalidate => [14.into_dart()].into_dart(),
            crate::api::api::Message::UpdateExtension(field0) => {
                [15.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::Error(field0) => {
                [16.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::MoveToRecycleBin(field0) => {
                [17.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::RecoverChat(field0) => {
                [18.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::PermanentDelete(field0) => {
                [19.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::Unschedule => [20.into_dart()].into_dart(),
            crate::api::api::Message::UpdateProfile(field0) => {
                [21.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::UpdateProfileSharing(field0) => {
                [22.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::ShareProfile(field0) => {
                [23.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Message::NotifyAnyways => [24.into_dart()].into_dart(),
            crate::api::api::Message::SetTranscriptBackground(field0) => {
                [25.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Message>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Message>>
    for crate::api::api::Message
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Message> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageEdit> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.t.into_into_dart().into_dart(),
            self.0.d.into_into_dart().into_dart(),
            self.0.bcg.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageEdit>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageEdit>>
    for crate::api::api::MessageEdit
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageEdit> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageEditRange> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.lo.into_into_dart().into_dart(),
            self.0.le.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageEditRange>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageEditRange>>
    for crate::api::api::MessageEditRange
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageEditRange> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageInst> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.sender.into_into_dart().into_dart(),
            self.0.conversation.into_into_dart().into_dart(),
            self.0.message.into_into_dart().into_dart(),
            self.0.sent_timestamp.into_into_dart().into_dart(),
            self.0.target.into_into_dart().into_dart(),
            self.0.send_delivered.into_into_dart().into_dart(),
            self.0.verification_failed.into_into_dart().into_dart(),
            self.0.certified_context.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageInst>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageInst>>
    for crate::api::api::MessageInst
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageInst> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessagePart> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::MessagePart::Text(field0, field1) => [
                0.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::MessagePart::Attachment(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::MessagePart::Mention(field0, field1) => [
                2.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::MessagePart::Object(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessagePart>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessagePart>>
    for crate::api::api::MessagePart
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessagePart> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageParts> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageParts>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageParts>>
    for crate::api::api::MessageParts
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageParts> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageProto> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.unk1.into_into_dart().into_dart(),
            self.0.group_title.into_into_dart().into_dart(),
            self.0.text.into_into_dart().into_dart(),
            self.0.attributed_body.into_into_dart().into_dart(),
            self.0.balloon_bundle_id.into_into_dart().into_dart(),
            self.0.payload_data.into_into_dart().into_dart(),
            self.0.message_summary_info.into_into_dart().into_dart(),
            self.0.effect.into_into_dart().into_dart(),
            self.0.date_read.into_into_dart().into_dart(),
            self.0.unk10.into_into_dart().into_dart(),
            self.0.unk11.into_into_dart().into_dart(),
            self.0.date_delivered.into_into_dart().into_dart(),
            self.0.unk14.into_into_dart().into_dart(),
            self.0.associated_message_type.into_into_dart().into_dart(),
            self.0.associated_message_guid.into_into_dart().into_dart(),
            self.0
                .associated_message_range_location
                .into_into_dart()
                .into_dart(),
            self.0
                .associated_message_range_length
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageProto>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageProto>>
    for crate::api::api::MessageProto
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageProto> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageProto2> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.reply.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageProto2>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageProto2>>
    for crate::api::api::MessageProto2
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageProto2> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageProto3> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.unk2.into_into_dart().into_dart(),
            self.0.unk3.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageProto3>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageProto3>>
    for crate::api::api::MessageProto3
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageProto3> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageProto4> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.associated_message_emoji.into_into_dart().into_dart(),
            self.0.service.into_into_dart().into_dart(),
            self.0.schedule_type.into_into_dart().into_dart(),
            self.0.schedule_state.into_into_dart().into_dart(),
            self.0.group_id.into_into_dart().into_dart(),
            self.0
                .sent_or_received_off_grid
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageProto4>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageProto4>>
    for crate::api::api::MessageProto4
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageProto4> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageSummaryInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ams.into_into_dart().into_dart(),
            self.0.ampt.into_into_dart().into_dart(),
            self.0.amc.into_into_dart().into_dart(),
            self.0.amb.into_into_dart().into_dart(),
            self.0.amd.into_into_dart().into_dart(),
            self.0.ec.into_into_dart().into_dart(),
            self.0.ep.into_into_dart().into_dart(),
            self.0.otr.into_into_dart().into_dart(),
            self.0.ust.into_into_dart().into_dart(),
            self.0.rp.into_into_dart().into_dart(),
            self.0.hbr.into_into_dart().into_dart(),
            self.0.oui.into_into_dart().into_dart(),
            self.0.osn.into_into_dart().into_dart(),
            self.0.euh.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageSummaryInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageSummaryInfo>>
    for crate::api::api::MessageSummaryInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageSummaryInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageTarget> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::MessageTarget::Token(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::MessageTarget::Uuid(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageTarget>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageTarget>>
    for crate::api::api::MessageTarget
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageTarget> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MessageType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::MessageType::IMessage => [0.into_dart()].into_dart(),
            crate::api::api::MessageType::SMS {
                is_phone,
                using_number,
                from_handle,
            } => [
                1.into_dart(),
                is_phone.into_into_dart().into_dart(),
                using_number.into_into_dart().into_dart(),
                from_handle.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MessageType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MessageType>>
    for crate::api::api::MessageType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MessageType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MMCSAttachmentMeta> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.mmcs_signature_hex.into_into_dart().into_dart(),
            self.0.file_size.into_into_dart().into_dart(),
            self.0.decryption_key.into_into_dart().into_dart(),
            self.0.uti_type.into_into_dart().into_dart(),
            self.0.mmcs_owner.into_into_dart().into_dart(),
            self.0.mime_type.into_into_dart().into_dart(),
            self.0.mmcs_url.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MMCSAttachmentMeta>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MMCSAttachmentMeta>>
    for crate::api::api::MMCSAttachmentMeta
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MMCSAttachmentMeta> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MMCSFile> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.signature.into_into_dart().into_dart(),
            self.0.object.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.key.into_into_dart().into_dart(),
            self.0.size.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MMCSFile>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MMCSFile>>
    for crate::api::api::MMCSFile
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MMCSFile> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::MMCSTransferProgress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.prog.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.file.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::api::MMCSTransferProgress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::MMCSTransferProgress>
    for crate::api::api::MMCSTransferProgress
{
    fn into_into_dart(self) -> crate::api::api::MMCSTransferProgress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MonogramData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .top_background_color_description
                .into_into_dart()
                .into_dart(),
            self.0
                .background_color_description
                .into_into_dart()
                .into_dart(),
            self.0.initials.into_into_dart().into_dart(),
            self.0
                .monogram_supported_for_name
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MonogramData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MonogramData>>
    for crate::api::api::MonogramData
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MonogramData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::MoveToRecycleBinMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.target.into_into_dart().into_dart(),
            self.0.recoverable_delete_date.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::MoveToRecycleBinMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::MoveToRecycleBinMessage>>
    for crate::api::api::MoveToRecycleBinMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::MoveToRecycleBinMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::MyAsyncRuntime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::api::MyAsyncRuntime
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::MyAsyncRuntime>
    for crate::api::api::MyAsyncRuntime
{
    fn into_into_dart(self) -> crate::api::api::MyAsyncRuntime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NormalMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.parts.into_into_dart().into_dart(),
            self.0.effect.into_into_dart().into_dart(),
            self.0.reply_guid.into_into_dart().into_dart(),
            self.0.reply_part.into_into_dart().into_dart(),
            self.0.service.into_into_dart().into_dart(),
            self.0.subject.into_into_dart().into_dart(),
            self.0.app.into_into_dart().into_dart(),
            self.0.link_meta.into_into_dart().into_dart(),
            self.0.voice.into_into_dart().into_dart(),
            self.0.scheduled.into_into_dart().into_dart(),
            self.0.embedded_profile.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NormalMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NormalMessage>>
    for crate::api::api::NormalMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NormalMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NSAttributedString> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.text.into_into_dart().into_dart(),
            self.0.ranges.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NSAttributedString>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NSAttributedString>>
    for crate::api::api::NSAttributedString
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NSAttributedString> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NSDictionaryClass> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::NSDictionaryClass::NSDictionary => 0.into_dart(),
            crate::api::api::NSDictionaryClass::NSMutableDictionary => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NSDictionaryClass>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NSDictionaryClass>>
    for crate::api::api::NSDictionaryClass
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NSDictionaryClass> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NSDictionaryTypedCoder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NSDictionaryTypedCoder>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NSDictionaryTypedCoder>>
    for crate::api::api::NSDictionaryTypedCoder
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NSDictionaryTypedCoder> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NSNumber> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NSNumber>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NSNumber>>
    for crate::api::api::NSNumber
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NSNumber> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NSString> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NSString>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NSString>>
    for crate::api::api::NSString
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NSString> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NSURL> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.base.into_into_dart().into_dart(),
            self.0.relative.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NSURL>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NSURL>>
    for crate::api::api::NSURL
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NSURL> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::NumOrString> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::NumOrString::Num(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::NumOrString::String(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::NumOrString>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::NumOrString>>
    for crate::api::api::NumOrString
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::NumOrString> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::OperatedChat> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.participants.into_into_dart().into_dart(),
            self.0.group_id.into_into_dart().into_dart(),
            self.0.guid.into_into_dart().into_dart(),
            self.0.delete_incoming_messages.into_into_dart().into_dart(),
            self.0.was_reported_as_junk.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::OperatedChat>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::OperatedChat>>
    for crate::api::api::OperatedChat
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::OperatedChat> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PartExtension> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::PartExtension::Sticker {
                msg_width,
                rotation,
                sai,
                scale,
                update,
                sli,
                normalized_x,
                normalized_y,
                version,
                hash,
                safi,
                effect_type,
                sticker_id,
            } => [
                0.into_dart(),
                msg_width.into_into_dart().into_dart(),
                rotation.into_into_dart().into_dart(),
                sai.into_into_dart().into_dart(),
                scale.into_into_dart().into_dart(),
                update.into_into_dart().into_dart(),
                sli.into_into_dart().into_dart(),
                normalized_x.into_into_dart().into_dart(),
                normalized_y.into_into_dart().into_dart(),
                version.into_into_dart().into_dart(),
                hash.into_into_dart().into_dart(),
                safi.into_into_dart().into_dart(),
                effect_type.into_into_dart().into_dart(),
                sticker_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PartExtension>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PartExtension>>
    for crate::api::api::PartExtension
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PartExtension> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PermanentDeleteMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.target.into_into_dart().into_dart(),
            self.0.is_scheduled.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PermanentDeleteMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PermanentDeleteMessage>>
    for crate::api::api::PermanentDeleteMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PermanentDeleteMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PhotoPosterContents> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.version.into_into_dart().into_dart(),
            self.0.layers.into_into_dart().into_dart(),
            self.0.properties.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PhotoPosterContents>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PhotoPosterContents>>
    for crate::api::api::PhotoPosterContents
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PhotoPosterContents> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PhotoPosterContentsFrame> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.width.into_into_dart().into_dart(),
            self.0.height.into_into_dart().into_dart(),
            self.0.x.into_into_dart().into_dart(),
            self.0.y.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PhotoPosterContentsFrame>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PhotoPosterContentsFrame>>
    for crate::api::api::PhotoPosterContentsFrame
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PhotoPosterContentsFrame> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PhotoPosterContentsSize> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.width.into_into_dart().into_dart(),
            self.0.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PhotoPosterContentsSize>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PhotoPosterContentsSize>>
    for crate::api::api::PhotoPosterContentsSize
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PhotoPosterContentsSize> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PhotoPosterLayer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.frame.into_into_dart().into_dart(),
            self.0.filename.into_into_dart().into_dart(),
            self.0.z_position.into_into_dart().into_dart(),
            self.0.identifier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PhotoPosterLayer>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PhotoPosterLayer>>
    for crate::api::api::PhotoPosterLayer
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PhotoPosterLayer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PhotoPosterLayout> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.clock_intersection.into_into_dart().into_dart(),
            self.0.device_resolution.into_into_dart().into_dart(),
            self.0.visible_frame.into_into_dart().into_dart(),
            self.0.time_frame.into_into_dart().into_dart(),
            self.0.clock_layer_order.into_into_dart().into_dart(),
            self.0.has_top_edge_contact.into_into_dart().into_dart(),
            self.0.inactive_frame.into_into_dart().into_dart(),
            self.0.image_size.into_into_dart().into_dart(),
            self.0.parallax_padding.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PhotoPosterLayout>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PhotoPosterLayout>>
    for crate::api::api::PhotoPosterLayout
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PhotoPosterLayout> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PhotoPosterProperties> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.portrait_layout.into_into_dart().into_dart(),
            self.0.settling_effect_enabled.into_into_dart().into_dart(),
            self.0.depth_enabled.into_into_dart().into_dart(),
            self.0.clock_area_luminance.into_into_dart().into_dart(),
            self.0.parallax_disabled.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PhotoPosterProperties>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PhotoPosterProperties>>
    for crate::api::api::PhotoPosterProperties
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PhotoPosterProperties> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::PollResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::api::PollResult::Stop => [0.into_dart()].into_dart(),
            crate::api::api::PollResult::Cont(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::api::PollResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::PollResult>
    for crate::api::api::PollResult
{
    fn into_into_dart(self) -> crate::api::api::PollResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PosterAsset> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.contents.into_into_dart().into_dart(),
            self.0.files.into_into_dart().into_dart(),
            self.0.uuid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PosterAsset>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PosterAsset>>
    for crate::api::api::PosterAsset
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PosterAsset> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PosterColor> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.alpha.into_into_dart().into_dart(),
            self.0.blue.into_into_dart().into_dart(),
            self.0.green.into_into_dart().into_dart(),
            self.0.red.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PosterColor>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PosterColor>>
    for crate::api::api::PosterColor
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PosterColor> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PosterRole> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::PosterRole::PRPosterRoleBackdrop => 0.into_dart(),
            crate::api::api::PosterRole::PRPosterRoleIncomingCall => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PosterRole>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PosterRole>>
    for crate::api::api::PosterRole
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PosterRole> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PosterType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::PosterType::Photo { assets } => {
                [0.into_dart(), assets.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PosterType::Monogram { data, background } => [
                1.into_dart(),
                data.into_into_dart().into_dart(),
                background.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::PosterType::Memoji { data, background } => [
                2.into_dart(),
                data.into_into_dart().into_dart(),
                background.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::PosterType::TranscriptDynamic { data } => {
                [3.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PosterType::TranscriptGradient { colors } => {
                [4.into_dart(), colors.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PosterType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PosterType>>
    for crate::api::api::PosterType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PosterType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PRPosterColor> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.preferred_style.into_into_dart().into_dart(),
            self.0.identifier.into_into_dart().into_dart(),
            self.0.suggested.into_into_dart().into_dart(),
            self.0.color.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PRPosterColor>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PRPosterColor>>
    for crate::api::api::PRPosterColor
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PRPosterColor> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PRPosterContentMaterialStyle> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::PRPosterContentMaterialStyle::PRPosterContentDiscreteColorsStyle {
                variation,
                colors,
                vibrant,
                supports_variation,
                needs_to_resolve_variation,
            } => [
                0.into_dart(),
                variation.into_into_dart().into_dart(),
                colors.into_into_dart().into_dart(),
                vibrant.into_into_dart().into_dart(),
                supports_variation.into_into_dart().into_dart(),
                needs_to_resolve_variation.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::PRPosterContentMaterialStyle::PRPosterContentVibrantMaterialStyle => {
                [1.into_dart()].into_dart()
            }
            crate::api::api::PRPosterContentMaterialStyle::PRPosterContentGradientStyle {
                gradient_type,
                colors,
                start_point,
                locations,
                end_point,
            } => [
                2.into_dart(),
                gradient_type.into_into_dart().into_dart(),
                colors.into_into_dart().into_dart(),
                start_point.into_into_dart().into_dart(),
                locations.into_into_dart().into_dart(),
                end_point.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PRPosterContentMaterialStyle>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PRPosterContentMaterialStyle>>
    for crate::api::api::PRPosterContentMaterialStyle
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PRPosterContentMaterialStyle> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::api::PRPosterSystemTimeFontConfiguration>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.is_system_item.into_into_dart().into_dart(),
            self.0.time_font_identifier.into_into_dart().into_dart(),
            self.0.weight.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PRPosterSystemTimeFontConfiguration>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::api::PRPosterSystemTimeFontConfiguration>,
    > for crate::api::api::PRPosterSystemTimeFontConfiguration
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PRPosterSystemTimeFontConfiguration> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::api::PRPosterTitleStyleConfiguration>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.alternate_date_enabled.into_into_dart().into_dart(),
            self.0.contents_luminence.into_into_dart().into_dart(),
            self.0.group_name.into_into_dart().into_dart(),
            self.0
                .preferred_title_alignment
                .into_into_dart()
                .into_dart(),
            self.0.preferred_title_layout.into_into_dart().into_dart(),
            self.0.time_font_configuration.into_into_dart().into_dart(),
            self.0.time_numbering_system.into_into_dart().into_dart(),
            self.0.title_color.into_into_dart().into_dart(),
            self.0.title_content_style.into_into_dart().into_dart(),
            self.0.user_configured.into_into_dart().into_dart(),
            self.0.title_style.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PRPosterTitleStyleConfiguration>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PRPosterTitleStyleConfiguration>>
    for crate::api::api::PRPosterTitleStyleConfiguration
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PRPosterTitleStyleConfiguration> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::PrivateDeviceInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.uuid.into_into_dart().into_dart(),
            self.0.device_name.into_into_dart().into_dart(),
            self.0.token.into_into_dart().into_dart(),
            self.0.is_hsa_trusted.into_into_dart().into_dart(),
            self.0.identites.into_into_dart().into_dart(),
            self.0.sub_services.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::PrivateDeviceInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::PrivateDeviceInfo>>
    for crate::api::api::PrivateDeviceInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::PrivateDeviceInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::PushMessage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::api::PushMessage::IMessage(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::SendConfirm { uuid, error } => [
                1.into_dart(),
                uuid.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::PushMessage::RegistrationState(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::NewPhotostream(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::FaceTime(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::StatusUpdate(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::Idms(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::TwoFaAuthEvent(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::PushMessage::CircleFinishEvent => [8.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::api::PushMessage {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::PushMessage>
    for crate::api::api::PushMessage
{
    fn into_into_dart(self) -> crate::api::api::PushMessage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::QuotaInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.total_bytes.into_into_dart().into_dart(),
            self.available_bytes.into_into_dart().into_dart(),
            self.messages_bytes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::api::QuotaInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::QuotaInfo> for crate::api::api::QuotaInfo {
    fn into_into_dart(self) -> crate::api::api::QuotaInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ReactMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.to_uuid.into_into_dart().into_dart(),
            self.0.to_part.into_into_dart().into_dart(),
            self.0.reaction.into_into_dart().into_dart(),
            self.0.to_text.into_into_dart().into_dart(),
            self.0.embedded_profile.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ReactMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ReactMessage>>
    for crate::api::api::ReactMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ReactMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ReactMessageType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::ReactMessageType::React { reaction, enable } => [
                0.into_dart(),
                reaction.into_into_dart().into_dart(),
                enable.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::ReactMessageType::Extension {
                spec,
                body,
                is_meta,
            } => [
                1.into_dart(),
                spec.into_into_dart().into_dart(),
                body.into_into_dart().into_dart(),
                is_meta.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ReactMessageType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ReactMessageType>>
    for crate::api::api::ReactMessageType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ReactMessageType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::Reaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::Reaction::Heart => [0.into_dart()].into_dart(),
            crate::api::api::Reaction::Like => [1.into_dart()].into_dart(),
            crate::api::api::Reaction::Dislike => [2.into_dart()].into_dart(),
            crate::api::api::Reaction::Laugh => [3.into_dart()].into_dart(),
            crate::api::api::Reaction::Emphasize => [4.into_dart()].into_dart(),
            crate::api::api::Reaction::Question => [5.into_dart()].into_dart(),
            crate::api::api::Reaction::Emoji(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::Reaction::Sticker { spec, body } => [
                7.into_dart(),
                spec.into_into_dart().into_dart(),
                body.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::Reaction>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::Reaction>>
    for crate::api::api::Reaction
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::Reaction> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::RegisterState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::api::RegisterState::Registered { next_s } => {
                [0.into_dart(), next_s.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::RegisterState::Registering => [1.into_dart()].into_dart(),
            crate::api::api::RegisterState::Failed { retry_wait, error } => [
                2.into_dart(),
                retry_wait.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::api::RegisterState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::RegisterState>
    for crate::api::api::RegisterState
{
    fn into_into_dart(self) -> crate::api::api::RegisterState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::RegistrationPhase {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::WantsOSConfig => 0.into_dart(),
            Self::WantsRegister => 1.into_dart(),
            Self::Registered => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::api::RegistrationPhase
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::RegistrationPhase>
    for crate::api::api::RegistrationPhase
{
    fn into_into_dart(self) -> crate::api::api::RegistrationPhase {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::RenameMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.new_name.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::RenameMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::RenameMessage>>
    for crate::api::api::RenameMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::RenameMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ReportMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.guid.into_into_dart().into_dart(),
            self.0.sender.into_into_dart().into_dart(),
            self.0.conversation_size.into_into_dart().into_dart(),
            self.0.parts.into_into_dart().into_dart(),
            self.0.time_of_message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ReportMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ReportMessage>>
    for crate::api::api::ReportMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ReportMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::api::RichLinkImageAttachmentSubstitute>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.mime_type.into_into_dart().into_dart(),
            self.0
                .rich_link_image_attachment_substitute_index
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::RichLinkImageAttachmentSubstitute>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::api::RichLinkImageAttachmentSubstitute>,
    > for crate::api::api::RichLinkImageAttachmentSubstitute
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::RichLinkImageAttachmentSubstitute> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ScheduleMode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ms.into_into_dart().into_dart(),
            self.0.schedule.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ScheduleMode>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ScheduleMode>>
    for crate::api::api::ScheduleMode
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ScheduleMode> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SetTranscriptBackgroundMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::SetTranscriptBackgroundMessage::Remove {
                aid,
                bid,
                chat_id,
                remove,
            } => [
                0.into_dart(),
                aid.into_into_dart().into_dart(),
                bid.into_into_dart().into_dart(),
                chat_id.into_into_dart().into_dart(),
                remove.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::SetTranscriptBackgroundMessage::Set {
                aid,
                bid,
                chat_id,
                object_id,
                payload_version,
                background_id,
                url,
                signature,
                key,
                file_size,
            } => [
                1.into_dart(),
                aid.into_into_dart().into_dart(),
                bid.into_into_dart().into_dart(),
                chat_id.into_into_dart().into_dart(),
                object_id.into_into_dart().into_dart(),
                payload_version.into_into_dart().into_dart(),
                background_id.into_into_dart().into_dart(),
                url.into_into_dart().into_dart(),
                signature.into_into_dart().into_dart(),
                key.into_into_dart().into_dart(),
                file_size.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SetTranscriptBackgroundMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SetTranscriptBackgroundMessage>>
    for crate::api::api::SetTranscriptBackgroundMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SetTranscriptBackgroundMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::ShareProfileMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .cloud_kit_decryption_record_key
                .into_into_dart()
                .into_dart(),
            self.0.cloud_kit_record_key.into_into_dart().into_dart(),
            self.0.poster.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::ShareProfileMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::ShareProfileMessage>>
    for crate::api::api::ShareProfileMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::ShareProfileMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SharedAlbum> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.fullname.into_into_dart().into_dart(),
            self.0.email.into_into_dart().into_dart(),
            self.0.albumguid.into_into_dart().into_dart(),
            self.0.sharingtype.into_into_dart().into_dart(),
            self.0.subscriptiondate.into_into_dart().into_dart(),
            self.0.albumlocation.into_into_dart().into_dart(),
            self.0.assets.into_into_dart().into_dart(),
            self.0.delete.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SharedAlbum>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SharedAlbum>>
    for crate::api::api::SharedAlbum
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SharedAlbum> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SharedPoster> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.low_res_wallpaper_tag.into_into_dart().into_dart(),
            self.0.wallpaper_tag.into_into_dart().into_dart(),
            self.0.message_tag.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SharedPoster>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SharedPoster>>
    for crate::api::api::SharedPoster
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SharedPoster> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SimplifiedIncomingCallPoster> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.poster.into_into_dart().into_dart(),
            self.0.text_metadata.into_into_dart().into_dart(),
            self.0.low_res.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SimplifiedIncomingCallPoster>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SimplifiedIncomingCallPoster>>
    for crate::api::api::SimplifiedIncomingCallPoster
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SimplifiedIncomingCallPoster> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SimplifiedPoster> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.title_configuration.into_into_dart().into_dart(),
            self.0.r#type.into_into_dart().into_dart(),
            self.0.role.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SimplifiedPoster>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SimplifiedPoster>>
    for crate::api::api::SimplifiedPoster
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SimplifiedPoster> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SimplifiedTranscriptPoster> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.watch.into_into_dart().into_dart(),
            self.0.poster.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SimplifiedTranscriptPoster>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SimplifiedTranscriptPoster>>
    for crate::api::api::SimplifiedTranscriptPoster
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SimplifiedTranscriptPoster> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::StatusKitMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::StatusKitMessage::StatusChanged {
                user,
                mode,
                allowed,
            } => [
                0.into_dart(),
                user.into_into_dart().into_dart(),
                mode.into_into_dart().into_dart(),
                allowed.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::StatusKitMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::StatusKitMessage>>
    for crate::api::api::StatusKitMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::StatusKitMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::StatusKitPersonalConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.allowed_modes.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::StatusKitPersonalConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::StatusKitPersonalConfig>>
    for crate::api::api::StatusKitPersonalConfig
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::StatusKitPersonalConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SupportAction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.url.into_into_dart().into_dart(),
            self.0.button.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SupportAction>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SupportAction>>
    for crate::api::api::SupportAction
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SupportAction> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SupportAlert> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.title.into_into_dart().into_dart(),
            self.0.body.into_into_dart().into_dart(),
            self.0.action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SupportAlert>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SupportAlert>>
    for crate::api::api::SupportAlert
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SupportAlert> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::SyncStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::SyncStatus::Synced => [0.into_dart()].into_dart(),
            crate::api::api::SyncStatus::Downloading { progress, total } => [
                1.into_dart(),
                progress.into_into_dart().into_dart(),
                total.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::SyncStatus::Uploading { progress, total } => [
                2.into_dart(),
                progress.into_into_dart().into_dart(),
                total.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::SyncStatus::Syncing => [3.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::SyncStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::SyncStatus>>
    for crate::api::api::SyncStatus
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::SyncStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TeardownSignIn> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.prevtxnid.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TeardownSignIn>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TeardownSignIn>>
    for crate::api::api::TeardownSignIn
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TeardownSignIn> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TextEffect> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::TextEffect::Big => 0.into_dart(),
            crate::api::api::TextEffect::Small => 1.into_dart(),
            crate::api::api::TextEffect::Shake => 2.into_dart(),
            crate::api::api::TextEffect::Nod => 3.into_dart(),
            crate::api::api::TextEffect::Explode => 4.into_dart(),
            crate::api::api::TextEffect::Ripple => 5.into_dart(),
            crate::api::api::TextEffect::Bloom => 6.into_dart(),
            crate::api::api::TextEffect::Jitter => 7.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TextEffect>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TextEffect>>
    for crate::api::api::TextEffect
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TextEffect> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TextFlags> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.bold.into_into_dart().into_dart(),
            self.0.italic.into_into_dart().into_dart(),
            self.0.underline.into_into_dart().into_dart(),
            self.0.strikethrough.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TextFlags>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TextFlags>>
    for crate::api::api::TextFlags
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TextFlags> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TextFormat> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::TextFormat::Flags(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::api::TextFormat::Effect(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TextFormat>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TextFormat>>
    for crate::api::api::TextFormat
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TextFormat> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TranscriptDynamicUserData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.identifier.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TranscriptDynamicUserData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TranscriptDynamicUserData>>
    for crate::api::api::TranscriptDynamicUserData
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TranscriptDynamicUserData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::api::TransferProgress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.prog.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.attachment.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::api::TransferProgress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::api::TransferProgress>
    for crate::api::api::TransferProgress
{
    fn into_into_dart(self) -> crate::api::api::TransferProgress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TrustedPhoneNumber> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.number_with_dial_code.into_into_dart().into_dart(),
            self.0.last_two_digits.into_into_dart().into_dart(),
            self.0.push_mode.into_into_dart().into_dart(),
            self.0.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TrustedPhoneNumber>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TrustedPhoneNumber>>
    for crate::api::api::TrustedPhoneNumber
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TrustedPhoneNumber> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::TypingApp> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.bundle_id.into_into_dart().into_dart(),
            self.0.icon.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::TypingApp>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::TypingApp>>
    for crate::api::api::TypingApp
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::TypingApp> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::UIColor> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::api::UIColor::RGBAColorSpace {
                color_components,
                green,
                blue,
                red,
                green_dbl,
                blue_dbl,
                red_dbl,
                alpha_dbl,
                alpha,
                rgb,
                color_space,
                class,
            } => [
                0.into_dart(),
                color_components.into_into_dart().into_dart(),
                green.into_into_dart().into_dart(),
                blue.into_into_dart().into_dart(),
                red.into_into_dart().into_dart(),
                green_dbl.into_into_dart().into_dart(),
                blue_dbl.into_into_dart().into_dart(),
                red_dbl.into_into_dart().into_dart(),
                alpha_dbl.into_into_dart().into_dart(),
                alpha.into_into_dart().into_dart(),
                rgb.into_into_dart().into_dart(),
                color_space.into_into_dart().into_dart(),
                class.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::api::UIColor::GrayscaleAlphaColorSpace {
                color_components,
                white,
                alpha,
                bin,
                color_space,
                class,
            } => [
                1.into_dart(),
                color_components.into_into_dart().into_dart(),
                white.into_into_dart().into_dart(),
                alpha.into_into_dart().into_dart(),
                bin.into_into_dart().into_dart(),
                color_space.into_into_dart().into_dart(),
                class.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::UIColor>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::UIColor>>
    for crate::api::api::UIColor
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::UIColor> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::UnsendMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.tuuid.into_into_dart().into_dart(),
            self.0.edit_part.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::UnsendMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::UnsendMessage>>
    for crate::api::api::UnsendMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::UnsendMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::UpdateExtensionMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.for_uuid.into_into_dart().into_dart(),
            self.0.ext.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::UpdateExtensionMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::UpdateExtensionMessage>>
    for crate::api::api::UpdateExtensionMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::UpdateExtensionMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::UpdateProfileMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.profile.into_into_dart().into_dart(),
            self.0.share_contacts.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::UpdateProfileMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::UpdateProfileMessage>>
    for crate::api::api::UpdateProfileMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::UpdateProfileMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::UpdateProfileSharingMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.shared_dismissed.into_into_dart().into_dart(),
            self.0.shared_all.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::UpdateProfileSharingMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::UpdateProfileSharingMessage>>
    for crate::api::api::UpdateProfileSharingMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::UpdateProfileSharingMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::WallpaperMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.background_color_key.into_into_dart().into_dart(),
            self.0.font_color_key.into_into_dart().into_dart(),
            self.0.font_name_key.into_into_dart().into_dart(),
            self.0.font_size_key.into_into_dart().into_dart(),
            self.0.font_weight_key.into_into_dart().into_dart(),
            self.0.is_vertical_key.into_into_dart().into_dart(),
            self.0.type_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::WallpaperMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::WallpaperMetadata>>
    for crate::api::api::WallpaperMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::WallpaperMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::api::WatchBackground> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.is_high_key.into_into_dart().into_dart(),
            self.0.luminance.into_into_dart().into_dart(),
            self.0.background_image_data.into_into_dart().into_dart(),
            self.0.extension_identifier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::api::WatchBackground>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::api::WatchBackground>>
    for crate::api::api::WatchBackground
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::api::WatchBackground> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for Arc<PushState> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < PushState >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Asset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ConversationLink {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ConversationParticipant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Date {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Date>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for EscrowData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FindMyFriendsClient<DefaultAnisetteProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyFriendsClient<DefaultAnisetteProvider>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FindMyPhoneClient<DefaultAnisetteProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyPhoneClient<DefaultAnisetteProvider>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GZipWrapper<AttachmentMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GZipWrapper<ChatProto> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<ChatProto>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GZipWrapper<MessageProto> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GZipWrapper<MessageProto2> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto2>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GZipWrapper<MessageProto3> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto3>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GZipWrapper<MessageProto4> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto4>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for IDSUser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for JoinedOSConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MessageFlags {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for NSArray<LPIconMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPIconMetadata>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for NSArray<LPImageMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPImageMetadata>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for PushError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for StCollapsedValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for SystemTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for VerifyBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ViableBottle {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, Asset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Asset)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, StCollapsedValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, StCollapsedValue)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, u64)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, bool)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::CloudAttachment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::CloudAttachment)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::CloudChat> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::CloudChat)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::CloudMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::CloudMessage)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::FTParticipant> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::FTParticipant)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, Vec<crate::api::api::MessageEdit>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Vec<crate::api::api::MessageEdit>)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Vec<u8>)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::MessageEditRange> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::MessageEditRange)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, Option<crate::api::api::CloudAttachment>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Option<crate::api::api::CloudAttachment>)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, Option<crate::api::api::CloudChat>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Option<crate::api::api::CloudChat>)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, Option<crate::api::api::CloudMessage>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Option<crate::api::api::CloudMessage>)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::StatusKitPersonalConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::StatusKitPersonalConfig)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, crate::api::api::SyncStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::api::api::SyncStatus)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Date>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            FindMyFriendsClient<DefaultAnisetteProvider>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            FindMyPhoneClient<DefaultAnisetteProvider>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<ChatProto>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto2>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto3>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<MessageProto4>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPIconMetadata>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray<LPImageMetadata>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for std::collections::HashSet<crate::api::api::FTMember> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::api::FTMember>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for StreamSink<
        crate::api::api::MMCSTransferProgress,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::api::TransferProgress, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::api::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.administrative_area, serializer);
        <String>::sse_encode(self.country, serializer);
        <String>::sse_encode(self.country_code, serializer);
        <Option<Vec<String>>>::sse_encode(self.formatted_address_lines, serializer);
        <Option<String>>::sse_encode(self.locality, serializer);
        <Option<String>>::sse_encode(self.state_code, serializer);
        <Option<String>>::sse_encode(self.street_address, serializer);
        <Option<String>>::sse_encode(self.street_name, serializer);
    }
}

impl SseEncode for crate::api::api::AkData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.lat, serializer);
        <f32>::sse_encode(self.lng, serializer);
    }
}

impl SseEncode for crate::api::api::ApsAlert {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.body, serializer);
        <String>::sse_encode(self.sbdy, serializer);
        <String>::sse_encode(self.defbtn, serializer);
        <String>::sse_encode(self.albtn, serializer);
    }
}

impl SseEncode for crate::api::api::ApsData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::ApsAlert>::sse_encode(self.alert, serializer);
    }
}

impl SseEncode for crate::api::api::Attachment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::AttachmentType>::sse_encode(self.a_type, serializer);
        <u64>::sse_encode(self.part, serializer);
        <String>::sse_encode(self.uti_type, serializer);
        <String>::sse_encode(self.mime, serializer);
        <String>::sse_encode(self.name, serializer);
        <bool>::sse_encode(self.iris, serializer);
    }
}

impl SseEncode for crate::api::api::AttachmentMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.mime_type, serializer);
        <u64>::sse_encode(self.start_date, serializer);
        <u64>::sse_encode(self.total_bytes, serializer);
        <u32>::sse_encode(self.transfer_state, serializer);
        <bool>::sse_encode(self.is_sticker, serializer);
        <String>::sse_encode(self.guid, serializer);
        <bool>::sse_encode(self.hide_attachment, serializer);
        <Option<crate::api::api::MMCSAttachmentMeta>>::sse_encode(self.user_info, serializer);
        <String>::sse_encode(self.filename, serializer);
        <Option<crate::api::api::AttachmentMetaExtra>>::sse_encode(self.extras, serializer);
        <bool>::sse_encode(self.is_outgoing, serializer);
        <String>::sse_encode(self.transfer_name, serializer);
        <u32>::sse_encode(self.version, serializer);
        <Option<String>>::sse_encode(self.uti, serializer);
        <u64>::sse_encode(self.created_date, serializer);
        <Option<String>>::sse_encode(self.pathc, serializer);
        <Option<String>>::sse_encode(self.md5, serializer);
    }
}

impl SseEncode for crate::api::api::AttachmentMetaExtra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.preview_generation_state, serializer);
    }
}

impl SseEncode for crate::api::api::AttachmentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::AttachmentType::Inline(field0) => {
                <i32>::sse_encode(0, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            crate::api::api::AttachmentType::MMCS(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::MMCSFile>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::Balloon {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.session, serializer);
        <Option<crate::api::api::BalloonLayout>>::sse_encode(self.layout, serializer);
        <Option<String>>::sse_encode(self.ld_text, serializer);
        <bool>::sse_encode(self.is_live, serializer);
        <Option<Vec<u8>>>::sse_encode(self.icon, serializer);
    }
}

impl SseEncode for crate::api::api::BalloonLayout {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::BalloonLayout::TemplateLayout {
                image_subtitle,
                image_title,
                caption,
                secondary_subcaption,
                tertiary_subcaption,
                subcaption,
                class,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(image_subtitle, serializer);
                <String>::sse_encode(image_title, serializer);
                <String>::sse_encode(caption, serializer);
                <String>::sse_encode(secondary_subcaption, serializer);
                <String>::sse_encode(tertiary_subcaption, serializer);
                <String>::sse_encode(subcaption, serializer);
                <crate::api::api::NSDictionaryClass>::sse_encode(class, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::api::CertifiedContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.version, serializer);
        <Vec<u8>>::sse_encode(self.receipt, serializer);
        <String>::sse_encode(self.sender, serializer);
        <String>::sse_encode(self.target, serializer);
        <Vec<u8>>::sse_encode(self.uuid, serializer);
        <Vec<u8>>::sse_encode(self.token, serializer);
    }
}

impl SseEncode for crate::api::api::ChangeParticipantMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.new_participants, serializer);
        <u64>::sse_encode(self.group_version, serializer);
    }
}

impl SseEncode for crate::api::api::ChatProto {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.unk1, serializer);
    }
}

impl SseEncode for crate::api::api::CloudAttachment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <GZipWrapper<AttachmentMeta>>::sse_encode(self.cm, serializer);
        <Asset>::sse_encode(self.lqa, serializer);
    }
}

impl SseEncode for crate::api::api::CloudChat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.style, serializer);
        <i64>::sse_encode(self.is_filtered, serializer);
        <i64>::sse_encode(self.successful_query, serializer);
        <i64>::sse_encode(self.state, serializer);
        <String>::sse_encode(self.chat_identifier, serializer);
        <String>::sse_encode(self.group_id, serializer);
        <String>::sse_encode(self.service_name, serializer);
        <String>::sse_encode(self.original_group_id, serializer);
        <Option<crate::api::api::CloudProp>>::sse_encode(self.properties, serializer);
        <Vec<crate::api::api::CloudParticipant>>::sse_encode(self.participants, serializer);
        <crate::api::api::CloudProp001>::sse_encode(self.prop001, serializer);
        <i64>::sse_encode(self.last_read_message_timestamp, serializer);
        <String>::sse_encode(self.last_addressed_handle, serializer);
        <String>::sse_encode(self.guid, serializer);
        <Option<String>>::sse_encode(self.display_name, serializer);
        <Option<GZipWrapper<ChatProto>>>::sse_encode(self.proto001, serializer);
        <Option<String>>::sse_encode(self.group_photo_guid, serializer);
        <Option<Asset>>::sse_encode(self.group_photo, serializer);
    }
}

impl SseEncode for crate::api::api::CloudMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<SystemTime>>::sse_encode(self.utm, serializer);
        <i64>::sse_encode(self.r#type, serializer);
        <i64>::sse_encode(self.error, serializer);
        <String>::sse_encode(self.chat_id, serializer);
        <String>::sse_encode(self.sender, serializer);
        <i64>::sse_encode(self.time, serializer);
        <Option<GZipWrapper<MessageProto2>>>::sse_encode(self.msg_proto_2, serializer);
        <String>::sse_encode(self.destination_caller_id, serializer);
        <GZipWrapper<MessageProto>>::sse_encode(self.msg_proto, serializer);
        <MessageFlags>::sse_encode(self.flags, serializer);
        <String>::sse_encode(self.guid, serializer);
        <Option<GZipWrapper<MessageProto3>>>::sse_encode(self.msg_proto_3, serializer);
        <String>::sse_encode(self.service, serializer);
        <Option<GZipWrapper<MessageProto4>>>::sse_encode(self.msg_proto_4, serializer);
    }
}

impl SseEncode for crate::api::api::CloudParticipant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.uri, serializer);
    }
}

impl SseEncode for crate::api::api::CloudProp {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.gpufc, serializer);
        <Option<u32>>::sse_encode(self.pv, serializer);
        <Option<u32>>::sse_encode(self.number_of_times_respondedto_thread, serializer);
        <Option<bool>>::sse_encode(self.should_force_to_sms, serializer);
        <Option<String>>::sse_encode(self.last_seen_message_guid, serializer);
        <Option<u32>>::sse_encode(self.message_handshake_state, serializer);
        <Vec<String>>::sse_encode(self.legacy_group_identifiers, serializer);
        <Option<String>>::sse_encode(self.group_photo_guid, serializer);
        <Option<Date>>::sse_encode(self.last_modification_date, serializer);
    }
}

impl SseEncode for crate::api::api::CloudProp001 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.syndication_type, serializer);
    }
}

impl SseEncode for crate::api::api::ConversationData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.participants, serializer);
        <Option<String>>::sse_encode(self.cv_name, serializer);
        <Option<String>>::sse_encode(self.sender_guid, serializer);
        <Option<String>>::sse_encode(self.after_guid, serializer);
    }
}

impl SseEncode for crate::api::api::DeleteTarget {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::DeleteTarget::Chat(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::OperatedChat>::sse_encode(field0, serializer);
            }
            crate::api::api::DeleteTarget::Messages(field0) => {
                <i32>::sse_encode(1, serializer);
                <Vec<String>>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::DeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.serial, serializer);
        <String>::sse_encode(self.os_version, serializer);
        <Option<Vec<u8>>>::sse_encode(self.encoded_data, serializer);
    }
}

impl SseEncode for crate::api::api::EditMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.tuuid, serializer);
        <u64>::sse_encode(self.edit_part, serializer);
        <crate::api::api::MessageParts>::sse_encode(self.new_parts, serializer);
    }
}

impl SseEncode for crate::api::api::ErrorMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.for_uuid, serializer);
        <u64>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.status_str, serializer);
    }
}

impl SseEncode for crate::api::api::ExtensionApp {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Option<u64>>::sse_encode(self.app_id, serializer);
        <String>::sse_encode(self.bundle_id, serializer);
        <Option<crate::api::api::Balloon>>::sse_encode(self.balloon, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::api::FFIFilePackager {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::api::Follow {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.create_timestamp, serializer);
        <i64>::sse_encode(self.expires, serializer);
        <String>::sse_encode(self.id, serializer);
        <Vec<String>>::sse_encode(self.invitation_accepted_handles, serializer);
        <Vec<String>>::sse_encode(self.invitation_from_handles, serializer);
        <bool>::sse_encode(self.is_from_messages, serializer);
        <Option<String>>::sse_encode(self.offer_id, serializer);
        <bool>::sse_encode(self.only_in_event, serializer);
        <String>::sse_encode(self.person_id_hash, serializer);
        <bool>::sse_encode(self.secure_locations_capable, serializer);
        <bool>::sse_encode(self.shallow_or_live_secure_locations_capable, serializer);
        <String>::sse_encode(self.source, serializer);
        <bool>::sse_encode(self.tk_permission, serializer);
        <i64>::sse_encode(self.update_timestamp, serializer);
        <Option<bool>>::sse_encode(self.fallback_to_legacy_allowed, serializer);
        <Option<bool>>::sse_encode(self.opted_not_to_share, serializer);
        <Option<crate::api::api::Location>>::sse_encode(self.last_location, serializer);
        <bool>::sse_encode(self.locate_in_progress, serializer);
    }
}

impl SseEncode for crate::api::api::FoundDevice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.device_model, serializer);
        <Option<bool>>::sse_encode(self.low_power_mode, serializer);
        <Option<i64>>::sse_encode(self.passcode_length, serializer);
        <Option<String>>::sse_encode(self.id, serializer);
        <Option<String>>::sse_encode(self.battery_status, serializer);
        <Option<bool>>::sse_encode(self.lost_mode_capable, serializer);
        <Option<f64>>::sse_encode(self.battery_level, serializer);
        <Option<bool>>::sse_encode(self.location_enabled, serializer);
        <Option<bool>>::sse_encode(self.is_considered_accessory, serializer);
        <Option<crate::api::api::Location>>::sse_encode(self.location, serializer);
        <Option<String>>::sse_encode(self.model_display_name, serializer);
        <Option<String>>::sse_encode(self.device_color, serializer);
        <Option<bool>>::sse_encode(self.activation_locked, serializer);
        <Option<i64>>::sse_encode(self.rm2_state, serializer);
        <Option<bool>>::sse_encode(self.loc_found_enabled, serializer);
        <Option<bool>>::sse_encode(self.nwd, serializer);
        <Option<String>>::sse_encode(self.device_status, serializer);
        <Option<bool>>::sse_encode(self.fmly_share, serializer);
        <std::collections::HashMap<String, bool>>::sse_encode(self.features, serializer);
        <Option<bool>>::sse_encode(self.this_device, serializer);
        <Option<bool>>::sse_encode(self.lost_mode_enabled, serializer);
        <Option<String>>::sse_encode(self.device_display_name, serializer);
        <Option<String>>::sse_encode(self.name, serializer);
        <Option<bool>>::sse_encode(self.can_wipe_after_lock, serializer);
        <Option<bool>>::sse_encode(self.is_mac, serializer);
        <Option<String>>::sse_encode(self.raw_device_model, serializer);
        <Option<String>>::sse_encode(self.ba_uuid, serializer);
        <Option<String>>::sse_encode(self.device_discovery_id, serializer);
        <Option<bool>>::sse_encode(self.scd, serializer);
        <Option<bool>>::sse_encode(self.location_capable, serializer);
        <Option<bool>>::sse_encode(self.wipe_in_progress, serializer);
        <Option<bool>>::sse_encode(self.dark_wake, serializer);
        <Option<bool>>::sse_encode(self.device_with_you, serializer);
        <Option<i64>>::sse_encode(self.max_msg_char, serializer);
        <Option<String>>::sse_encode(self.device_class, serializer);
    }
}

impl SseEncode for crate::api::api::FTMember {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.handle, serializer);
    }
}

impl SseEncode for crate::api::api::FTMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::FTMessage::LetMeInRequest(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::LetMeInRequest>::sse_encode(field0, serializer);
            }
            crate::api::api::FTMessage::LinkChanged { guid } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(guid, serializer);
            }
            crate::api::api::FTMessage::JoinEvent {
                guid,
                participant,
                handle,
                ring,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(guid, serializer);
                <u64>::sse_encode(participant, serializer);
                <String>::sse_encode(handle, serializer);
                <bool>::sse_encode(ring, serializer);
            }
            crate::api::api::FTMessage::AddMembers {
                guid,
                members,
                ring,
            } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(guid, serializer);
                <std::collections::HashSet<crate::api::api::FTMember>>::sse_encode(
                    members, serializer,
                );
                <bool>::sse_encode(ring, serializer);
            }
            crate::api::api::FTMessage::RemoveMembers { guid, members } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(guid, serializer);
                <std::collections::HashSet<crate::api::api::FTMember>>::sse_encode(
                    members, serializer,
                );
            }
            crate::api::api::FTMessage::LeaveEvent {
                guid,
                participant,
                handle,
            } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(guid, serializer);
                <u64>::sse_encode(participant, serializer);
                <String>::sse_encode(handle, serializer);
            }
            crate::api::api::FTMessage::Ring { guid } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(guid, serializer);
            }
            crate::api::api::FTMessage::Decline { guid } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(guid, serializer);
            }
            crate::api::api::FTMessage::RespondedElsewhere { guid } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(guid, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::FTMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::api::FTMode::Outgoing => 0,
                crate::api::api::FTMode::Incoming => 1,
                crate::api::api::FTMode::Missed => 2,
                crate::api::api::FTMode::MissedOutgoing => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::FTParticipant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.token, serializer);
        <String>::sse_encode(self.handle, serializer);
        <u64>::sse_encode(self.participant_id, serializer);
        <Option<u64>>::sse_encode(self.last_join_date, serializer);
        <Option<ConversationParticipant>>::sse_encode(self.active, serializer);
    }
}

impl SseEncode for crate::api::api::FTSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.group_id, serializer);
        <Vec<String>>::sse_encode(self.my_handles, serializer);
        <std::collections::HashMap<String, crate::api::api::FTParticipant>>::sse_encode(
            self.participants,
            serializer,
        );
        <Option<ConversationLink>>::sse_encode(self.link, serializer);
        <std::collections::HashSet<crate::api::api::FTMember>>::sse_encode(
            self.members,
            serializer,
        );
        <String>::sse_encode(self.report_id, serializer);
        <Option<u64>>::sse_encode(self.start_time, serializer);
        <Option<u64>>::sse_encode(self.last_rekey, serializer);
        <bool>::sse_encode(self.is_propped, serializer);
        <bool>::sse_encode(self.is_ringing_inaccurate, serializer);
        <Option<crate::api::api::FTMode>>::sse_encode(self.mode, serializer);
        <std::collections::HashMap<String, u64>>::sse_encode(self.recent_member_adds, serializer);
    }
}

impl SseEncode for crate::api::api::HwExtra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.version, serializer);
        <u32>::sse_encode(self.protocol_version, serializer);
        <String>::sse_encode(self.device_id, serializer);
        <String>::sse_encode(self.icloud_ua, serializer);
        <String>::sse_encode(self.aoskit_version, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::api::IMessageNameRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.first, serializer);
        <String>::sse_encode(self.last, serializer);
    }
}

impl SseEncode for crate::api::api::IMessageNicknameRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::IMessageNameRecord>::sse_encode(self.name, serializer);
        <Option<Vec<u8>>>::sse_encode(self.image, serializer);
        <Option<crate::api::api::IMessagePosterRecord>>::sse_encode(self.poster, serializer);
    }
}

impl SseEncode for crate::api::api::IMessagePosterRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.low_res_poster, serializer);
        <Vec<u8>>::sse_encode(self.package, serializer);
        <Vec<u8>>::sse_encode(self.meta, serializer);
    }
}

impl SseEncode for crate::api::api::IconChangeMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::api::MMCSFile>>::sse_encode(self.file, serializer);
        <u64>::sse_encode(self.group_version, serializer);
    }
}

impl SseEncode for crate::api::api::IdmsCircleMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.step, serializer);
        <String>::sse_encode(self.atxnid, serializer);
        <Option<String>>::sse_encode(self.pake, serializer);
        <Option<i32>>::sse_encode(self.ec, serializer);
        <String>::sse_encode(self.idmsdata, serializer);
    }
}

impl SseEncode for crate::api::api::IdmsMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::IdmsMessage::RequestedSignIn(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::IdmsRequestedSignIn>::sse_encode(field0, serializer);
            }
            crate::api::api::IdmsMessage::TeardownSignIn(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::TeardownSignIn>::sse_encode(field0, serializer);
            }
            crate::api::api::IdmsMessage::CircleRequest(field0, field1) => {
                <i32>::sse_encode(2, serializer);
                <crate::api::api::IdmsCircleMessage>::sse_encode(field0, serializer);
                <Option<crate::api::api::IdmsRequestedSignIn>>::sse_encode(field1, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::IdmsRequestedSignIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::ApsData>::sse_encode(self.aps, serializer);
        <String>::sse_encode(self.txnid, serializer);
        <crate::api::api::AkData>::sse_encode(self.akdata, serializer);
        <String>::sse_encode(self.adsid, serializer);
    }
}

impl SseEncode for crate::api::api::IndexedMessagePart {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::MessagePart>::sse_encode(self.part, serializer);
        <Option<usize>>::sse_encode(self.idx, serializer);
        <Option<crate::api::api::PartExtension>>::sse_encode(self.ext, serializer);
    }
}

impl SseEncode for crate::api::api::LetMeInRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.shared_secret, serializer);
        <String>::sse_encode(self.pseud, serializer);
        <String>::sse_encode(self.requestor, serializer);
        <Option<String>>::sse_encode(self.nickname, serializer);
        <Vec<u8>>::sse_encode(self.token, serializer);
        <Option<String>>::sse_encode(self.delegation_uuid, serializer);
        <Option<String>>::sse_encode(self.usage, serializer);
    }
}

impl SseEncode for crate::api::api::LinkMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::LPLinkMetadata>::sse_encode(self.data, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.attachments, serializer);
    }
}

impl SseEncode for Vec<IDSUser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <IDSUser>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<StCollapsedValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <StCollapsedValue>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ViableBottle> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ViableBottle>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::CloudParticipant> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::CloudParticipant>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::Follow> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::Follow>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::FoundDevice> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::FoundDevice>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::FTMember> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::FTMember>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::FTSession> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::FTSession>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::IndexedMessagePart> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::IndexedMessagePart>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::MessageEdit> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::MessageEdit>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::MessageTarget> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::MessageTarget>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::PhotoPosterLayer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::PhotoPosterLayer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::PosterAsset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::PosterAsset>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::PosterColor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::PosterColor>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::PrivateDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::PrivateDeviceInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Asset)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Asset)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, StCollapsedValue)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, StCollapsedValue)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, bool)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, bool)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, u64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, u64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::CloudAttachment)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::CloudAttachment)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::CloudChat)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::CloudChat)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::CloudMessage)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::CloudMessage)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::FTParticipant)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::FTParticipant)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Vec<crate::api::api::MessageEdit>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Vec<crate::api::api::MessageEdit>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Vec<u8>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::MessageEditRange)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::MessageEditRange)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Option<crate::api::api::CloudAttachment>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Option<crate::api::api::CloudAttachment>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Option<crate::api::api::CloudChat>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Option<crate::api::api::CloudChat>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Option<crate::api::api::CloudMessage>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Option<crate::api::api::CloudMessage>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::StatusKitPersonalConfig)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::StatusKitPersonalConfig)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::api::api::SyncStatus)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::api::api::SyncStatus)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(u32, crate::api::api::NSDictionaryTypedCoder)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(u32, crate::api::api::NSDictionaryTypedCoder)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::ReportMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::ReportMessage>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::SharedAlbum> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::SharedAlbum>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::TrustedPhoneNumber> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::TrustedPhoneNumber>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::api::UIColor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::api::UIColor>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::api::Location {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::api::Address>>::sse_encode(self.address, serializer);
        <f64>::sse_encode(self.altitude, serializer);
        <i64>::sse_encode(self.floor_level, serializer);
        <f64>::sse_encode(self.horizontal_accuracy, serializer);
        <bool>::sse_encode(self.is_inaccurate, serializer);
        <f64>::sse_encode(self.latitude, serializer);
        <Option<String>>::sse_encode(self.location_id, serializer);
        <Option<i64>>::sse_encode(self.location_timestamp, serializer);
        <f64>::sse_encode(self.longitude, serializer);
        <i64>::sse_encode(self.secure_location_ts, serializer);
        <i64>::sse_encode(self.timestamp, serializer);
        <f64>::sse_encode(self.vertical_accuracy, serializer);
        <Option<String>>::sse_encode(self.position_type, serializer);
        <Option<bool>>::sse_encode(self.is_old, serializer);
        <Option<bool>>::sse_encode(self.location_finished, serializer);
    }
}

impl SseEncode for crate::api::api::LoginState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::LoginState::LoggedIn => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::api::LoginState::NeedsDevice2FA => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::api::LoginState::Needs2FAVerification => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::api::LoginState::NeedsSMS2FA => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::api::LoginState::NeedsSMS2FAVerification(field0) => {
                <i32>::sse_encode(4, serializer);
                <VerifyBody>::sse_encode(field0, serializer);
            }
            crate::api::api::LoginState::NeedsExtraStep(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::api::LoginState::NeedsLogin => {
                <i32>::sse_encode(6, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::LPIconMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::NSURL>::sse_encode(self.url, serializer);
        <u8>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for crate::api::api::LPImageMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.size, serializer);
        <crate::api::api::NSURL>::sse_encode(self.url, serializer);
        <u8>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for crate::api::api::LPLinkMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::api::LPImageMetadata>>::sse_encode(self.image_metadata, serializer);
        <u8>::sse_encode(self.version, serializer);
        <Option<crate::api::api::LPIconMetadata>>::sse_encode(self.icon_metadata, serializer);
        <crate::api::api::NSURL>::sse_encode(self.original_url, serializer);
        <Option<crate::api::api::NSURL>>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.summary, serializer);
        <Option<crate::api::api::RichLinkImageAttachmentSubstitute>>::sse_encode(
            self.image, serializer,
        );
        <Option<crate::api::api::RichLinkImageAttachmentSubstitute>>::sse_encode(
            self.icon, serializer,
        );
        <Option<NSArray<LPImageMetadata>>>::sse_encode(self.images, serializer);
        <Option<NSArray<LPIconMetadata>>>::sse_encode(self.icons, serializer);
    }
}

impl SseEncode for crate::api::api::MemojiData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::PosterColor>::sse_encode(self.background_color_description, serializer);
        <Vec<u8>>::sse_encode(self.avatar_record_data, serializer);
        <Vec<u8>>::sse_encode(self.avatar_pose_data, serializer);
        <bool>::sse_encode(self.has_body, serializer);
        <Vec<u8>>::sse_encode(self.avatar_image_data, serializer);
    }
}

impl SseEncode for crate::api::api::Message {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::Message::Message(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::NormalMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::RenameMessage(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::RenameMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::ChangeParticipants(field0) => {
                <i32>::sse_encode(2, serializer);
                <crate::api::api::ChangeParticipantMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::React(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::api::api::ReactMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::Delivered => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::api::Message::Read => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::api::Message::Typing(field0, field1) => {
                <i32>::sse_encode(6, serializer);
                <bool>::sse_encode(field0, serializer);
                <Option<crate::api::api::TypingApp>>::sse_encode(field1, serializer);
            }
            crate::api::api::Message::Unsend(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::api::api::UnsendMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::Edit(field0) => {
                <i32>::sse_encode(8, serializer);
                <crate::api::api::EditMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::IconChange(field0) => {
                <i32>::sse_encode(9, serializer);
                <crate::api::api::IconChangeMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::EnableSmsActivation(field0) => {
                <i32>::sse_encode(10, serializer);
                <bool>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::MessageReadOnDevice => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::api::Message::SmsConfirmSent(field0) => {
                <i32>::sse_encode(12, serializer);
                <bool>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::MarkUnread => {
                <i32>::sse_encode(13, serializer);
            }
            crate::api::api::Message::PeerCacheInvalidate => {
                <i32>::sse_encode(14, serializer);
            }
            crate::api::api::Message::UpdateExtension(field0) => {
                <i32>::sse_encode(15, serializer);
                <crate::api::api::UpdateExtensionMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::Error(field0) => {
                <i32>::sse_encode(16, serializer);
                <crate::api::api::ErrorMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::MoveToRecycleBin(field0) => {
                <i32>::sse_encode(17, serializer);
                <crate::api::api::MoveToRecycleBinMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::RecoverChat(field0) => {
                <i32>::sse_encode(18, serializer);
                <crate::api::api::OperatedChat>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::PermanentDelete(field0) => {
                <i32>::sse_encode(19, serializer);
                <crate::api::api::PermanentDeleteMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::Unschedule => {
                <i32>::sse_encode(20, serializer);
            }
            crate::api::api::Message::UpdateProfile(field0) => {
                <i32>::sse_encode(21, serializer);
                <crate::api::api::UpdateProfileMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::UpdateProfileSharing(field0) => {
                <i32>::sse_encode(22, serializer);
                <crate::api::api::UpdateProfileSharingMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::ShareProfile(field0) => {
                <i32>::sse_encode(23, serializer);
                <crate::api::api::ShareProfileMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::Message::NotifyAnyways => {
                <i32>::sse_encode(24, serializer);
            }
            crate::api::api::Message::SetTranscriptBackground(field0) => {
                <i32>::sse_encode(25, serializer);
                <crate::api::api::SetTranscriptBackgroundMessage>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::MessageEdit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.t, serializer);
        <f64>::sse_encode(self.d, serializer);
        <Option<String>>::sse_encode(self.bcg, serializer);
    }
}

impl SseEncode for crate::api::api::MessageEditRange {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.lo, serializer);
        <u32>::sse_encode(self.le, serializer);
    }
}

impl SseEncode for crate::api::api::MessageInst {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <Option<String>>::sse_encode(self.sender, serializer);
        <Option<crate::api::api::ConversationData>>::sse_encode(self.conversation, serializer);
        <crate::api::api::Message>::sse_encode(self.message, serializer);
        <u64>::sse_encode(self.sent_timestamp, serializer);
        <Option<Vec<crate::api::api::MessageTarget>>>::sse_encode(self.target, serializer);
        <bool>::sse_encode(self.send_delivered, serializer);
        <bool>::sse_encode(self.verification_failed, serializer);
        <Option<crate::api::api::CertifiedContext>>::sse_encode(self.certified_context, serializer);
    }
}

impl SseEncode for crate::api::api::MessagePart {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::MessagePart::Text(field0, field1) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
                <crate::api::api::TextFormat>::sse_encode(field1, serializer);
            }
            crate::api::api::MessagePart::Attachment(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::Attachment>::sse_encode(field0, serializer);
            }
            crate::api::api::MessagePart::Mention(field0, field1) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
                <String>::sse_encode(field1, serializer);
            }
            crate::api::api::MessagePart::Object(field0) => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::MessageParts {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::api::IndexedMessagePart>>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::api::MessageProto {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.unk1, serializer);
        <Option<String>>::sse_encode(self.group_title, serializer);
        <String>::sse_encode(self.text, serializer);
        <Vec<u8>>::sse_encode(self.attributed_body, serializer);
        <Option<String>>::sse_encode(self.balloon_bundle_id, serializer);
        <Option<Vec<u8>>>::sse_encode(self.payload_data, serializer);
        <Option<Vec<u8>>>::sse_encode(self.message_summary_info, serializer);
        <Option<String>>::sse_encode(self.effect, serializer);
        <Option<u64>>::sse_encode(self.date_read, serializer);
        <Option<u32>>::sse_encode(self.unk10, serializer);
        <Option<u32>>::sse_encode(self.unk11, serializer);
        <Option<u64>>::sse_encode(self.date_delivered, serializer);
        <Option<u32>>::sse_encode(self.unk14, serializer);
        <Option<u32>>::sse_encode(self.associated_message_type, serializer);
        <Option<String>>::sse_encode(self.associated_message_guid, serializer);
        <Option<u32>>::sse_encode(self.associated_message_range_location, serializer);
        <Option<u32>>::sse_encode(self.associated_message_range_length, serializer);
    }
}

impl SseEncode for crate::api::api::MessageProto2 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.reply, serializer);
    }
}

impl SseEncode for crate::api::api::MessageProto3 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.unk2, serializer);
        <Option<u32>>::sse_encode(self.unk3, serializer);
    }
}

impl SseEncode for crate::api::api::MessageProto4 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.associated_message_emoji, serializer);
        <Option<String>>::sse_encode(self.service, serializer);
        <Option<u32>>::sse_encode(self.schedule_type, serializer);
        <Option<u32>>::sse_encode(self.schedule_state, serializer);
        <Option<String>>::sse_encode(self.group_id, serializer);
        <Option<u32>>::sse_encode(self.sent_or_received_off_grid, serializer);
    }
}

impl SseEncode for crate::api::api::MessageSummaryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.ams, serializer);
        <Option<Vec<u8>>>::sse_encode(self.ampt, serializer);
        <Option<u32>>::sse_encode(self.amc, serializer);
        <Option<String>>::sse_encode(self.amb, serializer);
        <Option<String>>::sse_encode(self.amd, serializer);
        <std::collections::HashMap<String, Vec<crate::api::api::MessageEdit>>>::sse_encode(
            self.ec, serializer,
        );
        <Vec<u32>>::sse_encode(self.ep, serializer);
        <std::collections::HashMap<String, crate::api::api::MessageEditRange>>::sse_encode(
            self.otr, serializer,
        );
        <Option<bool>>::sse_encode(self.ust, serializer);
        <Vec<u32>>::sse_encode(self.rp, serializer);
        <Option<bool>>::sse_encode(self.hbr, serializer);
        <Option<String>>::sse_encode(self.oui, serializer);
        <Option<String>>::sse_encode(self.osn, serializer);
        <Vec<String>>::sse_encode(self.euh, serializer);
    }
}

impl SseEncode for crate::api::api::MessageTarget {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::MessageTarget::Token(field0) => {
                <i32>::sse_encode(0, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            crate::api::api::MessageTarget::Uuid(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::MessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::MessageType::IMessage => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::api::MessageType::SMS {
                is_phone,
                using_number,
                from_handle,
            } => {
                <i32>::sse_encode(1, serializer);
                <bool>::sse_encode(is_phone, serializer);
                <String>::sse_encode(using_number, serializer);
                <Option<String>>::sse_encode(from_handle, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::MMCSAttachmentMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.mmcs_signature_hex, serializer);
        <crate::api::api::NumOrString>::sse_encode(self.file_size, serializer);
        <String>::sse_encode(self.decryption_key, serializer);
        <Option<String>>::sse_encode(self.uti_type, serializer);
        <String>::sse_encode(self.mmcs_owner, serializer);
        <Option<String>>::sse_encode(self.mime_type, serializer);
        <String>::sse_encode(self.mmcs_url, serializer);
        <Option<String>>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for crate::api::api::MMCSFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.signature, serializer);
        <String>::sse_encode(self.object, serializer);
        <String>::sse_encode(self.url, serializer);
        <Vec<u8>>::sse_encode(self.key, serializer);
        <usize>::sse_encode(self.size, serializer);
    }
}

impl SseEncode for crate::api::api::MMCSTransferProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.prog, serializer);
        <usize>::sse_encode(self.total, serializer);
        <Option<crate::api::api::MMCSFile>>::sse_encode(self.file, serializer);
    }
}

impl SseEncode for crate::api::api::MonogramData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::PosterColor>::sse_encode(
            self.top_background_color_description,
            serializer,
        );
        <crate::api::api::PosterColor>::sse_encode(self.background_color_description, serializer);
        <String>::sse_encode(self.initials, serializer);
        <bool>::sse_encode(self.monogram_supported_for_name, serializer);
    }
}

impl SseEncode for crate::api::api::MoveToRecycleBinMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::DeleteTarget>::sse_encode(self.target, serializer);
        <u64>::sse_encode(self.recoverable_delete_date, serializer);
    }
}

impl SseEncode for crate::api::api::MyAsyncRuntime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::api::NormalMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::MessageParts>::sse_encode(self.parts, serializer);
        <Option<String>>::sse_encode(self.effect, serializer);
        <Option<String>>::sse_encode(self.reply_guid, serializer);
        <Option<String>>::sse_encode(self.reply_part, serializer);
        <crate::api::api::MessageType>::sse_encode(self.service, serializer);
        <Option<String>>::sse_encode(self.subject, serializer);
        <Option<crate::api::api::ExtensionApp>>::sse_encode(self.app, serializer);
        <Option<crate::api::api::LinkMeta>>::sse_encode(self.link_meta, serializer);
        <bool>::sse_encode(self.voice, serializer);
        <Option<crate::api::api::ScheduleMode>>::sse_encode(self.scheduled, serializer);
        <Option<crate::api::api::ShareProfileMessage>>::sse_encode(
            self.embedded_profile,
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::NSAttributedString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.text, serializer);
        <Vec<(u32, crate::api::api::NSDictionaryTypedCoder)>>::sse_encode(self.ranges, serializer);
    }
}

impl SseEncode for crate::api::api::NSDictionaryClass {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::api::NSDictionaryClass::NSDictionary => 0,
                crate::api::api::NSDictionaryClass::NSMutableDictionary => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::NSDictionaryTypedCoder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <std::collections::HashMap<String, StCollapsedValue>>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::api::NSNumber {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::api::NSString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::api::NSURL {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.base, serializer);
        <String>::sse_encode(self.relative, serializer);
    }
}

impl SseEncode for crate::api::api::NumOrString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::NumOrString::Num(field0) => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            crate::api::api::NumOrString::String(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::OperatedChat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.participants, serializer);
        <String>::sse_encode(self.group_id, serializer);
        <String>::sse_encode(self.guid, serializer);
        <Option<bool>>::sse_encode(self.delete_incoming_messages, serializer);
        <Option<bool>>::sse_encode(self.was_reported_as_junk, serializer);
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Asset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Asset>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ConversationLink> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ConversationLink>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ConversationParticipant> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ConversationParticipant>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Date> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Date>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<GZipWrapper<ChatProto>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <GZipWrapper<ChatProto>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<GZipWrapper<MessageProto2>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <GZipWrapper<MessageProto2>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<GZipWrapper<MessageProto3>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <GZipWrapper<MessageProto3>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<GZipWrapper<MessageProto4>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <GZipWrapper<MessageProto4>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<IDSUser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <IDSUser>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<JoinedOSConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <JoinedOSConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<NSArray<LPIconMetadata>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <NSArray<LPIconMetadata>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<NSArray<LPImageMetadata>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <NSArray<LPImageMetadata>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<SystemTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <SystemTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::Address> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::Address>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::Attachment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::Attachment>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::AttachmentMetaExtra> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::AttachmentMetaExtra>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::Balloon> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::Balloon>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::BalloonLayout> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::BalloonLayout>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::CertifiedContext> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::CertifiedContext>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::CloudAttachment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::CloudAttachment>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::CloudChat> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::CloudChat>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::CloudMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::CloudMessage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::CloudProp> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::CloudProp>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::ConversationData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::ConversationData>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::ExtensionApp> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::ExtensionApp>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::FTMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::FTMode>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::IMessagePosterRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::IMessagePosterRecord>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::IdmsRequestedSignIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::IdmsRequestedSignIn>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::LinkMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::LinkMeta>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::Location> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::Location>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::LoginState> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::LoginState>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::LPIconMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::LPIconMetadata>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::LPImageMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::LPImageMetadata>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::MMCSAttachmentMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::MMCSAttachmentMeta>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::MMCSFile> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::MMCSFile>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::NSURL> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::NSURL>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::PartExtension> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::PartExtension>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::PosterColor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::PosterColor>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::PRPosterContentMaterialStyle> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::PRPosterContentMaterialStyle>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::PushMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::PushMessage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(String, u64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(String, u64)>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::RichLinkImageAttachmentSubstitute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::RichLinkImageAttachmentSubstitute>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::ScheduleMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::ScheduleMode>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::ShareProfileMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::ShareProfileMessage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::SharedPoster> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::SharedPoster>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::SupportAction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::SupportAction>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::SupportAlert> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::SupportAlert>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::api::TypingApp> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::api::TypingApp>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::api::MessageTarget>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::api::MessageTarget>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::api::PartExtension {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::PartExtension::Sticker {
                msg_width,
                rotation,
                sai,
                scale,
                update,
                sli,
                normalized_x,
                normalized_y,
                version,
                hash,
                safi,
                effect_type,
                sticker_id,
            } => {
                <i32>::sse_encode(0, serializer);
                <f64>::sse_encode(msg_width, serializer);
                <f64>::sse_encode(rotation, serializer);
                <u64>::sse_encode(sai, serializer);
                <f64>::sse_encode(scale, serializer);
                <Option<bool>>::sse_encode(update, serializer);
                <u64>::sse_encode(sli, serializer);
                <f64>::sse_encode(normalized_x, serializer);
                <f64>::sse_encode(normalized_y, serializer);
                <u64>::sse_encode(version, serializer);
                <String>::sse_encode(hash, serializer);
                <u64>::sse_encode(safi, serializer);
                <i64>::sse_encode(effect_type, serializer);
                <String>::sse_encode(sticker_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::PermanentDeleteMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::DeleteTarget>::sse_encode(self.target, serializer);
        <bool>::sse_encode(self.is_scheduled, serializer);
    }
}

impl SseEncode for crate::api::api::PhotoPosterContents {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.version, serializer);
        <Vec<crate::api::api::PhotoPosterLayer>>::sse_encode(self.layers, serializer);
        <crate::api::api::PhotoPosterProperties>::sse_encode(self.properties, serializer);
    }
}

impl SseEncode for crate::api::api::PhotoPosterContentsFrame {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.width, serializer);
        <f64>::sse_encode(self.height, serializer);
        <f64>::sse_encode(self.x, serializer);
        <f64>::sse_encode(self.y, serializer);
    }
}

impl SseEncode for crate::api::api::PhotoPosterContentsSize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.width, serializer);
        <f64>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for crate::api::api::PhotoPosterLayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::PhotoPosterContentsFrame>::sse_encode(self.frame, serializer);
        <String>::sse_encode(self.filename, serializer);
        <f32>::sse_encode(self.z_position, serializer);
        <String>::sse_encode(self.identifier, serializer);
    }
}

impl SseEncode for crate::api::api::PhotoPosterLayout {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.clock_intersection, serializer);
        <crate::api::api::PhotoPosterContentsSize>::sse_encode(self.device_resolution, serializer);
        <crate::api::api::PhotoPosterContentsFrame>::sse_encode(self.visible_frame, serializer);
        <crate::api::api::PhotoPosterContentsFrame>::sse_encode(self.time_frame, serializer);
        <String>::sse_encode(self.clock_layer_order, serializer);
        <bool>::sse_encode(self.has_top_edge_contact, serializer);
        <crate::api::api::PhotoPosterContentsFrame>::sse_encode(self.inactive_frame, serializer);
        <crate::api::api::PhotoPosterContentsSize>::sse_encode(self.image_size, serializer);
        <crate::api::api::PhotoPosterContentsSize>::sse_encode(self.parallax_padding, serializer);
    }
}

impl SseEncode for crate::api::api::PhotoPosterProperties {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::PhotoPosterLayout>::sse_encode(self.portrait_layout, serializer);
        <bool>::sse_encode(self.settling_effect_enabled, serializer);
        <bool>::sse_encode(self.depth_enabled, serializer);
        <f64>::sse_encode(self.clock_area_luminance, serializer);
        <bool>::sse_encode(self.parallax_disabled, serializer);
    }
}

impl SseEncode for crate::api::api::PollResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::PollResult::Stop => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::api::PollResult::Cont(field0) => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::api::PushMessage>>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::PosterAsset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::PhotoPosterContents>::sse_encode(self.contents, serializer);
        <std::collections::HashMap<String, Vec<u8>>>::sse_encode(self.files, serializer);
        <String>::sse_encode(self.uuid, serializer);
    }
}

impl SseEncode for crate::api::api::PosterColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.alpha, serializer);
        <f64>::sse_encode(self.blue, serializer);
        <f64>::sse_encode(self.green, serializer);
        <f64>::sse_encode(self.red, serializer);
    }
}

impl SseEncode for crate::api::api::PosterRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::api::PosterRole::PRPosterRoleBackdrop => 0,
                crate::api::api::PosterRole::PRPosterRoleIncomingCall => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::PosterType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::PosterType::Photo { assets } => {
                <i32>::sse_encode(0, serializer);
                <Vec<crate::api::api::PosterAsset>>::sse_encode(assets, serializer);
            }
            crate::api::api::PosterType::Monogram { data, background } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::MonogramData>::sse_encode(data, serializer);
                <crate::api::api::PosterColor>::sse_encode(background, serializer);
            }
            crate::api::api::PosterType::Memoji { data, background } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::api::MemojiData>::sse_encode(data, serializer);
                <crate::api::api::PosterColor>::sse_encode(background, serializer);
            }
            crate::api::api::PosterType::TranscriptDynamic { data } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::api::TranscriptDynamicUserData>::sse_encode(data, serializer);
            }
            crate::api::api::PosterType::TranscriptGradient { colors } => {
                <i32>::sse_encode(4, serializer);
                <Vec<crate::api::api::PosterColor>>::sse_encode(colors, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::PRPosterColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.preferred_style, serializer);
        <String>::sse_encode(self.identifier, serializer);
        <bool>::sse_encode(self.suggested, serializer);
        <crate::api::api::UIColor>::sse_encode(self.color, serializer);
    }
}

impl SseEncode for crate::api::api::PRPosterContentMaterialStyle {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::PRPosterContentMaterialStyle::PRPosterContentDiscreteColorsStyle {
                variation,
                colors,
                vibrant,
                supports_variation,
                needs_to_resolve_variation,
            } => {
                <i32>::sse_encode(0, serializer);
                <f32>::sse_encode(variation, serializer);
                <Vec<crate::api::api::UIColor>>::sse_encode(colors, serializer);
                <bool>::sse_encode(vibrant, serializer);
                <bool>::sse_encode(supports_variation, serializer);
                <bool>::sse_encode(needs_to_resolve_variation, serializer);
            }
            crate::api::api::PRPosterContentMaterialStyle::PRPosterContentVibrantMaterialStyle => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::api::PRPosterContentMaterialStyle::PRPosterContentGradientStyle {
                gradient_type,
                colors,
                start_point,
                locations,
                end_point,
            } => {
                <i32>::sse_encode(2, serializer);
                <u32>::sse_encode(gradient_type, serializer);
                <Vec<crate::api::api::UIColor>>::sse_encode(colors, serializer);
                <String>::sse_encode(start_point, serializer);
                <Vec<f64>>::sse_encode(locations, serializer);
                <String>::sse_encode(end_point, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::PRPosterSystemTimeFontConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_system_item, serializer);
        <String>::sse_encode(self.time_font_identifier, serializer);
        <f64>::sse_encode(self.weight, serializer);
    }
}

impl SseEncode for crate::api::api::PRPosterTitleStyleConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.alternate_date_enabled, serializer);
        <f64>::sse_encode(self.contents_luminence, serializer);
        <String>::sse_encode(self.group_name, serializer);
        <u32>::sse_encode(self.preferred_title_alignment, serializer);
        <u32>::sse_encode(self.preferred_title_layout, serializer);
        <crate::api::api::PRPosterSystemTimeFontConfiguration>::sse_encode(
            self.time_font_configuration,
            serializer,
        );
        <Option<Vec<u8>>>::sse_encode(self.time_numbering_system, serializer);
        <crate::api::api::PRPosterColor>::sse_encode(self.title_color, serializer);
        <Vec<u8>>::sse_encode(self.title_content_style, serializer);
        <bool>::sse_encode(self.user_configured, serializer);
        <Option<crate::api::api::PRPosterContentMaterialStyle>>::sse_encode(
            self.title_style,
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::PrivateDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.uuid, serializer);
        <Option<String>>::sse_encode(self.device_name, serializer);
        <Vec<u8>>::sse_encode(self.token, serializer);
        <bool>::sse_encode(self.is_hsa_trusted, serializer);
        <Vec<String>>::sse_encode(self.identites, serializer);
        <Vec<String>>::sse_encode(self.sub_services, serializer);
    }
}

impl SseEncode for crate::api::api::PushMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::PushMessage::IMessage(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::MessageInst>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::SendConfirm { uuid, error } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(uuid, serializer);
                <Option<String>>::sse_encode(error, serializer);
            }
            crate::api::api::PushMessage::RegistrationState(field0) => {
                <i32>::sse_encode(2, serializer);
                <crate::api::api::RegisterState>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::NewPhotostream(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::api::api::SharedAlbum>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::FaceTime(field0) => {
                <i32>::sse_encode(4, serializer);
                <crate::api::api::FTMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::StatusUpdate(field0) => {
                <i32>::sse_encode(5, serializer);
                <crate::api::api::StatusKitMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::Idms(field0) => {
                <i32>::sse_encode(6, serializer);
                <crate::api::api::IdmsMessage>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::TwoFaAuthEvent(field0) => {
                <i32>::sse_encode(7, serializer);
                <bool>::sse_encode(field0, serializer);
            }
            crate::api::api::PushMessage::CircleFinishEvent => {
                <i32>::sse_encode(8, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::QuotaInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_bytes, serializer);
        <u64>::sse_encode(self.available_bytes, serializer);
        <u64>::sse_encode(self.messages_bytes, serializer);
    }
}

impl SseEncode for crate::api::api::ReactMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_uuid, serializer);
        <Option<u64>>::sse_encode(self.to_part, serializer);
        <crate::api::api::ReactMessageType>::sse_encode(self.reaction, serializer);
        <String>::sse_encode(self.to_text, serializer);
        <Option<crate::api::api::ShareProfileMessage>>::sse_encode(
            self.embedded_profile,
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::ReactMessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::ReactMessageType::React { reaction, enable } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::Reaction>::sse_encode(reaction, serializer);
                <bool>::sse_encode(enable, serializer);
            }
            crate::api::api::ReactMessageType::Extension {
                spec,
                body,
                is_meta,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::ExtensionApp>::sse_encode(spec, serializer);
                <crate::api::api::MessageParts>::sse_encode(body, serializer);
                <bool>::sse_encode(is_meta, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::Reaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::Reaction::Heart => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::api::Reaction::Like => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::api::Reaction::Dislike => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::api::Reaction::Laugh => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::api::Reaction::Emphasize => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::api::Reaction::Question => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::api::Reaction::Emoji(field0) => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::api::Reaction::Sticker { spec, body } => {
                <i32>::sse_encode(7, serializer);
                <Option<crate::api::api::ExtensionApp>>::sse_encode(spec, serializer);
                <crate::api::api::MessageParts>::sse_encode(body, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode
    for (
        Vec<u8>,
        std::collections::HashMap<String, Option<crate::api::api::CloudAttachment>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <std::collections::HashMap<String, Option<crate::api::api::CloudAttachment>>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode
    for (
        Vec<u8>,
        std::collections::HashMap<String, Option<crate::api::api::CloudChat>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <std::collections::HashMap<String, Option<crate::api::api::CloudChat>>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode
    for (
        Vec<u8>,
        std::collections::HashMap<String, Option<crate::api::api::CloudMessage>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <std::collections::HashMap<String, Option<crate::api::api::CloudMessage>>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode for (Vec<u8>, Option<Vec<u8>>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <Option<Vec<u8>>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (Vec<crate::api::api::SharedAlbum>, Vec<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::api::SharedAlbum>>::sse_encode(self.0, serializer);
        <Vec<String>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        Vec<crate::api::api::TrustedPhoneNumber>,
        Option<crate::api::api::LoginState>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::api::TrustedPhoneNumber>>::sse_encode(self.0, serializer);
        <Option<crate::api::api::LoginState>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (crate::api::api::LoginState, Option<IDSUser>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::LoginState>::sse_encode(self.0, serializer);
        <Option<IDSUser>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        std::collections::HashMap<String, crate::api::api::SyncStatus>,
        Option<(String, u64)>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <std::collections::HashMap<String, crate::api::api::SyncStatus>>::sse_encode(
            self.0, serializer,
        );
        <Option<(String, u64)>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, Asset) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Asset>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, StCollapsedValue) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <StCollapsedValue>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, bool) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <bool>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::CloudAttachment) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::CloudAttachment>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::CloudChat) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::CloudChat>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::CloudMessage) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::CloudMessage>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::FTParticipant) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::FTParticipant>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, Vec<crate::api::api::MessageEdit>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Vec<crate::api::api::MessageEdit>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, Vec<u8>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Vec<u8>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::MessageEditRange) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::MessageEditRange>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, Option<crate::api::api::CloudAttachment>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Option<crate::api::api::CloudAttachment>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, Option<crate::api::api::CloudChat>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Option<crate::api::api::CloudChat>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, Option<crate::api::api::CloudMessage>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Option<crate::api::api::CloudMessage>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::StatusKitPersonalConfig) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::StatusKitPersonalConfig>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::api::api::SyncStatus) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::api::api::SyncStatus>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, u64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <u64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (u32, crate::api::api::NSDictionaryTypedCoder) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.0, serializer);
        <crate::api::api::NSDictionaryTypedCoder>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::api::RegisterState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::RegisterState::Registered { next_s } => {
                <i32>::sse_encode(0, serializer);
                <i64>::sse_encode(next_s, serializer);
            }
            crate::api::api::RegisterState::Registering => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::api::RegisterState::Failed { retry_wait, error } => {
                <i32>::sse_encode(2, serializer);
                <Option<u64>>::sse_encode(retry_wait, serializer);
                <String>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::RegistrationPhase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::api::RegistrationPhase::WantsOSConfig => 0,
                crate::api::api::RegistrationPhase::WantsRegister => 1,
                crate::api::api::RegistrationPhase::Registered => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::RenameMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.new_name, serializer);
    }
}

impl SseEncode for crate::api::api::ReportMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.guid, serializer);
        <String>::sse_encode(self.sender, serializer);
        <u32>::sse_encode(self.conversation_size, serializer);
        <crate::api::api::MessageParts>::sse_encode(self.parts, serializer);
        <f64>::sse_encode(self.time_of_message, serializer);
    }
}

impl SseEncode for crate::api::api::RichLinkImageAttachmentSubstitute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.mime_type, serializer);
        <u64>::sse_encode(self.rich_link_image_attachment_substitute_index, serializer);
    }
}

impl SseEncode for crate::api::api::ScheduleMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.ms, serializer);
        <bool>::sse_encode(self.schedule, serializer);
    }
}

impl SseEncode for crate::api::api::SetTranscriptBackgroundMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::SetTranscriptBackgroundMessage::Remove {
                aid,
                bid,
                chat_id,
                remove,
            } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(aid, serializer);
                <u32>::sse_encode(bid, serializer);
                <Option<String>>::sse_encode(chat_id, serializer);
                <bool>::sse_encode(remove, serializer);
            }
            crate::api::api::SetTranscriptBackgroundMessage::Set {
                aid,
                bid,
                chat_id,
                object_id,
                payload_version,
                background_id,
                url,
                signature,
                key,
                file_size,
            } => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(aid, serializer);
                <u32>::sse_encode(bid, serializer);
                <Option<String>>::sse_encode(chat_id, serializer);
                <String>::sse_encode(object_id, serializer);
                <u32>::sse_encode(payload_version, serializer);
                <String>::sse_encode(background_id, serializer);
                <String>::sse_encode(url, serializer);
                <String>::sse_encode(signature, serializer);
                <String>::sse_encode(key, serializer);
                <usize>::sse_encode(file_size, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::ShareProfileMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.cloud_kit_decryption_record_key, serializer);
        <String>::sse_encode(self.cloud_kit_record_key, serializer);
        <Option<crate::api::api::SharedPoster>>::sse_encode(self.poster, serializer);
    }
}

impl SseEncode for crate::api::api::SharedAlbum {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.fullname, serializer);
        <Option<String>>::sse_encode(self.email, serializer);
        <String>::sse_encode(self.albumguid, serializer);
        <String>::sse_encode(self.sharingtype, serializer);
        <Option<String>>::sse_encode(self.subscriptiondate, serializer);
        <Option<String>>::sse_encode(self.albumlocation, serializer);
        <Vec<String>>::sse_encode(self.assets, serializer);
        <Option<String>>::sse_encode(self.delete, serializer);
    }
}

impl SseEncode for crate::api::api::SharedPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.low_res_wallpaper_tag, serializer);
        <Vec<u8>>::sse_encode(self.wallpaper_tag, serializer);
        <Vec<u8>>::sse_encode(self.message_tag, serializer);
    }
}

impl SseEncode for crate::api::api::SimplifiedIncomingCallPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::SimplifiedPoster>::sse_encode(self.poster, serializer);
        <crate::api::api::WallpaperMetadata>::sse_encode(self.text_metadata, serializer);
        <Vec<u8>>::sse_encode(self.low_res, serializer);
    }
}

impl SseEncode for crate::api::api::SimplifiedPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::PRPosterTitleStyleConfiguration>::sse_encode(
            self.title_configuration,
            serializer,
        );
        <crate::api::api::PosterType>::sse_encode(self.r#type, serializer);
        <crate::api::api::PosterRole>::sse_encode(self.role, serializer);
    }
}

impl SseEncode for crate::api::api::SimplifiedTranscriptPoster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::api::WatchBackground>::sse_encode(self.watch, serializer);
        <crate::api::api::SimplifiedPoster>::sse_encode(self.poster, serializer);
    }
}

impl SseEncode for crate::api::api::StatusKitMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::StatusKitMessage::StatusChanged {
                user,
                mode,
                allowed,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(user, serializer);
                <Option<String>>::sse_encode(mode, serializer);
                <bool>::sse_encode(allowed, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::StatusKitPersonalConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.allowed_modes, serializer);
    }
}

impl SseEncode for crate::api::api::SupportAction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.button, serializer);
    }
}

impl SseEncode for crate::api::api::SupportAlert {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.body, serializer);
        <Option<crate::api::api::SupportAction>>::sse_encode(self.action, serializer);
    }
}

impl SseEncode for crate::api::api::SyncStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::SyncStatus::Synced => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::api::SyncStatus::Downloading { progress, total } => {
                <i32>::sse_encode(1, serializer);
                <usize>::sse_encode(progress, serializer);
                <usize>::sse_encode(total, serializer);
            }
            crate::api::api::SyncStatus::Uploading { progress, total } => {
                <i32>::sse_encode(2, serializer);
                <usize>::sse_encode(progress, serializer);
                <usize>::sse_encode(total, serializer);
            }
            crate::api::api::SyncStatus::Syncing => {
                <i32>::sse_encode(3, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::TeardownSignIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.prevtxnid, serializer);
    }
}

impl SseEncode for crate::api::api::TextEffect {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::api::TextEffect::Big => 0,
                crate::api::api::TextEffect::Small => 1,
                crate::api::api::TextEffect::Shake => 2,
                crate::api::api::TextEffect::Nod => 3,
                crate::api::api::TextEffect::Explode => 4,
                crate::api::api::TextEffect::Ripple => 5,
                crate::api::api::TextEffect::Bloom => 6,
                crate::api::api::TextEffect::Jitter => 7,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::api::TextFlags {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.bold, serializer);
        <bool>::sse_encode(self.italic, serializer);
        <bool>::sse_encode(self.underline, serializer);
        <bool>::sse_encode(self.strikethrough, serializer);
    }
}

impl SseEncode for crate::api::api::TextFormat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::TextFormat::Flags(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::api::TextFlags>::sse_encode(field0, serializer);
            }
            crate::api::api::TextFormat::Effect(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::api::TextEffect>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::api::TranscriptDynamicUserData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.identifier, serializer);
    }
}

impl SseEncode for crate::api::api::TransferProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.prog, serializer);
        <usize>::sse_encode(self.total, serializer);
        <Option<crate::api::api::Attachment>>::sse_encode(self.attachment, serializer);
    }
}

impl SseEncode for crate::api::api::TrustedPhoneNumber {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.number_with_dial_code, serializer);
        <String>::sse_encode(self.last_two_digits, serializer);
        <String>::sse_encode(self.push_mode, serializer);
        <u32>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::api::api::TypingApp {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.bundle_id, serializer);
        <Vec<u8>>::sse_encode(self.icon, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for crate::api::api::UIColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::api::UIColor::RGBAColorSpace {
                color_components,
                green,
                blue,
                red,
                green_dbl,
                blue_dbl,
                red_dbl,
                alpha_dbl,
                alpha,
                rgb,
                color_space,
                class,
            } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(color_components, serializer);
                <f64>::sse_encode(green, serializer);
                <f64>::sse_encode(blue, serializer);
                <f64>::sse_encode(red, serializer);
                <Option<f64>>::sse_encode(green_dbl, serializer);
                <Option<f64>>::sse_encode(blue_dbl, serializer);
                <Option<f64>>::sse_encode(red_dbl, serializer);
                <Option<f64>>::sse_encode(alpha_dbl, serializer);
                <f64>::sse_encode(alpha, serializer);
                <Vec<u8>>::sse_encode(rgb, serializer);
                <u32>::sse_encode(color_space, serializer);
                <String>::sse_encode(class, serializer);
            }
            crate::api::api::UIColor::GrayscaleAlphaColorSpace {
                color_components,
                white,
                alpha,
                bin,
                color_space,
                class,
            } => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(color_components, serializer);
                <f64>::sse_encode(white, serializer);
                <f64>::sse_encode(alpha, serializer);
                <Vec<u8>>::sse_encode(bin, serializer);
                <u32>::sse_encode(color_space, serializer);
                <String>::sse_encode(class, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::api::UnsendMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.tuuid, serializer);
        <u64>::sse_encode(self.edit_part, serializer);
    }
}

impl SseEncode for crate::api::api::UpdateExtensionMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.for_uuid, serializer);
        <crate::api::api::PartExtension>::sse_encode(self.ext, serializer);
    }
}

impl SseEncode for crate::api::api::UpdateProfileMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::api::ShareProfileMessage>>::sse_encode(self.profile, serializer);
        <bool>::sse_encode(self.share_contacts, serializer);
    }
}

impl SseEncode for crate::api::api::UpdateProfileSharingMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.shared_dismissed, serializer);
        <Vec<String>>::sse_encode(self.shared_all, serializer);
        <u64>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::api::WallpaperMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::api::PosterColor>>::sse_encode(self.background_color_key, serializer);
        <crate::api::api::PosterColor>::sse_encode(self.font_color_key, serializer);
        <String>::sse_encode(self.font_name_key, serializer);
        <f32>::sse_encode(self.font_size_key, serializer);
        <f32>::sse_encode(self.font_weight_key, serializer);
        <bool>::sse_encode(self.is_vertical_key, serializer);
        <String>::sse_encode(self.type_key, serializer);
    }
}

impl SseEncode for crate::api::api::WatchBackground {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_high_key, serializer);
        <f64>::sse_encode(self.luminance, serializer);
        <Vec<u8>>::sse_encode(self.background_image_data, serializer);
        <String>::sse_encode(self.extension_identifier, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // Generated by `flutter_rust_bridge`@ 2.3.0.

    // Section: imports

    use super::*;
    use crate::api::api::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcPushState(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < PushState >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcPushState(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < PushState >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAsset(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAsset(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Asset>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConversationLink(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConversationLink(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConversationParticipant(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConversationParticipant(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDate(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Date>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDate(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Date>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEscrowData(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEscrowData(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EscrowData>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFindMyFriendsClientDefaultAnisetteProvider(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyFriendsClient<DefaultAnisetteProvider>,
            >,
        >::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFindMyFriendsClientDefaultAnisetteProvider(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyFriendsClient<DefaultAnisetteProvider>,
            >,
        >::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFindMyPhoneClientDefaultAnisetteProvider(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyPhoneClient<DefaultAnisetteProvider>,
            >,
        >::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFindMyPhoneClientDefaultAnisetteProvider(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FindMyPhoneClient<DefaultAnisetteProvider>,
            >,
        >::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperAttachmentMeta(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>,
        >::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperAttachmentMeta(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper<AttachmentMeta>>,
        >::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperChatProto(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < ChatProto >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperChatProto(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < ChatProto >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto2(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto2 >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto2(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto2 >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto3(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto3 >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto3(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto3 >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto4(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto4 >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGZipWrapperMessageProto4(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GZipWrapper < MessageProto4 >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIDSUser(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIDSUser(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJoinedOSConfig(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJoinedOSConfig(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageFlags(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageFlags(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageFlags>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNSArrayLPIconMetadata(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray < LPIconMetadata >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNSArrayLPIconMetadata(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray < LPIconMetadata >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNSArrayLPImageMetadata(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray < LPImageMetadata >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNSArrayLPImageMetadata(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NSArray < LPImageMetadata >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPushError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPushError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PushError>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStCollapsedValue(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStCollapsedValue(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StCollapsedValue>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSystemTime(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSystemTime(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SystemTime>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVerifyBody(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVerifyBody(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerViableBottle(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerViableBottle(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ViableBottle>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
